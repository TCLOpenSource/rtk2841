/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include <memory.h> /* for memset */
#include <AudioRPC_System.h>
#include <ClientStub.h>

#include <RPCBaseDS.h>
#include <AudioRPCBaseDS.h>

RPCRES_LONG *
AUDIO_RPC_ToAgent_Create_0(AUDIO_RPC_INSTANCE *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	RPCRES_LONG * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_INSTANCE );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (RPCRES_LONG *) malloc(sizeof(RPCRES_LONG ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_Create, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_INSTANCE, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (RPCRES_LONG *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(RPCRES_LONG), XDR_DECODE);
		 if(!xdr_RPCRES_LONG(&xdrs, result))
			 return (RPCRES_LONG *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_Connect_0(AUDIO_RPC_CONNECTION *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_CONNECTION );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_Connect, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_CONNECTION, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_InitRingBufferHeader_0(AUDIO_RPC_RINGBUFFER_HEADER *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_RINGBUFFER_HEADER );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_InitRingBufferHeader, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_RINGBUFFER_HEADER, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_Run_0(long *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(long );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_Run, clnt->sendMode,
		(xdrproc_t) xdr_long, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_Pause_0(long *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(long );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_Pause, clnt->sendMode,
		(xdrproc_t) xdr_long, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_Stop_0(long *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(long );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_Stop, clnt->sendMode,
		(xdrproc_t) xdr_long, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_Destroy_0(long *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(long );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_Destroy, clnt->sendMode,
		(xdrproc_t) xdr_long, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_Flush_0(AUDIO_RPC_SENDIO *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_SENDIO );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_Flush, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_SENDIO, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_SetRefClock_0(AUDIO_RPC_REFCLOCK *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_REFCLOCK );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_SetRefClock, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_REFCLOCK, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

RPCRES_LONG *
AUDIO_RPC_ToAgent_GetStatus_0(AUDIO_RPC_SEND_LONG *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	RPCRES_LONG * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_SEND_LONG );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (RPCRES_LONG *) malloc(sizeof(RPCRES_LONG ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_GetStatus, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_SEND_LONG, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (RPCRES_LONG *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(RPCRES_LONG), XDR_DECODE);
		 if(!xdr_RPCRES_LONG(&xdrs, result))
			 return (RPCRES_LONG *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_SetSeeking_0(AUDIO_RPC_SEEK *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_SEEK );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_SetSeeking, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_SEEK, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_DisConnect_0(AUDIO_RPC_CONNECTION *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_CONNECTION );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_DisConnect, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_CONNECTION, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

AUDIO_RPC_FORMAT_INFO *
AUDIO_RPC_ToAgent_BitstreamValidation_0(AUDIO_RPC_DEC_BITSTREAM_BUFFER *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	AUDIO_RPC_FORMAT_INFO * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_DEC_BITSTREAM_BUFFER );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (AUDIO_RPC_FORMAT_INFO *) malloc(sizeof(AUDIO_RPC_FORMAT_INFO ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_BitstreamValidation, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_DEC_BITSTREAM_BUFFER, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (AUDIO_RPC_FORMAT_INFO *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(AUDIO_RPC_FORMAT_INFO), XDR_DECODE);
		 if(!xdr_AUDIO_RPC_FORMAT_INFO(&xdrs, result))
			 return (AUDIO_RPC_FORMAT_INFO *)-1;
		return result;
	}

	return 0;

}

int *
AUDIO_RPC_AO_ToAgent_IsFinishPlaySoundEvent_0(int *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	int * result = NULL ;
	long args_size = sizeof(int );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (int *) malloc(sizeof(int ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_AO_ToAgent_IsFinishPlaySoundEvent, clnt->sendMode,
		(xdrproc_t) xdr_int, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (int *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(int), XDR_DECODE);
		 if(!xdr_int(&xdrs, result))
			 return (int *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_AudioConfig_0(AUDIO_CONFIG_COMMAND *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_CONFIG_COMMAND );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_AudioConfig, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_CONFIG_COMMAND, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_DEC_ToAgent_Init_0(AUDIO_RPC_DEC_INIT *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_DEC_INIT );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_DEC_ToAgent_Init, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_DEC_INIT, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_DEC_ToAgent_SkipMode_0(AUDIO_RPC_SEND_LONG *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_SEND_LONG );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_DEC_ToAgent_SkipMode, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_SEND_LONG, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_DEC_ToAgent_SetDualMonoOutMode_0(AUDIO_RPC_CHANNEL_OUT_MODE *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_CHANNEL_OUT_MODE );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_DEC_ToAgent_SetDualMonoOutMode, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_CHANNEL_OUT_MODE, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

AUDIO_RPC_GET_PTS_INFO *
AUDIO_RPC_DEC_ToAgent_GetPTS_0(long *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	AUDIO_RPC_GET_PTS_INFO * result = NULL ;
	long args_size = sizeof(long );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (AUDIO_RPC_GET_PTS_INFO *) malloc(sizeof(AUDIO_RPC_GET_PTS_INFO ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_DEC_ToAgent_GetPTS, clnt->sendMode,
		(xdrproc_t) xdr_long, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (AUDIO_RPC_GET_PTS_INFO *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(AUDIO_RPC_GET_PTS_INFO), XDR_DECODE);
		 if(!xdr_AUDIO_RPC_GET_PTS_INFO(&xdrs, result))
			 return (AUDIO_RPC_GET_PTS_INFO *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ENC_ToAgent_Init_0(AUDIO_RPC_ENC_INIT *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_ENC_INIT );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ENC_ToAgent_Init, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_ENC_INIT, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ENC_ToAgent_SetBitRate_0(AUDIO_RPC_ENC_SET_BITRATE *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_ENC_SET_BITRATE );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ENC_ToAgent_SetBitRate, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_ENC_SET_BITRATE, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ENC_ToAgent_StartEncoder_0(AUDIO_RPC_SEND_LONG *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_SEND_LONG );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ENC_ToAgent_StartEncoder, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_SEND_LONG, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ENC_ToAgent_PauseEncoder_0(AUDIO_RPC_SEND_LONG *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_SEND_LONG );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ENC_ToAgent_PauseEncoder, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_SEND_LONG, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ENC_ToAgent_StopEncoder_0(AUDIO_RPC_SEND_LONG *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_SEND_LONG );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ENC_ToAgent_StopEncoder, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_SEND_LONG, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ENC_ToAgent_SetSourceFile_0(AUDIO_RPC_ENC_SOURCEFILE *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_ENC_SOURCEFILE );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ENC_ToAgent_SetSourceFile, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_ENC_SOURCEFILE, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ENC_ToAgent_Command_0(AUDIO_RPC_ENC_COMMAND *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_ENC_COMMAND );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ENC_ToAgent_Command, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_ENC_COMMAND, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ENC_ToAgent_MuteEncoder_0(AUDIO_RPC_SEND_LONG *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_SEND_LONG );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ENC_ToAgent_MuteEncoder, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_SEND_LONG, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ENC_SetEncoder_0(AUDIO_RPC_ENC_INFO *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_ENC_INFO );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ENC_SetEncoder, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_ENC_INFO, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ENC_ToAgent_SetDVMixer_0(AUDIO_RPC_ENC_DV_MIXER *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_ENC_DV_MIXER );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ENC_ToAgent_SetDVMixer, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_ENC_DV_MIXER, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ENC_ToAgent_SetNonRealTime_0(AUDIO_RPC_SEND_LONG *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_SEND_LONG );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ENC_ToAgent_SetNonRealTime, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_SEND_LONG, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ENC_ToAgent_SetInputSR_0(AUDIO_RPC_SEND_LONG *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_SEND_LONG );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ENC_ToAgent_SetInputSR, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_SEND_LONG, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_AO_ToAgent_Init_0(AUDIO_RPC_AO_INIT *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_AO_INIT );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_AO_ToAgent_Init, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_AO_INIT, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_AO_ToAgent_SetEaqualizer_0(AUDIO_RPC_AO_SET_EQUALIZER *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_AO_SET_EQUALIZER );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_AO_ToAgent_SetEaqualizer, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_AO_SET_EQUALIZER, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_AO_ToAgent_ConfigDelayControl_0(AUDIO_AO_RPC_CONFIG_DELAY_CONTROL *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_AO_RPC_CONFIG_DELAY_CONTROL );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_AO_ToAgent_ConfigDelayControl, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_AO_RPC_CONFIG_DELAY_CONTROL, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_AO_ToAgent_ConfigKaraoke_0(AUDIO_RPC_AO_CONFIG_KARAOKE *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_AO_CONFIG_KARAOKE );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_AO_ToAgent_ConfigKaraoke, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_AO_CONFIG_KARAOKE, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_AO_ToAgent_ConfigMixer_0(AUDIO_RPC_AO_MIXER *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_AO_MIXER );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_AO_ToAgent_ConfigMixer, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_AO_MIXER, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_AO_ToAgent_ConfigPP_0(AUDIO_RPC_PP_CFG *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_PP_CFG );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_AO_ToAgent_ConfigPP, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_PP_CFG, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_AO_ToAgent_Mute_0(AUDIO_OUT_MUTE_INFO *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_OUT_MUTE_INFO );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_AO_ToAgent_Mute, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_OUT_MUTE_INFO, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_AO_ToAgent_ConfigDAC_0(AUDIO_RPC_AO_DAC *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_AO_DAC );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_AO_ToAgent_ConfigDAC, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_AO_DAC, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_AO_ToAgent_ConfigPrologic_0(AUDIO_RPC_PP_PROLOGIC *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_PP_PROLOGIC );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_AO_ToAgent_ConfigPrologic, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_PP_PROLOGIC, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_AO_ToAgent_SPDIFO_Source_Config_0(AUDIO_RPC_SPDIFO_SOURCE *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_SPDIFO_SOURCE );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_AO_ToAgent_SPDIFO_Source_Config, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_SPDIFO_SOURCE, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_AO_ToAgent_ResampleTable_0(AUDIO_RPC_RESAMPLE_INFO *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_RESAMPLE_INFO );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_AO_ToAgent_ResampleTable, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_RESAMPLE_INFO, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_ADC0_Config_0(AUDIO_CONFIG_ADC *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_CONFIG_ADC );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_ADC0_Config, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_CONFIG_ADC, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_ADC1_Config_0(AUDIO_CONFIG_ADC *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_CONFIG_ADC );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_ADC1_Config, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_CONFIG_ADC, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_SPDIF_Config_0(AUDIO_CONFIG_SPDIF *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_CONFIG_SPDIF );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_SPDIF_Config, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_CONFIG_SPDIF, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_AI_BackDoor_Init_0(AUDIO_BACKDOOR_AI_INIT *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_BACKDOOR_AI_INIT );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_AI_BackDoor_Init, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_BACKDOOR_AI_INIT, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_SPDIF_Err_Threshold_Config_0(AUDIO_CONFIG_SPDIF_ERR *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_CONFIG_SPDIF_ERR );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_SPDIF_Err_Threshold_Config, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_CONFIG_SPDIF_ERR, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_AIN_Switch_Focus_0(AUDIO_IN_SOURCE *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_IN_SOURCE );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_AIN_Switch_Focus, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_IN_SOURCE, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_AOUT_Copy_Source_0(AUDIO_OUT_COPY_SOURCE *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_OUT_COPY_SOURCE );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_AOUT_Copy_Source, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_OUT_COPY_SOURCE, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_AOUT_Volume_Control_0(AUDIO_VOLUME_CONTROL *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_VOLUME_CONTROL );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_AOUT_Volume_Control, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_VOLUME_CONTROL, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_AOUT_SPDIF_Source_0(AUDIO_OUT_SPDIF_SOURCE *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_OUT_SPDIF_SOURCE );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_AOUT_SPDIF_Source, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_OUT_SPDIF_SOURCE, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_Karaoke_Control_0(AUDIO_KARAOKE_CONTROL_INFO *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_KARAOKE_CONTROL_INFO );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_Karaoke_Control, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_KARAOKE_CONTROL_INFO, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_AIN_Mute_0(AUDIO_IN_MUTE_INFO *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_IN_MUTE_INFO );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_AIN_Mute, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_IN_MUTE_INFO, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_AOUT_Drop_Sample_0(AUDIO_DROP_SAMPLE *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_DROP_SAMPLE );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_AOUT_Drop_Sample, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_DROP_SAMPLE, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_AOUT_Pink_White_Noise_0(AUDIO_P_W_NOISE_CFG *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_P_W_NOISE_CFG );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_AOUT_Pink_White_Noise, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_P_W_NOISE_CFG, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_AOUT_Send_Spectrum_Data_0(AUDIO_SPECTRUM_CFG *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_SPECTRUM_CFG );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_AOUT_Send_Spectrum_Data, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_SPECTRUM_CFG, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_PlaySoundEvent_0(AUDIO_SOUND_EVENT *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_SOUND_EVENT );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_PlaySoundEvent, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_SOUND_EVENT, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_AOUT_ResetPin_0(long *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(long );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_AOUT_ResetPin, clnt->sendMode,
		(xdrproc_t) xdr_long, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_AFC_Config_0(AUDIO_CONFIG_AFC *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_CONFIG_AFC );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_AFC_Config, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_CONFIG_AFC, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_Audistry_Config_0(AUDISTRY_CONFIG_COMMAND *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDISTRY_CONFIG_COMMAND );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_Audistry_Config, clnt->sendMode,
		(xdrproc_t) xdr_AUDISTRY_CONFIG_COMMAND, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_HDMI_Mute_0(AUDIO_HDMI_MUTE_INFO *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_HDMI_MUTE_INFO );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_HDMI_Mute, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_HDMI_MUTE_INFO, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_ADC2_Config_0(AUDIO_CONFIG_ADC *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_CONFIG_ADC );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_ADC2_Config, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_CONFIG_ADC, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_AOUT_HDMI_Set_0(AUDIO_HDMI_SET *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_HDMI_SET );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_AOUT_HDMI_Set, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_HDMI_SET, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_AO_Only_Switchfocus_0(AUDIO_RPC_AO_FOCUS *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_AO_FOCUS );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_AO_Only_Switchfocus, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_AO_FOCUS, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_AIN_Data_Measurement_0(AUDIO_IN_DATA_MEASURE *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_IN_DATA_MEASURE );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_AIN_Data_Measurement, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_IN_DATA_MEASURE, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_BBADC_Config_0(AUDIO_RPC_BBADC_CONFIG *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_BBADC_CONFIG );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_BBADC_Config, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_BBADC_CONFIG, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_I2SI_Config_0(AUDIO_RPC_I2SI_CONFIG *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_I2SI_CONFIG );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_I2SI_Config, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_I2SI_CONFIG, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_SPDIFI_Config_0(AUDIO_RPC_SPDIFI_CONFIG *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_SPDIFI_CONFIG );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_SPDIFI_Config, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_SPDIFI_CONFIG, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_ChangeInputSource_0(AUDIO_RPC_IPT_SRC *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_IPT_SRC );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_ChangeInputSource, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_IPT_SRC, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_SET_ATV_CLOCK_0(AUDIO_RPC_SET_ATV_CLOCK *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_SET_ATV_CLOCK );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_SET_ATV_CLOCK, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_SET_ATV_CLOCK, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_INOUT_CH_SELECT_0(AUDIO_RPC_INOUT_CH_SELECT *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_INOUT_CH_SELECT );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_INOUT_CH_SELECT, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_INOUT_CH_SELECT, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_SET_FS_CLOCKSRC_0(AUDIO_RPC_SET_FS_CLOCKSRC *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_SET_FS_CLOCKSRC );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_SET_FS_CLOCKSRC, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_SET_FS_CLOCKSRC, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_SET_PATH_DATA_OUT_0(AUDIO_RPC_SET_PATH_DATA_OUT *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_SET_PATH_DATA_OUT );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_SET_PATH_DATA_OUT, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_SET_PATH_DATA_OUT, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_SET_INTERLEAVE_OUT_0(AUDIO_RPC_SET_INTERLEAVE_OUT *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_SET_INTERLEAVE_OUT );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_SET_INTERLEAVE_OUT, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_SET_INTERLEAVE_OUT, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_SET_CHANNEL_OUT_SWAP_0(AUDIO_RPC_AO_CHANNEL_OPT_SWAP *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_AO_CHANNEL_OPT_SWAP );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_SET_CHANNEL_OUT_SWAP, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_AO_CHANNEL_OPT_SWAP, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_SetAuthorityKey_0(long *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(long );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_SetAuthorityKey, clnt->sendMode,
		(xdrproc_t) xdr_long, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_GET_SPDIF_CS_0(AUDIO_SPDIF_CS *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_SPDIF_CS );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_GET_SPDIF_CS, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_SPDIF_CS, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_SET_SIF_ADC_INIT_0(AUDIO_RPC_SET_SIF_ADC_INIT *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_SET_SIF_ADC_INIT );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_SET_SIF_ADC_INIT, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_SET_SIF_ADC_INIT, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_HDMI_OUT_EDID_0(AUDIO_HDMI_OUT_EDID_DATA *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_HDMI_OUT_EDID_DATA );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_HDMI_OUT_EDID, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_HDMI_OUT_EDID_DATA, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_HDMI_INFO_0(HDMI_INFO *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(HDMI_INFO );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_HDMI_INFO, clnt->sendMode,
		(xdrproc_t) xdr_HDMI_INFO, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_UpdatePTS_0(AUDIO_RPC_PTS_INFO *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_PTS_INFO );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_UpdatePTS, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_PTS_INFO, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_EndOfStream_0(AUDIO_RPC_SENDPIN_LONG *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_SENDPIN_LONG );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_EndOfStream, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_SENDPIN_LONG, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_SwitchFocus_0(AUDIO_RPC_FOCUS *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_FOCUS );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_SwitchFocus, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_FOCUS, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_DAC_I2S_Config_0(AUDIO_CONFIG_DAC_I2S *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_CONFIG_DAC_I2S );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_DAC_I2S_Config, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_CONFIG_DAC_I2S, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_DAC_SPDIF_Config_0(AUDIO_CONFIG_DAC_SPDIF *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_CONFIG_DAC_SPDIF );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_DAC_SPDIF_Config, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_CONFIG_DAC_SPDIF, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_HDMI_OUT_VSDB_0(AUDIO_HDMI_OUT_VSDB_DATA *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_HDMI_OUT_VSDB_DATA );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_HDMI_OUT_VSDB, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_HDMI_OUT_VSDB_DATA, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_HDMI_OUT_EDID2_0(AUDIO_HDMI_OUT_EDID_DATA2 *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_HDMI_OUT_EDID_DATA2 );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_HDMI_OUT_EDID2, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_HDMI_OUT_EDID_DATA2, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_DecoderConfig_0(AUDIO_RPC_DECCFG *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_DECCFG );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_DecoderConfig, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_DECCFG, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_NightMode_0(AUDIO_RPC_NIGHTMODE *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_NIGHTMODE );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_NightMode, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_NIGHTMODE, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_PP_InitPin_0(long *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(long );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_PP_InitPin, clnt->sendMode,
		(xdrproc_t) xdr_long, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_AskDebugMemoryAddress_0(u_long *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(u_long );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_AskDebugMemoryAddress, clnt->sendMode,
		(xdrproc_t) xdr_u_long, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_PP_Config_0(AUDIO_PP_CONFIG *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_PP_CONFIG );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_PP_Config, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_PP_CONFIG, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_PP_SRC_Config_0(AUDIO_SRC_CONFIG *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_SRC_CONFIG );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_PP_SRC_Config, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_SRC_CONFIG, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_PP_PL2_Config_0(AUDIO_PROLOGIC2_CONFIG *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_PROLOGIC2_CONFIG );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_PP_PL2_Config, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_PROLOGIC2_CONFIG, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_PP_MIXER_Config_0(AUDIO_MIXER_CONFIG *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_MIXER_CONFIG );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_PP_MIXER_Config, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_MIXER_CONFIG, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_PP_BASS_MANAGEMENT_Config_0(AUDIO_BASS_MANAGEMENT_CONFIG *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_BASS_MANAGEMENT_CONFIG );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_PP_BASS_MANAGEMENT_Config, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_BASS_MANAGEMENT_CONFIG, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_PP_KEY_SHIFT_Config_0(AUDIO_KEY_SHIFT_CONFIG *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_KEY_SHIFT_CONFIG );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_PP_KEY_SHIFT_Config, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_KEY_SHIFT_CONFIG, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_PP_REVERB_Config_0(AUDIO_REVERB_CONFIG *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_REVERB_CONFIG );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_PP_REVERB_Config, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_REVERB_CONFIG, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_PP_COMFORT_LISTEN_0(AUDIO_AGC_MODE *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_AGC_MODE );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_PP_COMFORT_LISTEN, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_AGC_MODE, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_PP_EQ_Config_0(AUDIO_EQUALIZER_CONFIG *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_EQUALIZER_CONFIG );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_PP_EQ_Config, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_EQUALIZER_CONFIG, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_PP_VOCAL_REMOVER_Config_0(AUDIO_VOCAL_REMOVER_CONFIG *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_VOCAL_REMOVER_CONFIG );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_PP_VOCAL_REMOVER_Config, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_VOCAL_REMOVER_CONFIG, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

AUDIO_RPC_DEC_FORMAT_INFO *
AUDIO_RPC_DEC_ToAgent_GetAudioFormatInfo_0(long *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	AUDIO_RPC_DEC_FORMAT_INFO * result = NULL ;
	long args_size = sizeof(long );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (AUDIO_RPC_DEC_FORMAT_INFO *) malloc(sizeof(AUDIO_RPC_DEC_FORMAT_INFO ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_DEC_ToAgent_GetAudioFormatInfo, clnt->sendMode,
		(xdrproc_t) xdr_long, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (AUDIO_RPC_DEC_FORMAT_INFO *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(AUDIO_RPC_DEC_FORMAT_INFO), XDR_DECODE);
		 if(!xdr_AUDIO_RPC_DEC_FORMAT_INFO(&xdrs, result))
			 return (AUDIO_RPC_DEC_FORMAT_INFO *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_PP_DVS_Config_0(AUDIO_DVS_CONFIG *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_DVS_CONFIG );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_PP_DVS_Config, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_DVS_CONFIG, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_PP_TSXT_Config_0(AUDIO_RPC_TSXT *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_TSXT );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_PP_TSXT_Config, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_TSXT, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_PP_PTS_MIXER_Config_0(AUDIO_RPC_PTS_MIXER_CONFIG *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_PTS_MIXER_CONFIG );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_PP_PTS_MIXER_Config, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_PTS_MIXER_CONFIG, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_PP_BASSBACK_PCBU_Config_0(AUDIO_RPC_PCBU_BASSBACK *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_PCBU_BASSBACK );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_PP_BASSBACK_PCBU_Config, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_PCBU_BASSBACK, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_PP_BASSBACK_TV_Config_0(AUDIO_RPC_TV_BASSBACK *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_TV_BASSBACK );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_PP_BASSBACK_TV_Config, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_TV_BASSBACK, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_PP_BASSBACK_Change_Bass_Gain_0(AUDIO_RPC_TV_BASSBACK_CHANGE_BASS_GAIN *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_TV_BASSBACK_CHANGE_BASS_GAIN );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_PP_BASSBACK_Change_Bass_Gain, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_TV_BASSBACK_CHANGE_BASS_GAIN, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_PP_AGC_0(AUDIO_RPC_PP_AGC *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_PP_AGC );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_PP_AGC, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_PP_AGC, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_PP_TRUVOLUME_Config_0(AUDIO_RPC_TRUVOLUME *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_TRUVOLUME );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_PP_TRUVOLUME_Config, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_TRUVOLUME, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_PP_FREQ_EQ_Config_0(AUDIO_RPC_FREQ_EQ *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_FREQ_EQ );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_PP_FREQ_EQ_Config, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_FREQ_EQ, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_PP_ASF_ON_OFF_Config_0(AUDIO_RPC_PP_ASF_ON_OFF *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_PP_ASF_ON_OFF );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_PP_ASF_ON_OFF_Config, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_PP_ASF_ON_OFF, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_PP_ASF_BALANCE_Config_0(AUDIO_RPC_PP_ASF_BALANCE *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_PP_ASF_BALANCE );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_PP_ASF_BALANCE_Config, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_PP_ASF_BALANCE, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_PP_ASF_VOLUME_Config_0(AUDIO_RPC_PP_ASF_MASTER_VOLUME *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_PP_ASF_MASTER_VOLUME );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_PP_ASF_VOLUME_Config, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_PP_ASF_MASTER_VOLUME, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_SubChannel_0(AUDIO_RPC_SUBCHANNEL *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_SUBCHANNEL );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_SubChannel, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_SUBCHANNEL, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_TrueHD_LosslessMode_0(AUDIO_RPC_TRUEHD_LOSSLESSMODE *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_TRUEHD_LOSSLESSMODE );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_TrueHD_LosslessMode, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_TRUEHD_LOSSLESSMODE, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_PP_TSHD_Config_0(AUDIO_RPC_TSHD *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_TSHD );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_PP_TSHD_Config, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_TSHD, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_AO_LGSE_SetMode_0(AUDIO_RPC_LGSE_SETMODE *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_LGSE_SETMODE );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_AO_LGSE_SetMode, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_LGSE_SETMODE, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_AO_LGSE_SetMain_0(AUDIO_RPC_LGSE_SETMAIN *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_LGSE_SETMAIN );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_AO_LGSE_SetMain, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_LGSE_SETMAIN, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_AO_LGSE_SetFn000_0(AUDIO_RPC_LGSE_SETFN000 *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_LGSE_SETFN000 );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_AO_LGSE_SetFn000, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_LGSE_SETFN000, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_AO_LGSE_SetFn001_0(AUDIO_RPC_LGSE_SETFN001 *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_LGSE_SETFN001 );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_AO_LGSE_SetFn001, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_LGSE_SETFN001, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_AO_LGSE_SetFn009_0(AUDIO_RPC_LGSE_SETFN009 *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_LGSE_SETFN009 );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_AO_LGSE_SetFn009, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_LGSE_SETFN009, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

AUDIO_RPC_LGSE_RETURNVAL *
AUDIO_RPC_ToAgent_AO_LGSE_SetFn010_0(AUDIO_RPC_LGSE_SETFN010 *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	AUDIO_RPC_LGSE_RETURNVAL * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_LGSE_SETFN010 );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (AUDIO_RPC_LGSE_RETURNVAL *) malloc(sizeof(AUDIO_RPC_LGSE_RETURNVAL ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_AO_LGSE_SetFn010, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_LGSE_SETFN010, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (AUDIO_RPC_LGSE_RETURNVAL *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(AUDIO_RPC_LGSE_RETURNVAL), XDR_DECODE);
		 if(!xdr_AUDIO_RPC_LGSE_RETURNVAL(&xdrs, result))
			 return (AUDIO_RPC_LGSE_RETURNVAL *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_AO_LGSE_SetFn004_0(AUDIO_RPC_LGSE_SETFN004 *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_LGSE_SETFN004 );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_AO_LGSE_SetFn004, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_LGSE_SETFN004, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_AO_LGSE_SetFn005_0(AUDIO_RPC_LGSE_SETFN005 *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_LGSE_SETFN005 );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_AO_LGSE_SetFn005, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_LGSE_SETFN005, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_AO_LGSE_SetFn008_0(AUDIO_RPC_LGSE_SETFN008 *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_LGSE_SETFN008 );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_AO_LGSE_SetFn008, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_LGSE_SETFN008, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_AO_LGSE_SetFn014_0(AUDIO_RPC_LGSE_SETFN014 *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_LGSE_SETFN014 );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_AO_LGSE_SetFn014, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_LGSE_SETFN014, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_AO_LGSE_SetFn017_0(AUDIO_RPC_LGSE_SETFN017 *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_LGSE_SETFN017 );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_AO_LGSE_SetFn017, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_LGSE_SETFN017, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_AO_LGSE_SetFn019_0(AUDIO_RPC_LGSE_SETFN019 *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_LGSE_SETFN019 );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_AO_LGSE_SetFn019, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_LGSE_SETFN019, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_AO_LGSE_SetFn022_0(AUDIO_RPC_LGSE_SETFN022 *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_LGSE_SETFN022 );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_AO_LGSE_SetFn022, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_LGSE_SETFN022, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_AO_LGSE_SetFn018_0(AUDIO_RPC_LGSE_SETFN018 *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_LGSE_SETFN018 );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_AO_LGSE_SetFn018, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_LGSE_SETFN018, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_AO_LGSE_SetFn026_0(AUDIO_RPC_LGSE_SETFN026 *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_LGSE_SETFN026 );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_AO_LGSE_SetFn026, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_LGSE_SETFN026, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_AO_LGSE_SetFn027_0(AUDIO_RPC_LGSE_SETFN027 *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_LGSE_SETFN027 );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_AO_LGSE_SetFn027, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_LGSE_SETFN027, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_AO_LGSE_SetFn028_0(AUDIO_RPC_LGSE_SETFN028 *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_LGSE_SETFN028 );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_AO_LGSE_SetFn028, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_LGSE_SETFN028, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_AO_LGSE_SetFn029_0(AUDIO_RPC_LGSE_SETFN029 *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_LGSE_SETFN029 );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_AO_LGSE_SetFn029, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_LGSE_SETFN029, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

AUDIO_RPC_LGSE_RETURNVAL *
AUDIO_RPC_ToAgent_AO_LGSE_GetData_0(AUDIO_RPC_LGSE_GETDATA *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	AUDIO_RPC_LGSE_RETURNVAL * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_LGSE_GETDATA );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (AUDIO_RPC_LGSE_RETURNVAL *) malloc(sizeof(AUDIO_RPC_LGSE_RETURNVAL ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_AO_LGSE_GetData, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_LGSE_GETDATA, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (AUDIO_RPC_LGSE_RETURNVAL *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(AUDIO_RPC_LGSE_RETURNVAL), XDR_DECODE);
		 if(!xdr_AUDIO_RPC_LGSE_RETURNVAL(&xdrs, result))
			 return (AUDIO_RPC_LGSE_RETURNVAL *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_AO_LGSE_SetFn024_0(AUDIO_RPC_LGSE_SETFN024 *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_LGSE_SETFN024 );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_AO_LGSE_SetFn024, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_LGSE_SETFN024, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

AUDIO_RPC_DEC_SEEKING_CAP *
AUDIO_RPC_DEC_ToAgent_GetAudioDecoderSeekCap_0(AUDIO_DEC_TYPE *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	AUDIO_RPC_DEC_SEEKING_CAP * result = NULL ;
	long args_size = sizeof(AUDIO_DEC_TYPE );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (AUDIO_RPC_DEC_SEEKING_CAP *) malloc(sizeof(AUDIO_RPC_DEC_SEEKING_CAP ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_DEC_ToAgent_GetAudioDecoderSeekCap, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_DEC_TYPE, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (AUDIO_RPC_DEC_SEEKING_CAP *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(AUDIO_RPC_DEC_SEEKING_CAP), XDR_DECODE);
		 if(!xdr_AUDIO_RPC_DEC_SEEKING_CAP(&xdrs, result))
			 return (AUDIO_RPC_DEC_SEEKING_CAP *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_Capability_SetMask_0(long *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(long );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_Capability_SetMask, clnt->sendMode,
		(xdrproc_t) xdr_long, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

AUDIO_RPC_AIN_FORMAT_INFO *
AUDIO_RPC_AIN_ToAgent_GetAudioFormatInfo_0(long *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	AUDIO_RPC_AIN_FORMAT_INFO * result = NULL ;
	long args_size = sizeof(long );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (AUDIO_RPC_AIN_FORMAT_INFO *) malloc(sizeof(AUDIO_RPC_AIN_FORMAT_INFO ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_AIN_ToAgent_GetAudioFormatInfo, clnt->sendMode,
		(xdrproc_t) xdr_long, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (AUDIO_RPC_AIN_FORMAT_INFO *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(AUDIO_RPC_AIN_FORMAT_INFO), XDR_DECODE);
		 if(!xdr_AUDIO_RPC_AIN_FORMAT_INFO(&xdrs, result))
			 return (AUDIO_RPC_AIN_FORMAT_INFO *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_AudioHalt_0(long *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(long );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_AudioHalt, clnt->sendMode,
		(xdrproc_t) xdr_long, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_Full_Capability_SetMask_0(AUDIO_LICENSE_STATUS_CONFIG *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_LICENSE_STATUS_CONFIG );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_Full_Capability_SetMask, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_LICENSE_STATUS_CONFIG, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

AUDIO_RPC_PRIVATEINFO_RETURNVAL *
AUDIO_RPC_ToAgent_PrivateInfo_0(AUDIO_RPC_PRIVATEINFO_PARAMETERS *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	AUDIO_RPC_PRIVATEINFO_RETURNVAL * result = NULL ;
	long args_size = sizeof(AUDIO_RPC_PRIVATEINFO_PARAMETERS );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (AUDIO_RPC_PRIVATEINFO_RETURNVAL *) malloc(sizeof(AUDIO_RPC_PRIVATEINFO_RETURNVAL ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_PrivateInfo, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_RPC_PRIVATEINFO_PARAMETERS, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (AUDIO_RPC_PRIVATEINFO_RETURNVAL *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(AUDIO_RPC_PRIVATEINFO_RETURNVAL), XDR_DECODE);
		 if(!xdr_AUDIO_RPC_PRIVATEINFO_RETURNVAL(&xdrs, result))
			 return (AUDIO_RPC_PRIVATEINFO_RETURNVAL *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_Capability_SetPassThroughMode_0(AUDIO_PASSTHROUGH_INFO *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_PASSTHROUGH_INFO );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_Capability_SetPassThroughMode, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_PASSTHROUGH_INFO, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}

USB_DEVICE_CONFIG_INFO *
AUDIO_RPC_ToAgent_AI_Device_USBinfo_0(AUDIO_AI_DEVICE_USB_INFO *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	USB_DEVICE_CONFIG_INFO * result = NULL ;
	long args_size = sizeof(AUDIO_AI_DEVICE_USB_INFO );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (USB_DEVICE_CONFIG_INFO *) malloc(sizeof(USB_DEVICE_CONFIG_INFO ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_AI_Device_USBinfo, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_AI_DEVICE_USB_INFO, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (USB_DEVICE_CONFIG_INFO *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(USB_DEVICE_CONFIG_INFO), XDR_DECODE);
		 if(!xdr_USB_DEVICE_CONFIG_INFO(&xdrs, result))
			 return (USB_DEVICE_CONFIG_INFO *)-1;
		return result;
	}

	return 0;

}

HRESULT *
AUDIO_RPC_ToAgent_Set_Dummy_Value_0(AUDIO_DUMMY_DATA *argp, CLNT_STRUCT *clnt)
{
#if defined(ENABLE_RPC_PROXY_INIT_CHECK)
  #if 1 == BUILD_FOR_MACARTHUR3
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 1" )
  #else
  #pragma message( "BUILD_FOR_MACARTHUR3 is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_KCPU_COMMON
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 1" )
  #else
  #pragma message("BUILD_FOR_KCPU_COMMON is #define'd to 0" )
  #endif
  #if 1 == BUILD_FOR_MACARTHUR3 && 0 == BUILD_FOR_KCPU_COMMON
    //THIS IS COMPILED FOR SCPU
    extern int g_RPCProxyInitDone;
    if (0 == g_RPCProxyInitDone)
    {
        //while (1)
        //{
        //    printf ("g_RPCProxyInitDone not init to 1\n");
        //    sleep (1);
        //}
        initRPCProxy();
    }
  #endif
#endif //ENABLE_RPC_PROXY_INIT_CHECK
	RPC_STRUCT rpc;
	HRESULT * result = NULL ;
	long args_size = sizeof(AUDIO_DUMMY_DATA );


	// if NONBLOCK_MODE, dont need to alloc memory
	if (clnt->sendMode & BLOCK_MODE) {
		result = (HRESULT *) malloc(sizeof(HRESULT ));
	}


	// prepare the RPC call structure
	// including programID, versionID, TaskID...
	rpc = prepareRPCCall(clnt, (int)result);


	if (client_call (&rpc, AUDIO_RPC_ToAgent_Set_Dummy_Value, clnt->sendMode,
		(xdrproc_t) xdr_AUDIO_DUMMY_DATA, (caddr_t) argp, args_size)
		!= RPC_SUCCESS) {
		if(result)
			free(result);
		return (HRESULT *)-1;
	}


	//for blocking use
	if (clnt->sendMode & BLOCK_MODE) {
		XDR xdrs;

		waitReply();
		xdrmem_create(&xdrs, (char *)result, sizeof(HRESULT), XDR_DECODE);
		 if(!xdr_HRESULT(&xdrs, result))
			 return (HRESULT *)-1;
		return result;
	}

	return 0;

}
