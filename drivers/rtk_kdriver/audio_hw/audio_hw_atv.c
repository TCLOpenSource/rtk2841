#include <linux/kconfig.h>
#include <linux/compiler.h>
#include <linux/init.h>
#include <linux/kernel.h>
#include <linux/stat.h>			/* permission */
#include <linux/fs.h>			/* fs */
#include <linux/errno.h>		/* error codes */
#include <linux/types.h>		/* size_t */
#include <linux/fcntl.h>		/* O_ACCMODE */
#include <asm/uaccess.h>		/* copy_*_user */
#include <linux/semaphore.h>		/* semaphore */
#include <linux/kthread.h>		/* kernel thread */
#include <linux/freezer.h>		/* set freezable */
#include <linux/wait.h>			/* wait event */
#include <linux/jiffies.h>		/* jiffies */
#include <linux/delay.h>

/*
 * rbus registers
 */
#include <rbus/tv_sb1_ana_reg.h>
#include <rbus/pll27x_reg_reg.h>
#include <rbus/audio_reg.h>
#include <rbus/sys_reg_reg.h>
#include <rtk_kdriver/RPCDriver.h>

#include "audio_hw_port.h"
#include "audio_hw_atv.h"
#include "audio_hw_aio.h"
#include "audio_hw_app.h"
#include "audio_hw_rpc.h"

//for LG BTSC stereo separation
#include <rtkaudio_debug.h>

#define __ALOG_SUBTAG "atv"

#define USE_PACFIC_STYLE
#define NO_USE_HIGHBW

/* bit 11 */
#define ENABLE_MAINTONE_THRESHOLD_ADJUST_MASK	(1<<11)
#define ENABLE_MAINTONE_THRESHOLD_ADJUST	(1<<11)

/* bit 12 */
#define  ENABLE_LIMITSTD_CHANGE_NO_UNKNOW_MASK	(1<<12)
#define  ENABLE_LIMITSTD_CHANGE_NO_UNKNOW	(1<<12)

/* bit 17 */
/* TOS input/remove testing */
#define ENABLE_NO_SIGNAL_RESTART		(1<<17)

/* bit 18~19 */
#define ENABLE_AM_GAIN_MASK			(3<<18)
#define ENABLE_AM_OPT_THREASHOLD		(1<<18)
#define ENABLE_AM_FIX_GAIN_0			(2<<18)

/* bit 20 */
#define ENABLE_NICAM_PRESCALE_OVERFLOW_MASK	(1<<20)
#define ENABLE_NICAM_PRESCALE_OVERFLOW		(1<<20)

/* bit 21 ~22 */
#define ENABLE_NEW_A2_DETECTED_MASK		(3<<21)
#define ENABLE_NEW_CHECK_A2			(2<<21)

/* bit 23 */
/* FIX T compay PS ratio is too high */
#define ENABLE_PS_RATION_MORETHAN_30DB		(1<<23)
#define ENABLE_PS_RATION_MORETHAN_30DB_MASK	(1<<23)

/* bit 24 */
/* add AM freq shift case */
#define ENABLE_AM_FREQ_SHIFT			(1<<24)
#define ENABLE_AM_FREQ_SHIFT_MASK		(1<<24)

/* bit 25 */
/* add BTSC deviation */
#define ENABLE_BTSC_USE_FM_MONO			(1<<25)
#define ENABLE_BTSC_USE_FM_MONO_MASK		(1<<25)

/* bit 27 */
#define ENABLE_AUTO_ADJUST_DEVIATION		(1<<26)
#define ENABLE_AUTO_ADJUST_DEVIATION_MASK	(1<<26)

#define ATV_STD_THRESHOLD_HIGH			(0x1500)
#define ATV_STD_THRESHOLD_LOW			(0xc80)

#define ATV_LOW_TH_THRESHOLD_HIGH		(0x500)
#define ATV_LOW_TH_THRESHOLD_LOW		(0x250)

#define A2SOUNDMODECHANGEMAX			(20)

/* For AVD check */
#define AUDIO_sb2_arch_reg_reg			(0xb801a604)
#define AUDIO_SET_SWITCH_CHANNEL_FLAG		(1<<1)
#define AUDIO_SET_START_SCAN_CHANNEL_FLAG	(1<<2)
#define AUDIO_SET_START_APVR_FLAG		(1<<3)

/* bit 0 */
#define ATV_PRINT_FLAG_ENABLE_SW_SCAN		(1)

/* bit 1 */
#define ATV_PRINT_FLAG_ENABLE_NORMAL_PRINT	(2)

#define MONITOR_NICAM_SIGNAL	/* test */

#define ATV_NO_VIDEO

#define KR_A2_TH_CNT				15

/* change 0x50000 to 0x500000 for NTSC channel-04(high phase error) in LG PT */
#define PHASE_ERROR_MAX_TH			(0x500000)

// for set fw's priority for sound standard
#define AUDIO_ATV_FW_PRIORITY_MN 	(0x01)
#define AUDIO_ATV_FW_PRIORITY_BG		(AUDIO_ATV_FW_PRIORITY_MN << 1)
#define AUDIO_ATV_FW_PRIORITY_I		(AUDIO_ATV_FW_PRIORITY_MN << 2)
#define AUDIO_ATV_FW_PRIORITY_DK		(AUDIO_ATV_FW_PRIORITY_MN << 3)
#define AUDIO_ATV_FW_PRIORITY_L		(AUDIO_ATV_FW_PRIORITY_MN << 4)
#define AUDIO_ATV_FW_PRIORITY_AUTO	(0xFF)

#undef  LG_NO_SIGNAL_NOISE_SOUND

static DEFINE_SEMAPHORE(audio_sem_atv);
static DEFINE_SEMAPHORE(audio_sem_sif);

#ifdef USE_PACFIC_STYLE
/* add detect no signal method, default use video */
#if 0
static uint32_t g_AudioTVControlFlag = (ENABLE_BTSC_USE_FM_MONO | \
					ENABLE_NEW_CHECK_A2 | \
					ENABLE_LIMITSTD_CHANGE_NO_UNKNOW | \
					ENABLE_NO_SIGNAL_RESTART);
#else
static uint32_t g_AudioTVControlFlag = (ENABLE_BTSC_USE_FM_MONO | \
					ENABLE_NEW_CHECK_A2 | \
					ENABLE_LIMITSTD_CHANGE_NO_UNKNOW);
#endif

static uint32_t g_AudioTVPrintFlag = 0;
#if 0//ndef TV001_BOARD
static int g_call_by_hal = 0;
#endif

static uint32_t g_AudioTVNormalMainToneThredhold_High = ATV_STD_THRESHOLD_HIGH;
static uint32_t g_AudioTVNormalMainToneThredhold_Low = ATV_STD_THRESHOLD_LOW;

static uint32_t g_AudioTVLOWTHDMainToneThredhold_High = ATV_LOW_TH_THRESHOLD_HIGH;
static uint32_t g_AudioTVLOWTHDNormalMainToneThredhold_Low = ATV_LOW_TH_THRESHOLD_LOW;

static uint32_t g_AudioTVNormalBWThredhold = 0xc80;

#ifndef NO_USE_HIGHBW
static uint32_t g_AudioTVHighBWThredhold = 0x2000;
#endif

int32_t g_user_config = AUDIO_USER_CONFIG_UNKNOWN;

static int g_Atvpath_PB = 0;	/* The default value of Mute control flag should 
				 * set 0, and get 1 by HAL 
				 */
static int g_Atvpath_TS = 0;	/* The default value of Mute control flag should
				 * set 0, and get 1 by HAL
				 */

static int g_ap_mute_pb_cnt = USR_MUTE_NUM;
static int g_ap_mute_ts_cnt = USR_MUTE_NUM;

static int g_AtvForceNotMute_PB  = 0;
static int g_AtvForceNotMute_TS  = 0;

/* set std */
static int g_UserStdMainSystem = 0;
static int g_UserStd = 0;
static int g_CurrentStd = 0;	/* Current maybe != g_UserStd */
static int g_isAutoDetect = 0;
static int g_SetStdFlag = 0;
static int g_StdchangeNoMuteFlag = 0;
static uint16_t g_FwStdPriority = AUDIO_ATV_FW_PRIORITY_AUTO;

/* add detect no signal method */
static int g_CurrentHWDetectStd = 0;
static int g_CurrentHWDetectUpdate = 0;

/* change to mono system for china style */
static int g_isForce2MonoSystem = 0;

/* deviation */
static uint32_t g_CurrentDeviation = 0;
static uint32_t g_DevBySoundStd = (uint32_t)ATV_DEV_CHANGE_BY_SOUND_STD;

/* nicam overflow debounce */
static uint32_t g_NicamOverFlowCnt = 0;

static SIF_INPUT_SOURCE sifsource = SIF_FROM_IFDEMOD;

/* signal */
static int g_TVAudioReady = 0;
static int g_TVAudioNosignal = 0;
static int g_TVAudioNosignalPrev = 0;
static int g_ChangeStdStatus = 0;
static bool TV_ChangeStateFlag = false;
static ATV_TASK_STATUS TV_OldWorkState = ATV_TASK_STOP;
static ATV_TASK_STATUS TV_CurrentWorkState = ATV_TASK_STOP;
static bool AtvThreadState = false;

static int g_numTVMute = 0;

/* signal RF , PS ratio */
static uint32_t g_lowRFDebounce  = 0;
static uint32_t g_lowRFFlag;
static uint32_t g_lowPSDebounce  = 0;
static uint32_t g_lowPSFlag;
static bool g_AudioScanSoundStdFlag = false;

/* sound select */
static int g_UserTVBTSCISStereo = 0;
static int g_UserTVA2ISStereo = 0;
static int g_UserTVNICAMISStereo = 0;

static int g_UserTVBTSCSAP = 0;
static int g_UserTVA2Language = 0;
static int g_UserTVNICAMLanguage = 0;

static int g_UserChangeBTSCSelectFlag = 0;
static int g_UserChagneA2SelectFlag = 0;
static int g_UserChangeNicamSelectFlag = 0;
static int g_nicam_carrier_shift = 0;
static int g_DetectedBGNicam = 0;

#define NICAM_CARRIER_SHIFT_TH 2

/* FM Radio */
//static int g_FMRadioscanFlag = 0;
static AUDIO_ATV_FM_RADIO_MODE g_FM_RADIO_MODE = AUDIO_ATV_FM_RADIO_STOP;

/* fix btsc sap disapper noise */
static int g_CurrentIsPlaySAP = 0;

/* sond mode */
uint8_t g_FirstTimeSoundMode[4];
static uint32_t g_nicam_soundmode;
static uint32_t g_btsc_soundmode;
static uint32_t g_A2_soundmode;
static uint32_t g_last_soundmode[3];
static uint32_t g_BTSCSOUNDCHANGEMAX = 30;
static uint32_t g_BTSCSOUNDCHANGEMIN = 0;

/* nicam error rate */
static int32_t g_ErrorRateConstNum = 0;
static int32_t g_NicamHighErrorRate = 0;

/* FIX Error Std Check, Mono DK-> A2 DK */
static uint32_t g_Std_energy_625;
static uint32_t g_Std_energy_6552;
static uint32_t g_Std_energy_674;
static audio_msd_status_RBUS g_Std_msd_status;
static audio_msd_result_RBUS g_Std_msd_result;

static uint32_t g_StdDataIsUpdate = 0;

/* wait ifd to finish init */
static int g_WaitIFDInitFinish = 0;

/* for first time to play mono sound for Txxx Company */
static int g_FirstTimeForce2PlayMono = 0;

/* for first time to play mono sound for Txxx Company */
static int g_Start2NormalProcess = 1;

/* for first time to play mono sound for Txxx Company */
static int g_EnableAutoChangeSoundMode = 1;

static int g_NicamEnhanceTrueDetect = 0;

/* for first time to play mono sound for Txxx Company */
static int g_EnableNicamAutoRecovery = 1;

static int g_ForceSoundSelect = 0;
static int g_InForceSoundSelectMode = 0;

static int g_NicamSignalStable = 0;
static int g_KR_A2_TH_CHG = 0;
#if 0//ndef TV001_BOARD
static uint32_t g_TVBGDKIVolumeCompensate_Normal = 0;
static uint32_t g_TVBGDKIVolumeCompensate_High = 0;
static uint32_t g_TVBGDKIVolumeCompensate_Super = 0;	/* supper 6 is correct, add ultra deviation */

static uint32_t g_TVNICAM_MonoVolumeCompensate_Normal = 0;
static uint32_t g_TVNICAM_MonoVolumeCompensate_High = 0;
static uint32_t g_TVNICAM_MonoVolumeCompensate_Super = 0;

static uint32_t g_TVA2_VolumeCompensate_Normal = 0;
static uint32_t g_TVA2_VolumeCompensate_High = 0;
static uint32_t g_TVA2_VolumeCompensate_Super = 0;

static uint32_t g_TV_M_Mono_VolumeCompensate_Normal = 0;
static uint32_t g_TV_M_Mono_VolumeCompensate_High = 0;
static uint32_t g_TV_M_Mono_VolumeCompensate_Super = 0;

static uint32_t g_TVM_A2M_VolumeCompensate_Normal = 0;
static uint32_t g_TVM_A2M_VolumeCompensate_High = 0;
static uint32_t g_TVM_A2M_VolumeCompensate_Super = 0;

static uint32_t g_TVM_BTSC_VolumeCompensate_Normal = 0;
static uint32_t g_TVM_BTSC_VolumeCompensate_High = 0;
static uint32_t g_TVM_BTSC_VolumeCompensate_Super = 0;

static uint32_t g_TVM_AM_Mono_VolumeCompensate_Normal = 0;
static uint32_t g_TVM_EIAJ_VolumeCompensate_Normal = 0;
static uint32_t g_TVM_VolumeCompensate_Zero = 0;
#endif
static int32_t g_wait_tunner_delay = 0;

/* FIX Error Std Check, 574 noise is too strong */
static uint32_t g_Std_energy_574;
static uint32_t g_Std_energy_585;
static uint32_t g_Std_energy_595;
static uint32_t g_Std_energy_6;
static uint32_t g_Std_energy_65;

#define A2_DK3_SUB_NOISE_THRESHOLD		(0xc80)
#define A2_DK3_MAIN_THRESHOLD			(0x4000)

static uint32_t g_Std_energy_45;
static uint32_t g_Std_energy_fix_45_55;
static uint32_t g_Std_energy_fix_60_65;
static uint32_t g_Std_energy_472;
static uint32_t g_Std_energy_428;
static uint32_t g_Std_energy_55;
static uint32_t g_Std_energy_525;

static int g_SetMode_Mute = 0;
static int g_InternalDecoder_0_FAIL = 0;
static int g_InternalDecoder_1_FAIL = 0;

static uint32_t AtvGetHWStd(void);
static void AtvCleanTVMuteNum(void);
static uint32_t AtvGetMainSystem(uint32_t std);

static long g_instanceID = 0;
static long g_sub_instanceID = 0;
static ENUM_AUDIO_IPT_SRC g_AudioClkStatus = AUDIO_IPT_SRC_UNKNOWN;
static ENUM_AUDIO_IPT_SRC g_AudioSubClkStatus = AUDIO_IPT_SRC_UNKNOWN;

static A2_BW_SEL_T g_FM1_bw = BANDWIDTH_HDV0_120KHZ;
static A2_BW_SEL_T g_FM2_bw = BANDWIDTH_HDV0_120KHZ;

/* to fix change TV channel during audio std change */
static uint32_t g_AudioDuringChangeStatus = FALSE;

static FP_AUDIOSTATUSCHANGE audioStatusChanageCallBack = NULL;

/* speed up the time when weak NICAM switch to MONO */
static uint32_t g_NicamErrorRateThresholdHigh = 0x70;		/* original 0x100 //0F */
static uint32_t g_NicamErrorRateThresholdNormal = 0x20;
static uint32_t g_NicamErrorRateThresholdLow = 0x10;		/* original 0x70 //03 */

/*
 * switching sound_select quickly is easy to get high error rate,
 * it's only in Mac & MAC2. 
 */
static int g_NicamMaxErrorDebounce = 30;
static int g_NoSignalNeedToMuteFlag = 1;

static ATV_SOUND_STD_MAIN_SYSTEM AtvSoundSystem = ATV_SOUND_UNKNOWN_SYSTEM;
static ATV_AUDIO_SIF_TYPE_T g_CurSifType = ATV_AUDIO_SIF_TYPE_NONE;
static bool g_HighDevOnOff = false;

#ifdef LG_NO_SIGNAL_NOISE_SOUND
static int g_LG_NoSignal = 0;
#endif

static int32_t g_sif_offset = 0;
#endif /* USE_PACFIC_STYLE */

#define ATV_TICK_PERIOD			(10*1000)	/* 10ms */

/* speed up to detect no signal method */
#define ATV_TICK_TIME_5MS		(5*1000)

#define ATV_TICK_TIME_10MS		(10*1000)
#define ATV_TICK_TIME_20MS		(ATV_TICK_TIME_10MS*2)
#define ATV_TICK_TIME_30MS		(ATV_TICK_TIME_10MS*3)
#define ATV_TICK_TIME_50MS		(ATV_TICK_TIME_10MS*5)
#define ATV_TICK_TIME_100MS		(100*1000)
#define ATV_TICK_TIME_200MS		(ATV_TICK_TIME_100MS*2)
#define ATV_TICK_TIME_500MS		(ATV_TICK_TIME_100MS*5)
#define ATV_TICK_TIME_1SEC		(1000*1000/ATV_TICK_PERIOD)
#define ATV_TICK_TIME_2SEC		(ATV_TICK_TIME_1SEC*2)
#define ATV_TICK_TIME_5SEC		(ATV_TICK_TIME_1SEC*5)
#define ATV_MODE_DEBOUNCE_THD		(ATV_TICK_TIME_10MS*7)
#define ATV_BTSC_DEBOUNCE_THD		(ATV_TICK_TIME_10MS*3)

/* speed up to detect no signal method */
#define ATV_TICK_THREAD_TIME		(ATV_TICK_TIME_5MS*5)	/* (ATV_TICK_TIME_10MS*2) */
#define ATV_TICK_PACFIC_TIME		(ATV_TICK_TIME_5MS*10)

#define FM_BW_70K			(3)
#define FM_BW_SUPER			(2)
#define FM_BW_HIGH			(1)
#define FM_BW_NORMAL			(0)

#define LOWRFDEBOUNCEMAX		(300)
#define LOWRFDEBOUNCEMIN		(0)

#define LOWPSDEBOUNCEMAX		(300)
#define LOWPSDEBOUNCEMIN		(0)

#define A2SOUNDCHANGEMAX		(5)	/* 20--> 5, speed mode detect debounce */
#define A2SOUNDCHANGEMIN		(0)

#define Low_BTSC_SAP_SIGNAL_NOISE_RATIO	(0x35)
#define Low_BTSC_SAP_THRESHOLD_HIGH	(0x55)
#define Low_BTSC_SAP_THRESHOLD_LOW	(0x40)

#define VD_MODE_DETECTION_STATUS_VADDR	(0xb80194a4)
#define VD_SEP_BURST_RO_2_VADDR		(0xb801956c)
#define VIDEO_STATUS_REG3_VADDR		(0xb8019010)
#define BURST_TH			(0x35)

typedef enum {
	ATV_HW_CARRIER_SHIFT_BANDWIDTH = 0,		// pacific new hw
	ATV_HW_CARRIER_NO_SHIFT,			// 1, old hw
	ATV_FW_CARRIER_SHIFT_HW_DETECT,			// 2, old hw
	ATV_HW_MONO_ONLY,				// 3 ,old hw
	ATV_HW_DISABLE,					// 4 old hw
	ATV_HW_CARRIER_NO_SHIFT_NO_BANDWIDTH,		// 5
	ATV_HW_CARRIER_SHIFT_NO_BANDWIDTH,		// 6
	ATV_HW_MONO_ONLY_CARRIER_SHIFT_BANDWIDTH,	//7, new added for FM Radio
	ATV_HW_MONO_ONLY_CARRIER_SHIFT_NO_BANDWIDTH,	// 8, new added for FM Radio
	ATV_HW_CARRIER_SHIFT_BANDWIDTH_MONO_ONLY,	//9, new added for LG auto scan
	ATV_HW_CARRIER_NO_SHIFT_NO_BANDWIDTH_MONO_ONLY	//10, new added for LG auto scan when M-system
} ATV_HW_MSD_DETECT_MODE;

typedef struct _SignalFreqPos {
	uint32_t MainTone;
	uint32_t SubTone;
} SignalFreqPos;

typedef struct _SignalFreqShfitDetect {
	int32_t shift;
	uint32_t value;
	uint32_t hwindex;
	uint32_t freq;
} SignalFreqShfitDetect;

typedef struct {
	uint16_t ATV_STD_FMRadio_THRESHOLD_HIGH;	//(0x2000)
	uint16_t ATV_STD_FMRadio_THRESHOLD_LOW;		//(0x2000)
	uint16_t ATV_STD_FMRadio_MAIN_NOISE_TH;		//(0x1500)
	uint16_t ATV_STD_FMRadio_WEAK_TH;		//(0x700)
	uint16_t ATV_STD_FMRadio_NORMAL_TH;		//(0x2500)
	uint16_t ATV_STD_FMRadio_STRONG_TH;		//(0x3000)
	uint16_t ATV_STD_FMRadio_TONE_4p5_SHIFT;	//3
	uint16_t ATV_STD_FMRadio_MSD_DEBOUNCE;		//3
} FM_RADIO_PARA;

typedef enum _CHANGESTDSTATUS {
	CHANGESTDSTATUS_FIRST_TIME = 0,
	CHANGESTDSTATUS_INIT,
	CHANGESTDSTATUS_CHECKDIGITAL_STABLE,
	CHANGESTDSTATUS_DETECT
} CHANGESTDSTATUS;

typedef enum {
	/* register bit field */
	AUD_FIFO_CHANNEL_L = 0,
	AUD_FIFO_CHANNEL_R,
	AUD_FIFO_CHANNEL_LMIXR,	// L+R
	AUD_FIFO_CHANNEL_L_R,	// L-R
} AUD_FIFO_CHANNEL_SRC;

typedef enum _WAIT_IFD_INIT_FINISH {
	WAIT_IFD_INIT = 0,
	WAIT_IFD_FIRSTTIME,
	WAIT_IFD_FINISH,
} WAIT_IFD_INIT_FINISH;

uint32_t m_sound_select_btsc_map[4][4] = {
	{	// Mono
		ATV_BTSC_MTS_SEL_MONO,
		ATV_BTSC_MTS_SEL_MONO,
		ATV_BTSC_MTS_SEL_MONO,
		ATV_BTSC_MTS_SEL_MONO
	},
	{	// Stereo
		ATV_BTSC_MTS_SEL_MONO,
		ATV_BTSC_MTS_SEL_STEREO,
		ATV_BTSC_MTS_SEL_STEREO,
		ATV_BTSC_MTS_SEL_STEREO
	},
	{	// Mono+SAP
		ATV_BTSC_MTS_SEL_L_MONO_R_SAP,
		ATV_BTSC_MTS_SEL_L_MONO_R_SAP,
		ATV_BTSC_MTS_SEL_MONO,
		ATV_BTSC_MTS_SEL_SAP
	},
	{	// Stereo+SAP
		ATV_BTSC_MTS_SEL_SAP,
		ATV_BTSC_MTS_SEL_MONO	/*ATV_BTSC_MTS_SEL_STEREO*/,
		ATV_BTSC_MTS_SEL_STEREO,
		ATV_BTSC_MTS_SEL_SAP
	}
};

#define USE_A2_TABLE

static ATV_A2_TH_TAB A2_Th_MN_Table[101] = {														/* ATV_MODE_MAX_TH_0 */
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x50000,	0x170000,	20},	//0
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x50000,	0x170000,	20},	//1
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x50000,	0x170000,	20},	//2
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x50000,	0x170000,	20},	//3
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x50000,	0x170000,	20},	//4
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x50000,	0x170000,	20},	//5
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x50000,	0x170000,	20},	//6
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x50000,	0x170000,	20},	//7
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x50000,	0x170000,	20},	//8
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x50000,	0x170000,	20},	//9
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x50000,	0x170000,	20},	//10
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x1C0000,	20},	//11
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x1E0000,	20},	//12
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x200000,	20},	//13
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x220000,	20},	//14
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x240000,	20},	//15
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x260000,	20},	//16
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x280000,	20},	//17
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x2A0000,	20},	//18
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x2C0000,	20},	//19
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x2E0000,	20},	//20
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x300000,	20},	//21
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x320000,	20},	//22
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x340000,	20},	//23
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x360000,	20},	//24
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x380000,	20},	//25
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x3A0000,	20},	//26
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x3C0000,	20},	//27
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x3E0000,	20},	//28
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x400000,	20},	//29
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x420000,	20},	//30
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x440000,	20},	//31
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x460000,	20},	//32
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x480000,	20},	//33
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x4A0000,	20},	//34
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x4C0000,	20},	//35
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x4E0000,	20},	//36
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x500000,	20},	//37
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x520000,	20},	//38
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x540000,	20},	//39
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x560000,	20},	//40
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x580000,	20},	//41
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x5A0000,	20},	//42
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x5C0000,	20},	//43
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x5E0000,	20},	//44
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x600000,	20},	//45
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x620000,	20},	//46
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x640000,	20},	//47
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x660000,	20},	//48
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x680000,	20},	//49
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x6A0000,	20},	//50
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x6C0000,	20},	//51
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x6E0000,	20},	//52
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x700000,	20},	//53
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x720000,	20},	//54
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x740000,	20},	//55
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x760000,	20},	//56
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x780000,	20},	//57
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x7A0000,	20},	//58
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x7C0000,	20},	//59
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x7E0000,	20},	//60
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x810000,	20},	//61
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x840000,	20},	//62
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x870000,	20},	//63
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x8A0000,	20},	//64
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x8D0000,	20},	//65
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x900000,	20},	//66
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x930000,	20},	//67
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x960000,	20},	//68
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x990000,	20},	//69
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x9C0000,	20},	//70
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x9F0000,	20},	//71
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xA20000,	20},	//72
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xA50000,	20},	//73
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xA80000,	20},	//74
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xAB0000,	20},	//75
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xAE0000,	20},	//76
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xB10000,	20},	//77
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xB40000,	20},	//78
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xB70000,	20},	//79
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xBA0000,	20},	//80
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xBD0000,	20},	//81
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xC00000,	20},	//82
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xC30000,	20},	//83
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xC60000,	20},	//84
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xC90000,	20},	//85
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xCC0000,	20},	//86
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xCF0000,	20},	//87
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xD20000,	20},	//88
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xD50000,	20},	//89
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xD80000,	20},	//90
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xDC0000,	20},	//91
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xE00000,	20},	//92
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xE40000,	20},	//93
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xE80000,	20},	//94
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xEC0000,	20},	//95
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xF00000,	20},	//96
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xF40000,	20},	//97
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xF80000,	20},	//98
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xFC0000,	20},	//99
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xFFFFFF,	20},	//100
};

static ATV_A2_TH_TAB *A2_Th_Table = A2_Th_MN_Table;
static ATV_A2_TH_TAB A2_Th_Normal_Table[101] = {													//ATV_MODE_MAX_TH_0
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x50000,	0x170000,	20},	//0
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x50000,	0x170000,	20},	//1
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x50000,	0x170000,	20},	//2
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x50000,	0x170000,	20},	//3
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x50000,	0x170000,	20},	//4
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x50000,	0x170000,	20},	//5
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x50000,	0x170000,	20},	//6
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x50000,	0x170000,	20},	//7
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x50000,	0x170000,	20},	//8
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x50000,	0x170000,	20},	//9
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x50000,	0x170000,	20},	//10
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x0C0000,	20},	//11
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x1E0000,	20},	//12
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x200000,	20},	//13
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x220000,	20},	//14
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x240000,	20},	//15
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x260000,	20},	//16
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x280000,	20},	//17
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x2A0000,	20},	//18
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x2C0000,	20},	//19
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x2E0000,	20},	//20
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x300000,	20},	//21
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x320000,	20},	//22
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x340000,	20},	//23
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x360000,	20},	//24
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x380000,	20},	//25
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x3A0000,	20},	//26
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x3C0000,	20},	//27
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x3E0000,	20},	//28
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x400000,	20},	//29
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x420000,	20},	//30
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x440000,	20},	//31
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x460000,	20},	//32
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x480000,	20},	//33
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x4A0000,	20},	//34
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x4C0000,	20},	//35
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x4E0000,	20},	//36
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x500000,	20},	//37
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x520000,	20},	//38
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x540000,	20},	//39
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x560000,	20},	//40
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x580000,	20},	//41
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x5A0000,	20},	//42
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x5C0000,	20},	//43
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x5E0000,	20},	//44
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x600000,	20},	//45
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x620000,	20},	//46
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x640000,	20},	//47
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x660000,	20},	//48
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x680000,	20},	//49
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x6A0000,	20},	//50
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x6C0000,	20},	//51
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x6E0000,	20},	//52
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x700000,	20},	//53
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x720000,	20},	//54
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x740000,	20},	//55
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x760000,	20},	//56
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x780000,	20},	//57
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x7A0000,	20},	//58
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x7C0000,	20},	//59
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x7E0000,	20},	//60
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x810000,	20},	//61
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x840000,	20},	//62
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x870000,	20},	//63
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x8A0000,	20},	//64
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x8D0000,	20},	//65
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x900000,	20},	//66
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x930000,	20},	//67
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x960000,	20},	//68
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x990000,	20},	//69
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x9C0000,	20},	//70
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0x9F0000,	20},	//71
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xA20000,	20},	//72
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xA50000,	20},	//73
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xA80000,	20},	//74
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xAB0000,	20},	//75
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xAE0000,	20},	//76
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xB10000,	20},	//77
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xB40000,	20},	//78
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xB70000,	20},	//79
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xBA0000,	20},	//80
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xBD0000,	20},	//81
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xC00000,	20},	//82
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xC30000,	20},	//83
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xC60000,	20},	//84
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xC90000,	20},	//85
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xCC0000,	20},	//86
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xCF0000,	20},	//87
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xD20000,	20},	//88
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xD50000,	20},	//89
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xD80000,	20},	//90
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xDC0000,	20},	//91
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xE00000,	20},	//92
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xE40000,	20},	//93
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xE80000,	20},	//94
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xEC0000,	20},	//95
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xF00000,	20},	//96
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xF40000,	20},	//97
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xF80000,	20},	//98
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xFC0000,	20},	//99
	{ATV_LPF_COEF_SEL_14, ATV_LPF_COEF_SEL_14, ATV_MODE_HI_TH_2P00T, ATV_MODE_LO_TH_1P50T, ATV_A2_DEBOUNCE_0P5S, 0x60000,	0xFFFFFF,	20},	//100
};

static ATV_MODE_TAB atv_mode_tab[16] = {
	/*
	 * LasVegas can detect 16 different standards.
	 * In the following setting,BTSC and MONO standards are useless
	 * but we keep these fields for being easy searching algo.
	 */
	{	0,	0,	0,	0}, // AUDIO_SOUND_STD_MN_MONO
	{	0,	0,	0,	0}, // AUDIO_SOUND_STD_BTSC
	{	ATV_A2_DEBOUNCE_0P5S,	ATV_MODE_HI_TH_2P50T,	ATV_MODE_LO_TH_1P00T,	ATV_MODE_ACCU_32}, // AUDIO_SOUND_STD_A2_M
	{	4,	ATV_MODE_HI_TH_2P50T,	ATV_MODE_LO_TH_1P00T,	ATV_MODE_ACCU_32}, // AUDIO_SOUND_STD_EIAJ
	{	0,	0,	0,	0}, // AUDIO_SOUND_STD_BG_MONO
	{	ATV_A2_DEBOUNCE_0P5S,	ATV_MODE_HI_TH_2P50T,	ATV_MODE_LO_TH_1P00T,	ATV_MODE_ACCU_32}, // AUDIO_SOUND_STD_A2_BG
	{	4,	0,	0,	0}, // AUDIO_SOUND_STD_NICAM_BG
	{	0,	0,	0,	0}, // AUDIO_SOUND_STD_DK_MONO
	{	ATV_A2_DEBOUNCE_0P5S,	ATV_MODE_HI_TH_2P50T,	ATV_MODE_LO_TH_1P00T,	ATV_MODE_ACCU_32}, // AUDIO_SOUND_STD_A2_DK1
	{	ATV_A2_DEBOUNCE_0P5S,	ATV_MODE_HI_TH_2P50T,	ATV_MODE_LO_TH_1P00T,	ATV_MODE_ACCU_32}, // AUDIO_SOUND_STD_A2_DK2 2014/4/24 special setting for Vietnam field
	{	ATV_A2_DEBOUNCE_0P5S,	ATV_MODE_HI_TH_2P50T,	ATV_MODE_LO_TH_1P00T,	ATV_MODE_ACCU_32}, // AUDIO_SOUND_STD_A2_DK3
	{	4,	0,	0,	0}, // AUDIO_SOUND_STD_NICAM_DK
	{	0,	0,	0,	0}, // AUDIO_SOUND_STD_AM_MONO
	{	4,	0,	0,	0}, // AUDIO_SOUND_STD_NICAM_L
	{	0,	0,	0,	0}, // AUDIO_SOUND_STD_FM_MONO_NO_I
	{	4,	0,	0,	0} // AUDIO_SOUND_STD_NICAM_I
};

static ATV_MODE_TAB atv_mode_preset_tab[16] = {
	/*
	 * LasVegas can detect 16 different standards.
	 * In the following setting,BTSC and MONO standards are useless
	 * but we keep these fields for being easy searching algo.
	 */
	{	0,	0,	0,	0}, // AUDIO_SOUND_STD_MN_MONO
	{	0,	0,	0,	0}, // AUDIO_SOUND_STD_BTSC
	{	ATV_A2_DEBOUNCE_NON,	ATV_MODE_HI_TH_2P00T,	ATV_MODE_LO_TH_1P50T,	ATV_MODE_ACCU_32}, // AUDIO_SOUND_STD_A2_M
	{	4,	ATV_MODE_HI_TH_2P00T,	ATV_MODE_LO_TH_1P50T,	ATV_MODE_ACCU_32}, // AUDIO_SOUND_STD_EIAJ
	{	0,	0,	0,	0}, // AUDIO_SOUND_STD_BG_MONO
	{	ATV_A2_DEBOUNCE_NON,	ATV_MODE_HI_TH_2P00T,	ATV_MODE_LO_TH_1P50T,	ATV_MODE_ACCU_32}, // AUDIO_SOUND_STD_A2_BG
	{	2,	0,	0,	0}, // AUDIO_SOUND_STD_NICAM_BG
	{	0,	0,	0,	0}, // AUDIO_SOUND_STD_DK_MONO
	{	ATV_A2_DEBOUNCE_NON,	ATV_MODE_HI_TH_2P00T,	ATV_MODE_LO_TH_1P50T,	ATV_MODE_ACCU_32}, // AUDIO_SOUND_STD_A2_DK1
	{	ATV_A2_DEBOUNCE_NON,	ATV_MODE_HI_TH_2P00T,	ATV_MODE_LO_TH_1P50T,	ATV_MODE_ACCU_32}, // AUDIO_SOUND_STD_A2_DK2 2014/4/24 special setting for Vietnam field
	{	ATV_A2_DEBOUNCE_NON,	ATV_MODE_HI_TH_2P00T,	ATV_MODE_LO_TH_1P50T,	ATV_MODE_ACCU_32}, // AUDIO_SOUND_STD_A2_DK3
	{	2,	0,	0,	0}, // AUDIO_SOUND_STD_NICAM_DK
	{	0,	0,	0,	0}, // AUDIO_SOUND_STD_AM_MONO
	{	2,	0,	0,	0}, // AUDIO_SOUND_STD_NICAM_L
	{	0,	0,	0,	0}, // AUDIO_SOUND_STD_FM_MONO_NO_I
	{	2,	0,	0,	0} // AUDIO_SOUND_STD_NICAM_I
};

/* 
 * Modify all FM1_Dev_Gain/FM2_Dev_Gain with default 0x4 (11.7dB)
 * for matching IC normalize target
 */
static ATV_PSDE_TAB atv_psde_normal_tab[16] = {
	// AUDIO_SOUND_STD_MN_MONO
	{                  0, ATV_NICAM_BW_250KHZ,      ATV_EIAJ_DEVIATION_20KHZ, ATV_A2_BW_SEL_70KHZ,
		ATV_DEEMPHASIS_75US, ATV_FM1_DEVIATION_100KHZ, ATV_FM2_DEVIATION_100KHZ,  ATV_AM_PRESCALE_0DB },
	// AUDIO_SOUND_STD_BTSC
	{                  0, ATV_NICAM_BW_250KHZ,      ATV_EIAJ_DEVIATION_20KHZ, ATV_A2_BW_SEL_70KHZ,
		ATV_DEEMPHASIS_75US, ATV_FM1_DEVIATION_100KHZ, ATV_FM2_DEVIATION_100KHZ,  ATV_AM_PRESCALE_0DB },
	// AUDIO_SOUND_STD_A2_M		// Modify for LGE A2M pilot carrier test
	// Back to Original 20151021
	// Change to 180kHz 20151021
	{                  0, ATV_NICAM_BW_250KHZ,      ATV_EIAJ_DEVIATION_20KHZ, ATV_A2_BW_SEL_100KHZ,
		ATV_DEEMPHASIS_75US, ATV_FM1_DEVIATION_180KHZ, ATV_FM2_DEVIATION_180KHZ,  ATV_AM_PRESCALE_0DB },
	// AUDIO_SOUND_STD_EIAJ
	{                  0, ATV_NICAM_BW_250KHZ,      ATV_EIAJ_DEVIATION_20KHZ, ATV_A2_BW_SEL_70KHZ,
		ATV_DEEMPHASIS_75US, ATV_FM1_DEVIATION_100KHZ, ATV_FM2_DEVIATION_100KHZ,  ATV_AM_PRESCALE_0DB },
	// AUDIO_SOUND_STD_BG_MONO
	{                  0, ATV_NICAM_BW_250KHZ,      ATV_EIAJ_DEVIATION_20KHZ, ATV_A2_BW_SEL_100KHZ,
		ATV_DEEMPHASIS_50US, ATV_FM1_DEVIATION_100KHZ, ATV_FM2_DEVIATION_100KHZ, ATV_AM_PRESCALE_0DB },
	// AUDIO_SOUND_STD_A2_BG
	{                  0, ATV_NICAM_BW_250KHZ,      ATV_EIAJ_DEVIATION_20KHZ, ATV_A2_BW_SEL_100KHZ,
		ATV_DEEMPHASIS_50US, ATV_FM1_DEVIATION_100KHZ, ATV_FM2_DEVIATION_100KHZ, ATV_AM_PRESCALE_0DB },
	// AUDIO_SOUND_STD_NICAM_BG
	{                  0, ATV_NICAM_BW_250KHZ,      ATV_EIAJ_DEVIATION_20KHZ, ATV_A2_BW_SEL_100KHZ,
		ATV_DEEMPHASIS_50US, ATV_FM1_DEVIATION_100KHZ, ATV_FM2_DEVIATION_100KHZ, ATV_AM_PRESCALE_0DB },
	// AUDIO_SOUND_STD_DK_MONO
	{                  0, ATV_NICAM_BW_250KHZ,      ATV_EIAJ_DEVIATION_20KHZ, ATV_A2_BW_SEL_100KHZ,
		ATV_DEEMPHASIS_50US, ATV_FM1_DEVIATION_100KHZ, ATV_FM2_DEVIATION_100KHZ, ATV_AM_PRESCALE_0DB },
	// AUDIO_SOUND_STD_A2_DK1
	{                  0, ATV_NICAM_BW_250KHZ,      ATV_EIAJ_DEVIATION_20KHZ, ATV_A2_BW_SEL_100KHZ,
		ATV_DEEMPHASIS_50US, ATV_FM1_DEVIATION_100KHZ, ATV_FM2_DEVIATION_100KHZ, ATV_AM_PRESCALE_0DB },
	// AUDIO_SOUND_STD_A2_DK2
	{                  0, ATV_NICAM_BW_250KHZ,      ATV_EIAJ_DEVIATION_20KHZ, ATV_A2_BW_SEL_100KHZ,
		ATV_DEEMPHASIS_50US, ATV_FM1_DEVIATION_100KHZ, ATV_FM2_DEVIATION_100KHZ, ATV_AM_PRESCALE_0DB },
	// AUDIO_SOUND_STD_A2_DK3
	{                  0, ATV_NICAM_BW_250KHZ,      ATV_EIAJ_DEVIATION_20KHZ, ATV_A2_BW_SEL_100KHZ,
		ATV_DEEMPHASIS_50US, ATV_FM1_DEVIATION_100KHZ, ATV_FM2_DEVIATION_100KHZ, ATV_AM_PRESCALE_0DB },
	// AUDIO_SOUND_STD_NICAM_DK
	{                  0, ATV_NICAM_BW_250KHZ,      ATV_EIAJ_DEVIATION_20KHZ, ATV_A2_BW_SEL_100KHZ,
		ATV_DEEMPHASIS_50US, ATV_FM1_DEVIATION_100KHZ, ATV_FM2_DEVIATION_100KHZ, ATV_AM_PRESCALE_0DB },
	// AUDIO_SOUND_STD_AM_MONO
	{                  0, ATV_NICAM_BW_250KHZ,      ATV_EIAJ_DEVIATION_20KHZ, ATV_A2_BW_SEL_70KHZ,
		ATV_DEEMPHASIS_75US, ATV_FM1_DEVIATION_100KHZ, ATV_FM2_DEVIATION_100KHZ,  ATV_AM_PRESCALE_6DB },
	// AUDIO_SOUND_STD_NICAM_L
	{                  0, ATV_NICAM_BW_250KHZ,      ATV_EIAJ_DEVIATION_20KHZ, ATV_A2_BW_SEL_70KHZ,
		ATV_DEEMPHASIS_75US, ATV_FM1_DEVIATION_100KHZ, ATV_FM2_DEVIATION_100KHZ,  ATV_AM_PRESCALE_6DB },
	// AUDIO_SOUND_STD_FM_MONO_NO_I
	{                  0, ATV_NICAM_BW_250KHZ,      ATV_EIAJ_DEVIATION_20KHZ, ATV_A2_BW_SEL_100KHZ,
		ATV_DEEMPHASIS_50US, ATV_FM1_DEVIATION_100KHZ, ATV_FM2_DEVIATION_100KHZ, ATV_AM_PRESCALE_0DB },
	// AUDIO_SOUND_STD_NICAM_I
	{                  0, ATV_NICAM_BW_350KHZ,      ATV_EIAJ_DEVIATION_20KHZ, ATV_A2_BW_SEL_100KHZ,
		ATV_DEEMPHASIS_50US, ATV_FM1_DEVIATION_100KHZ, ATV_FM2_DEVIATION_100KHZ, ATV_AM_PRESCALE_0DB },
};
#if 0//ndef TV001_BOARD
/* 
 * Modify all FM1_Dev_Gain/FM2_Dev_Gain with default 0x4 (11.7dB) for matching
 * IC normalize target
 */
static ATV_PSDE_TAB atv_psde_special_tab[16] = {
	// AUDIO_SOUND_STD_MN_MONO
	{                  0, ATV_NICAM_BW_250KHZ,       ATV_EIAJ_DEVIATION_20KHZ, ATV_A2_BW_SEL_100KHZ,
		ATV_DEEMPHASIS_75US, ATV_FM1_DEVIATION_100KHZ,  ATV_FM2_DEVIATION_100KHZ, ATV_AM_PRESCALE_0DB },
	// AUDIO_SOUND_STD_BTSC
	{                  0, ATV_NICAM_BW_250KHZ,       ATV_EIAJ_DEVIATION_20KHZ, ATV_A2_BW_SEL_100KHZ,
		ATV_DEEMPHASIS_75US, ATV_FM1_DEVIATION_100KHZ,  ATV_FM2_DEVIATION_100KHZ, ATV_AM_PRESCALE_0DB },
	// AUDIO_SOUND_STD_A2_M		// Modify for LGE A2M pilot carrier test
	{                  0, ATV_NICAM_BW_250KHZ,       ATV_EIAJ_DEVIATION_20KHZ, ATV_A2_BW_SEL_100KHZ,
		ATV_DEEMPHASIS_75US, ATV_FM1_DEVIATION_28KHZ, ATV_FM2_DEVIATION_28KHZ,  ATV_AM_PRESCALE_0DB },
	// AUDIO_SOUND_STD_EIAJ
	{                  0, ATV_NICAM_BW_250KHZ,       ATV_EIAJ_DEVIATION_20KHZ, ATV_A2_BW_SEL_100KHZ,
		ATV_DEEMPHASIS_75US, ATV_FM1_DEVIATION_100KHZ,  ATV_FM2_DEVIATION_100KHZ, ATV_AM_PRESCALE_0DB },
	// AUDIO_SOUND_STD_BG_MONO
	{                  0, ATV_NICAM_BW_250KHZ,       ATV_EIAJ_DEVIATION_20KHZ, ATV_A2_BW_SEL_150KHZ,
		ATV_DEEMPHASIS_50US, ATV_FM1_DEVIATION_100KHZ,  ATV_FM2_DEVIATION_100KHZ, ATV_AM_PRESCALE_0DB },
	// AUDIO_SOUND_STD_A2_BG
	{                  0, ATV_NICAM_BW_250KHZ,       ATV_EIAJ_DEVIATION_20KHZ, ATV_A2_BW_SEL_150KHZ,
		ATV_DEEMPHASIS_50US, ATV_FM1_DEVIATION_100KHZ,  ATV_FM2_DEVIATION_100KHZ, ATV_AM_PRESCALE_0DB },
	// AUDIO_SOUND_STD_NICAM_BG
	{                  0, ATV_NICAM_BW_250KHZ,       ATV_EIAJ_DEVIATION_20KHZ, ATV_A2_BW_SEL_150KHZ,
		ATV_DEEMPHASIS_50US, ATV_FM1_DEVIATION_100KHZ,  ATV_FM2_DEVIATION_100KHZ, ATV_AM_PRESCALE_0DB },
	// AUDIO_SOUND_STD_DK_MONO
	{                  0, ATV_NICAM_BW_250KHZ,       ATV_EIAJ_DEVIATION_20KHZ, ATV_A2_BW_SEL_150KHZ,
		ATV_DEEMPHASIS_50US, ATV_FM1_DEVIATION_100KHZ,  ATV_FM2_DEVIATION_100KHZ, ATV_AM_PRESCALE_0DB },
	// AUDIO_SOUND_STD_A2_DK1
	{                  0, ATV_NICAM_BW_250KHZ,       ATV_EIAJ_DEVIATION_20KHZ, ATV_A2_BW_SEL_150KHZ,
		ATV_DEEMPHASIS_50US, ATV_FM1_DEVIATION_100KHZ,  ATV_FM2_DEVIATION_100KHZ, ATV_AM_PRESCALE_0DB },
	// AUDIO_SOUND_STD_A2_DK2
	{                  0, ATV_NICAM_BW_250KHZ,       ATV_EIAJ_DEVIATION_20KHZ, ATV_A2_BW_SEL_150KHZ,
		ATV_DEEMPHASIS_50US, ATV_FM1_DEVIATION_100KHZ,  ATV_FM2_DEVIATION_100KHZ, ATV_AM_PRESCALE_0DB },
	// AUDIO_SOUND_STD_A2_DK3
	{                  0, ATV_NICAM_BW_250KHZ,       ATV_EIAJ_DEVIATION_20KHZ, ATV_A2_BW_SEL_150KHZ,
		ATV_DEEMPHASIS_50US, ATV_FM1_DEVIATION_100KHZ,  ATV_FM2_DEVIATION_100KHZ, ATV_AM_PRESCALE_0DB },
	// AUDIO_SOUND_STD_NICAM_DK
	{                  0, ATV_NICAM_BW_250KHZ,       ATV_EIAJ_DEVIATION_20KHZ, ATV_A2_BW_SEL_150KHZ,
		ATV_DEEMPHASIS_50US, ATV_FM1_DEVIATION_100KHZ,  ATV_FM2_DEVIATION_100KHZ, ATV_AM_PRESCALE_0DB },
	// AUDIO_SOUND_STD_AM_MONO
	{                  0, ATV_NICAM_BW_250KHZ,       ATV_EIAJ_DEVIATION_20KHZ, ATV_A2_BW_SEL_70KHZ,
		ATV_DEEMPHASIS_75US, ATV_FM1_DEVIATION_100KHZ,  ATV_FM2_DEVIATION_100KHZ,  ATV_AM_PRESCALE_6DB },
	// AUDIO_SOUND_STD_NICAM_L
	{                  0, ATV_NICAM_BW_250KHZ,       ATV_EIAJ_DEVIATION_20KHZ, ATV_A2_BW_SEL_70KHZ,
		ATV_DEEMPHASIS_75US, ATV_FM1_DEVIATION_100KHZ,  ATV_FM2_DEVIATION_100KHZ,  ATV_AM_PRESCALE_6DB },
	// AUDIO_SOUND_STD_FM_MONO_NO_I
	{                  0, ATV_NICAM_BW_250KHZ,       ATV_EIAJ_DEVIATION_20KHZ, ATV_A2_BW_SEL_100KHZ,
		ATV_DEEMPHASIS_50US, ATV_FM1_DEVIATION_100KHZ,  ATV_FM2_DEVIATION_100KHZ, ATV_AM_PRESCALE_0DB },
	// AUDIO_SOUND_STD_NICAM_I
	{                  0, ATV_NICAM_BW_350KHZ,       ATV_EIAJ_DEVIATION_20KHZ, ATV_A2_BW_SEL_100KHZ,
		ATV_DEEMPHASIS_50US, ATV_FM1_DEVIATION_100KHZ,  ATV_FM2_DEVIATION_100KHZ, ATV_AM_PRESCALE_0DB },
};
#endif
static ATV_CFG atv_cfg = {
	/* BTSC system */
	0,		//m_vol_comp_btsc_sap    = APP_VOL_0DB;
	0,		//m_vol_comp_btsc_stereo = APP_VOL_0DB;
	0,		//m_vol_comp_btsc_mono   = APP_VOL_0DB;
	0x0064,		//m_btsc_pilot_threshold_high = 0xb0;	// these are dragon's setting
	0x0044,		//m_btsc_pilot_threshold_low  = 0x70;
	0x0064,		//m_btsc_sap_threshold_high   = 0x80;
	0x0030,		//m_btsc_sap_threshold_low    = 0x60;
	//0x0050,	//m_btsc_sap_threshold_low    = 0x60;
	0x0050,		//m_btsc_sap_noise_threshold_high  = 0x1c0;
	0x0040,		//m_btsc_sap_noise_threshold_low   = 0x0c0;

	/* other systems */
	0,		//m_vol_comp_mn_dual
	0,		//m_vol_comp_mn_stereo
	0,		//m_vol_comp_mn_mono
};

static SignalFreqPos TVFreqPos[] = {
	{4500, 0},	// mn mono
	{4500, 0},	//BTSC
	{4500, 4720},	// A2 m
	{4500, 0},	//EIAJ

	{5500, 0},	// BG mono
	{5500, 5740},	// BG A2
	{5500, 5850},	// BG NICAM

	{6500, 0},	// DK mono

	{6500, 6250},	// DK1 A2
	{6500, 6740},	// DK2 A2
	{6500, 5740},	// DK3 A2

	{6500, 5850},	// DK NICAM

	{6500, 0},	// AM mono
	{6500, 5850},	// L NICAM

	{6000, 0},	// I mono
	{6000, 6552},	// I NICAM
};

#if 1
static SignalFreqShfitDetect  SignalFreqShfitDetectTable[] = {
	{-500, 0, 0, 0},
	{-450, 0, 0, 0},
	{-400, 0, 0, 0},
	{-350, 0, 0, 0},
	{  0,  0, 0},

	{-300, 0, 0, 0},
	{-250, 0, 0, 0},
	{-200, 0, 0, 0},
	{-150, 0, 0, 0},
	{  0,  0, 0},

	{-100, 0, 0, 0},
	{-50, 0, 0, 0},
	{  0,  0, 0},
	{  50, 0, 0, 0},
	{  100, 0, 0, 0},

	{  150, 0, 0, 0},
	{  200, 0, 0, 0},
	{  250, 0, 0, 0},
	{  300, 0, 0, 0},
	{  0,  0, 0},

	{  350, 0, 0, 0},
	{  400, 0, 0, 0},
	{  450, 0, 0, 0},
	{  500, 0, 0, 0},
	{  0,  0, 0},
};
#else
SignalFreqShfitDetect  SignalFreqShfitDetectTable[] ={
	{(6500 - 6500), 0, 0, 0},
	{-1000, 0, 0, 0},
	{-500, 0, 0, 0},
	{-1250, 0, 0, 0},
	{-750, 0, 0},
	{-650, 0, 0, 0},
	{-550, 0, 0, 0},
	{-250, 0, 0, 0},
	{50, 0, 0, 0},
	{250, 0, 0, 0},
	{(6500 - 6500), 0, 0, 0},
	{-1000, 0, 0, 0},
	{-500, 0, 0, 0},
	{-1250, 0, 0, 0},
	{-750, 0, 0},
	{-650, 0, 0, 0},
	{-550, 0, 0, 0},
	{-250, 0, 0, 0},
	{50, 0, 0, 0},
	{250, 0, 0, 0},	//674 //dk
};
#endif
#if 0//ndef TV001_BOARD
static uint32_t ACCU_Value[] = {
	16,
	32,
	64,
	128
};
#endif
static ATV_CFG m_atv_cfg_default = {
	APP_VOL_0DB,	//m_vol_comp_btsc_sap    = APP_VOL_0DB;
	APP_VOL_0DB,	//m_vol_comp_btsc_stereo = APP_VOL_0DB;
	APP_VOL_0DB,	//m_vol_comp_btsc_mono   = APP_VOL_0DB;
	0x00b0,		//m_btsc_pilot_threshold_high = 0xb0;	// these are dragon's setting
	0x0070,		//m_btsc_pilot_threshold_low  = 0x70;
	0x0064,		//m_btsc_sap_threshold_high   = 0x80;
	0x0050,		//m_btsc_sap_threshold_low    = 0x60;
	0x01c0,		//m_btsc_sap_noise_threshold_high  = 0x1c0;
	0x00c0		//m_btsc_sap_noise_threshold_low   = 0x0c0;

};

/* 
 * THRESHOLD_HIGH, THRESHOLD_LOW, MAIN_NOISE_TH, WEAK_TH, NORMAL_TH, STRONG_TH, TONE_4p5_SHIFT, MSD_DEBOUNCE
 */
static FM_RADIO_PARA fm_radio_parameter_gen \
	= {0x2000, 0x2000, 0x1500, 0x700, 0x2500, 0x3000, 3, 3};	/* general */

static FM_RADIO_PARA fm_radio_parameter_rmd \
	= {0x1200, 0x1200, 0x1500, 0x700, 0x1500, 0x3000, 1, 1};	/* RMD */

static FM_RADIO_PARA g_FMRadio_para
	= {0x2000, 0x2000, 0x1500, 0x700, 0x2500, 0x3000, 3, 3};	/* general */

static uint32_t	atv_flag;
static uint32_t g_A2_TH_sel = 11;
static ATV_SIF_EQ_48K_CFG k_sif_eq_48K_cfg;

/* 
 * {{ {LP_a1, 0, LP_h0}, {BP1_a1, BP1_a2, BP1_h0}, {BP2_a1, BP2_a2, BP2_h0} }}
 */
static ATV_SIF_EQ_48K_CFG atv_sif_eq_48k_tab[16] = {
	// AUDIO_SOUND_STD_MN_MONO
	{0x0, { {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} }},
	// AUDIO_SOUND_STD_BTSC
	{0x6, { {0x0, 0x0, 0x0}, {0xa644, 0x311b, 0x34c}, {0xe45f, 0x2ac3, 0x34c} }},
	// AUDIO_SOUND_STD_A2_M
	{0x0, { {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} }},
	// AUDIO_SOUND_STD_EIAJ
	{0x0, { {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} }},
	// AUDIO_SOUND_STD_BG_MONO
	{0x0, { {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} }},
	// AUDIO_SOUND_STD_A2_BG
	{0x0, { {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} }},
	// AUDIO_SOUND_STD_NICAM_BG
	{0x0, { {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} }},
	// AUDIO_SOUND_STD_DK_MONO
	{0x0, { {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} }},
	// AUDIO_SOUND_STD_A2_DK1
	{0x0, { {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} }},
	// AUDIO_SOUND_STD_A2_DK2
	{0x0, { {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} }},
	// AUDIO_SOUND_STD_A2_DK3
	{0x0, { {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} }},
	// AUDIO_SOUND_STD_NICAM_DK
	{0x0, { {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} }},
	// AUDIO_SOUND_STD_AM_MONO
	{0x1, { {0x0, 0, 0x0639}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} }},
	// AUDIO_SOUND_STD_NICAM_L
	{0x0, { {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} }},
	// AUDIO_SOUND_STD_FM_MONO_NO_I
	{0x0, { {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} }},
	// AUDIO_SOUND_STD_NICAM_I
	{0x0, { {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0}, {0x0, 0x0, 0x0} }},
};

#ifdef USE_PACFIC_STYLE
static DECLARE_WAIT_QUEUE_HEAD(audio_atv_wait);
static struct task_struct *audio_atv_thread = NULL;
static int AtvThread(void *arg);
#endif /* USE_PACFIC_STYLE */

static int set_sif_mute(unsigned int para);
static void AtvSetHwAGC(int32_t para, uint32_t fix_gain, uint32_t afe_pga_vol);
static void AtvSetPrescaleDeemphasis(uint32_t sound_std);
static void AtvSetModeDebounceCoef(uint32_t sound_std);
static void AtvSpeedupA2SoundModeDetect(ATV_SOUND_STD sound_std);
static void AtvSetFwCarrierFreq(uint32_t para, uint32_t fc_main, 
				uint32_t fc_sub, uint32_t fc_3rd);
static void AtvSetA2Parameter(void);
static void AtvSetMute(int32_t para);
static void AtvCleanStatusData(void);
static ATV_TASK_STATUS AtvGetCurrState(void);
static ATV_TASK_STATUS AtvRestoreState(void);
static ATV_TASK_STATUS AtvUpdateState(const ATV_TASK_STATUS state);
static void AtvAdjuseMainCarrierThreshold(uint32_t  threadholdHigh, 
					  uint32_t threadholdLow);
static void AtvEnableTvInterrupt(uint32_t isEnable);
static void AtvSetHwDetecteMode(ATV_HW_MSD_DETECT_MODE mode);
static void AtvCleanOldStd(void);
static ATV_SOUND_STD AtvHwDetectResult(uint32_t id, uint32_t islowThread);
static ATV_SOUND_STD AtvHwDetectResult_FMRadio(uint32_t id, 
					       uint32_t islowThread);
static void Atv_FMRadio_SetPara(ATV_FIELD_AREA area);
static uint32_t AtvCheckAGCFlag(void);
static uint32_t AtvIsMonoSystem(uint32_t std);
static void AtvGetFreqPos(uint32_t std, uint32_t *main, uint32_t *sub);
static uint32_t AtvIsMNSystem(ATV_SOUND_STD std);
static void AtvResetDefaultBW(void);
static void AtvPresetModeDebounceCoef(uint32_t sound_std);
static void AtvCheckTask(void);
static void AtvSwitch2NicamDigial(void);
static void AtvSwitch2NicamAnalog(void);
static void AtvResetErrorRateConsNum(void);
static void  AtvResetNicamOverflow(void);
static void AtvChangeDeviation(uint32_t newStd, uint32_t bwid);
static void AtvSetSoundStd(ATV_SOUND_STD sound_std);
static void AtvSetNewSoundStd(ATV_SOUND_STD sound_std);
static void AtvEnhanceNicamTrueDetect(uint32_t Enable);
static void CheckAndChangeDeviation(void);


static void AtvSetAtvClock(ENUM_AUDIO_IPT_SRC audio_ipt_src, int debug);
static void AtvSetAtvSubClock(ENUM_AUDIO_IPT_SRC audio_ipt_src, int debug);

static void AtvEnableBTSCSAPFreqCompensate(uint32_t Enable);
static void AtvEnableAMFreqCompensate(uint32_t Enable);
static void AtvSetDevBandWidth(A2_BW_SEL_T bw_sel, A2_BW_SEL_T sub_bw_sel);
#if 0//ndef TV001_BOARD
static void AtvSetA2ModeDebounceTime(ATV_A2_DEBOUNCE_TIME debounce_time);
static void AtvNormalA2SoundModeDetect(void);
static void AtvRestartIFDAGCGain(void);
static void DisableSIFEQPara(void);
#endif
#ifdef RTD289X
static void AtvBTSCSAPFreqCompensate(void);
static void AtvAMFreqCompensate(void);
#endif
static void AtvLowBTSCSAPModeDetectThreshold(void);
static void AtvNormalBTSCSAPModeDetectThreshold(void);
static int32_t AtvScanSoundStd_LG(ATV_SOUND_STD *p_sound_std, uint32_t flag);
static int32_t AtvCheckVideoTiming(ATV_SOUND_STD_MAIN_SYSTEM main_sys);
static int Check625LineDetect(void);
static ATV_SOUND_STD Audio_HwSIFRetrunSoundStandard(int debounce_sound_std);
static uint32_t AtvGetSubThresh(ATV_SUB_TONE_RATIO ratio, uint32_t subthresh);
static void AtvResetMSD(void);
static void HwpSetVolume_SIF(int32_t vol);

static pfnMuteHandling pFwDecoder0MuteCallBack = NULL;
static pfnMuteHandling pFwDecoder1MuteCallBack = NULL;

static DEFINE_SEMAPHORE(audio_hw_atv_sem);

void Audio_AtvRegMuteCallback(int decindex, pfnMuteHandling pfnCallBack)
{
	if (decindex == 0) {
			pFwDecoder0MuteCallBack = pfnCallBack;

		alog_debug("dec0 %p\n", pfnCallBack);
	} else if (decindex == 1) {
			pFwDecoder1MuteCallBack = pfnCallBack;

		alog_debug("dec1 %p\n", pfnCallBack);
	}
}

void Audio_AtvMuteDecoder(bool isMute)
{
	ENUM_AI_PATH path_sel = ENUM_AI_PB_PATH;

	if(g_Atvpath_PB == 1)
		path_sel = ENUM_AI_PB_PATH;
	else if(g_Atvpath_TS == 1)
		path_sel = ENUM_AI_TS_PATH;
	else
		alog_err("pFwDecoder0MuteCallBack is not ready %d!!!\n", __LINE__);

	if (pFwDecoder0MuteCallBack != NULL)
		rtk_snd_set_decoder_mute(isMute, path_sel);
	else if (g_SetMode_Mute == 1) //NULL & SetMode
		g_InternalDecoder_0_FAIL = 1;

	if (pFwDecoder1MuteCallBack != NULL)
		rtk_snd_set_decoder_mute(isMute, path_sel);
	else if (g_SetMode_Mute == 1) //NULL & SetMode
		g_InternalDecoder_1_FAIL = 1;
}

void Audio_AtvTaskSemPost(const char *msg)
{
	up(&audio_sem_atv);
}

void Audio_AtvTaskSemWait(const char *msg)
{
	if (down_interruptible(&audio_sem_atv))
		alog_warning("interrupted, no semaphore held\n");
}

void Audio_AtvEnableAutoChangeStdFlag(int32_t enable)
{
	if (enable == 1)
		g_isAutoDetect = ATV_SOUND_STD_AUTO;
	else
		g_isAutoDetect = 0;

}

void Audio_AtvAutoChange2Mono(int enable)
{
	if (enable == 1)
		g_isForce2MonoSystem = 1;
	else
		g_isForce2MonoSystem = 0;
}

#ifdef USE_PACFIC_STYLE
int32_t Audio_AtvSetSoundStd(ATV_SOUND_STD_MAIN_SYSTEM main_system,
			     ATV_SOUND_STD sound_std)
{
	//ATV_AUDIO_SIF_TYPE_T flags;

	//	audio_msd_crtl_word_RBUS	MSD_CTRL_REG;
	audio_msd_result_RBUS MSD_RESULT_REG;

	//TODO::
	/*
	    AIO_PATH_CFG 		t_path_cfg;
	*/
	if (sound_std == (ATV_SOUND_STD)g_UserStd)
		return ATV_OK; //avoid setting too many times.
#if 0
if(g_user_config == AUDIO_USER_CONFIG_TV002)
{
	AUDIO_SIF_SetBandSetup(ATV_AUDIO_SIF_DVB_SELECT, main_system); //DVB sif type for all std in RTK TV
}
#endif
	if (1 == g_wait_tunner_delay) {
#define AUDIO_SIF_SEL_TYPE	(ATV_AUDIO_SIF_BTSC_SELECT | \
				 ATV_AUDIO_SIF_BTSC_BR_SELECT | \
				 ATV_AUDIO_SIF_BTSC_US_SELECT | \
				 ATV_AUDIO_SIF_KOREA_A2_SELECT)
		if ((g_CurSifType & AUDIO_SIF_SEL_TYPE) == 0) {
			alog_debug("start set mode Delay\n");
			audio_hw_usleep(210000);	// 210ms
			g_wait_tunner_delay = 0;
		}

	}

	alog_info("set sound std( %x %x )\n", main_system, sound_std);

	alog_info("( Mono %x %x)\n", g_isForce2MonoSystem, g_isAutoDetect);

	//USER:Peter_Lin DATE:2010/12/10
	// change to mono system for china style
	
	if (g_isForce2MonoSystem == 1)
		sound_std = Audio_AtvConvert2MonoStd(sound_std);

	// TODO: stop scanning carrier offset
#ifdef LG_NO_SIGNAL_NOISE_SOUND
	MSD_RESULT_REG.regValue = AIO_ReadRegister(AUDIO_msd_result_reg);
	if (MSD_RESULT_REG.hw_detected_std == ATV_SOUND_STD_UNKNOWN) {
		g_LG_NoSignal++;
		if (g_LG_NoSignal > 11)
			g_LG_NoSignal = 12;
	} else {
		g_LG_NoSignal = 0;
	}

	if (g_LG_NoSignal == 11) {
		AtvCleanTVMuteNum();
		Audio_HwpSetMute(ATV_DISABLE,
				 ATV_CH_ID_L|ATV_CH_ID_R|ATV_CH_ID_LS|ATV_CH_ID_RS,
				 AP_MUTE_ID);
		Audio_HwpSetMuteTS(ATV_DISABLE,
				   ATV_CH_ID_L|ATV_CH_ID_R|ATV_CH_ID_LS|ATV_CH_ID_RS,
				   AP_MUTE_ID);
		AtvSetMute(ATV_DISABLE);
		alog_info("set mode Disable mute....\n");
	} else if (g_LG_NoSignal == 12) { //525
		alog_info("set mode No mute....\n");
	} else {
		AtvSetMute(ATV_ENABLE);
		alog_info("set mode MuTe....\n");
	}
#else
	//alog_info("SetMode...Mute... \n");
	g_SetMode_Mute = 1;
	AtvSetMute(ATV_ENABLE);
	//alog_info("SetMode...unMute... \n");
#endif

	// turn-off F/W carrier setting
	AtvSetFwCarrierFreq(ATV_DISABLE, 0, 0, 0);

	Audio_AtvSetPlayChannel(ATV_PLAY_CH_SEL_L, ATV_PLAY_CH_SEL_R);  // reset to stereo

	// add later
	//AtvRestartIFDAGCGain(); //Clayton 2015/4/29 No need to use here
	//ResetAMPrescale();

	// disable TV-related interrupts temporarily.
	AtvEnableTvInterrupt(ATV_DISABLE);

	g_UserStdMainSystem = main_system % (ATV_SOUND_UNKNOWN_SYSTEM + 1); // invalid check
	g_UserStd = sound_std&0xFF;

#if 0//def TV001_BOARD
if(g_user_config == AUDIO_USER_CONFIG_TV001){
	//change outputlevel only for K3L CN model ryanliao 20161103
	if (sound_std == ATV_SOUND_STD_A2_M && g_CurSifType == ATV_AUDIO_SIF_DVB_CN_SELECT) {
		HwpSetVolume_SIF(48); // SIF gain 6dB
	} else {
		HwpSetVolume_SIF(0);  // SIF gain 0dB
	}
}
else
{
	if (sound_std == ATV_SOUND_STD_BTSC)
		HwpSetVolume_SIF(48);
	else HwpSetVolume_SIF(0);
}
#endif

	// ryanliao 20161123
	// For LG E-07 channel NICAM BG true detect issue, KTASKWBS-6003 No sound in DK special streamit, P/N ratio QA testing
	// it need to change fixed gain 3.5db or using auto gain
	if (sifsource == SIF_FROM_SIF_ADC) {
		if ((sound_std == ATV_SOUND_STD_NICAM_L) || (sound_std == ATV_SOUND_STD_AM_MONO)) {
		#ifdef RTD289X
			// SIF AGC fixed gain +6.5dB
			AtvSetHwAGC(ATV_DISABLE, 0x8, 0x4);
			alog_debug("External SIF case, SIF PGA = +6.5dB\n");
		#else  //SIF PGA cost down after RTD289X
			// SIF AGC fixed gain +6dB
			AtvSetHwAGC(ATV_DISABLE, 0x0, 0x6);
			alog_debug("External SIF case, SIF PGA = +6dB\n");
		#endif
		} else {
			// SIF AGC auto gain
			AtvSetHwAGC(AIO_ENABLE, 0, 0);
			alog_debug("External SIF case, SIF PGA = auto gain\n");
		}
	} else { //575
		 // SIF AGC enable
		AtvSetHwAGC(ATV_ENABLE, 0, 0);
		alog_debug("Internal SIF case, SIF AGC enable\n");
	}

	if ((sound_std == ATV_SOUND_STD_AM_MONO) || (sound_std == ATV_SOUND_STD_NICAM_L))
		Audio_AtvSetMtsPriority(ATV_MTS_PRIO_L);
	else
		Audio_AtvSetMtsPriority(ATV_MTS_PRIO_DK);

	if (ATV_SOUND_STD_BTSC == g_UserStd) // no eiaj code
		Audio_AtvSetMtsPriority(ATV_MTS_PRIO_BTSC);
	else
		Audio_AtvSetMtsPriority(ATV_MTS_PRIO_MONO);

	//	drv_audio_set_backendplay(AUD_DISABLE); ?

	//	audio_set_hw_detecte_mode(ATV_HW_DISABLE);

	//	audio_enable_hw_update_std_result(AUD_DISABLE);

	AtvSetHwDetecteMode(ATV_HW_CARRIER_SHIFT_BANDWIDTH);

	//	if(sound_std == ATV_SOUND_STD_AUTO) {

	//	}else

	{
		/*
		 * step 1. use MSD to check if standard exist.
		 * step 2. use freq_offset or 2nd_phase to lock standard (move to sub-routine in the future)
		 */



		//AtvSetSoundStd(sound_std);

		MSD_RESULT_REG.regValue = AIO_ReadRegister(AUDIO_msd_result_reg);

		//USER:Peter_Lin DATE:2010/12/15
		// enable
#if 0
		//USER:Peter_Lin DATE:2010/12/13
		// wait ifd to finish init
		
		if(g_WaitIFDInitFinish != WAIT_IFD_FINISH){
			alog_info("wait IFD init %x %x \n", main_system, sound_std);
			MSD_RESULT_REG.reg_std = ATV_SOUND_STD_UNKNOWN;
		} else
		MSD_RESULT_REG.reg_std = g_UserStd; // speed up sound mode
						    


#else
		MSD_RESULT_REG.reg_std = g_UserStd; // speed up sound mode
#endif

		AtvSetSoundStd((ATV_SOUND_STD)g_UserStd); //error: MSD_RESULT_REG.regValue

		//USER:Peter_Lin DATE:2010/12/13
		// wait ifd to finish init
		if (g_UserStd != ATV_SOUND_STD_UNKNOWN) {
			// TODO: ioctl change Clock/PLL setting
			//g_SetStdFlag = 1;
			g_TVAudioReady = 0;
			// 48K
			//	ioctl(audio_fd, ATV_CMD_SET_CLOCK, AIO_PATH_SRC_ATV); // default use 48k
			AtvSetAtvClock(AUDIO_IPT_SRC_ATV, __LINE__);
			AtvSetAtvSubClock(AUDIO_IPT_SRC_ATV, __LINE__);
		}
	}

	if (sound_std == ATV_SOUND_STD_A2_M && g_CurSifType == ATV_AUDIO_SIF_KOREA_A2_SELECT) { //585
		A2_Th_Table = A2_Th_MN_Table;
	} else {
		A2_Th_Table = A2_Th_Normal_Table;
	}

	if ((sound_std == ATV_SOUND_STD_A2_M && g_CurSifType != ATV_AUDIO_SIF_KOREA_A2_SELECT) ||
	    sound_std == ATV_SOUND_STD_A2_BG  ||
	    sound_std == ATV_SOUND_STD_A2_DK1 ||
	    sound_std == ATV_SOUND_STD_A2_DK2 ||
	    sound_std == ATV_SOUND_STD_A2_DK3) {
		audio_global_ctrl_1_RBUS global_ctrl_1;
		audio_a2_eiaj_demod_RBUS a2_eiaj_demod;

		global_ctrl_1.regValue = AIO_ReadRegister(AUDIO_global_ctrl_1_reg);

		a2_eiaj_demod.regValue = AIO_ReadRegister(AUDIO_a2_eiaj_demod_reg);
		//g_save_hdv_mode_sel = global_ctrl_1.hdv_mode_sel;
		//g_save_a2_bw_sel = a2_eiaj_demod.a2_bw_sel;
		global_ctrl_1.hdv_mode_sel = 0;
		a2_eiaj_demod.a2_bw_sel = 2;
		a2_eiaj_demod.a2_sub_bw_sel = 2;
		AIO_WriteRegister(AUDIO_a2_eiaj_demod_reg, a2_eiaj_demod.regValue);
		AIO_WriteRegister(AUDIO_global_ctrl_1_reg, global_ctrl_1.regValue);
		//g_a2_deviation_change = 1;
		alog_info("Set A2 dev\n");
	}
	//else if(sound_std == ATV_SOUND_STD_BG_MONO || sound_std == ATV_SOUND_STD_DK_MONO)
	else { //595
		AtvSetDevBandWidth(g_FM1_bw, g_FM2_bw);
	}

	//Move for driver base

	//AtvChangeStdCleanData(); //not add first
	MSD_RESULT_REG.regValue = AIO_ReadRegister(AUDIO_msd_result_reg);
	MSD_RESULT_REG.reg_std = ATV_SOUND_STD_UNKNOWN;
	AIO_WriteRegister(AUDIO_msd_result_reg, MSD_RESULT_REG.regValue);

	AtvSetNewSoundStd((ATV_SOUND_STD)g_UserStd);
	g_CurrentStd = g_UserStd; //for LG
				  //Move for driver base .....end

	//clean sound mode status
	g_A2_soundmode = 0;
	g_nicam_soundmode = 0;
	g_btsc_soundmode = 0;

	return ATV_OK;
}

#endif

/**
 * Select ATV play channel
 * this function only affect the data into post-processing,
 * it cannot control the ATV audio decoder.
 *
 * @param <sound_sel>	{ ATV_PLAY_CH_SEL_XXX , refer to audio_atv.h }
 * @return				{ ATV_OK or AIO_ERROR_CODE }
 * @ingroup lib_audio
 */
int32_t Audio_AtvSetPlayChannel(ATV_PLAY_CH_SEL l_sel, ATV_PLAY_CH_SEL r_sel)
{


	// TODO: use DS_FIFO_SEL instead of this feature, but how about TS_PATH ??!
	//	alog_info("Audio_AtvSetPlayChannel is still underconstruction\n");


	return ATV_OK;
}

static void AtvSleep(uint32_t msec)
{
	audio_hw_usleep(msec*1000);
}

/**
 * Select ATV Sound/Language
 *
 * @param <sound_sel>	{ ATV_SOUND_SEL_XXX , refer to audio_atv.h }
 * @return				{ ATV_OK or AIO_ERROR_CODE }
 * @ingroup lib_audio
 */
int32_t Audio_AtvSetSoundSelect(ATV_SOUND_SEL sound_sel)
{
	audio_msd_crtl_word_RBUS	MSD_CTRL_REG;

	alog_info("change SoundSelect to %d\n", sound_sel);

	MSD_CTRL_REG.regValue = AIO_ReadRegister(AUDIO_msd_crtl_word_reg);
	MSD_CTRL_REG.sound_select = sound_sel;
	AIO_WriteRegister(AUDIO_msd_crtl_word_reg, MSD_CTRL_REG.regValue);

	return ATV_OK;
}



#if 0
/**
 * Set ATV BTSC Sound/Language Volume Compensation
 *
 * @param <comp_mono>	{ compensation value of mono sound }
 * @param <comp_stereo>	{ compensation value of stereo sound }
 * @param <comp_sap>	{ compensation value of sap sound }
 * @return			{ ATV_OK or AIO_ERROR_CODE }
 * @ingroup lib_audio
 */
int32_t Audio_AtvSetBtscMtsVolume(int32_t comp_mono, int32_t comp_stereo, int32_t comp_sap){
	//	sem_wait(&audio_sem_atv);

	atv_cfg.m_vol_comp_btsc_mono   = comp_mono;
	atv_cfg.m_vol_comp_btsc_stereo = comp_stereo;
	atv_cfg.m_vol_comp_btsc_sap    = comp_sap;

	//	sem_post(&audio_sem_atv);

	return ATV_OK;
}
#endif

/**
 * Select ATV MTS Priority
 *
 * @param <mts_prio>	{ ATV_MTS_PRIO_XXX , refer to audio_atv.h }
 * @return				{ ATV_OK or AIO_ERROR_CODE }
 * @ingroup lib_audio
 */
int32_t Audio_AtvSetMtsPriority(ATV_MTS_PRIORITY mts_prio)
{
	audio_msd_crtl_word_RBUS	MSD_CTRL_REG;

	MSD_CTRL_REG.regValue = AIO_ReadRegister(AUDIO_msd_crtl_word_reg);

	switch (mts_prio) {
	case ATV_MTS_PRIO_BTSC:
		MSD_CTRL_REG.mn_priority = ATV_MN_PRIO_BTSC;
		break;
	case ATV_MTS_PRIO_EIAJ:
		MSD_CTRL_REG.mn_priority = ATV_MN_PRIO_EIAJ;
		break;
	case ATV_MTS_PRIO_MONO:
		MSD_CTRL_REG.mn_priority = ATV_MN_PRIO_MONO1;
		break;
	case ATV_MTS_PRIO_DK:
		MSD_CTRL_REG.dkl_priority = ATV_DKL_PRIO_DK;
		break;
	case ATV_MTS_PRIO_L:
		MSD_CTRL_REG.dkl_priority = ATV_DKL_PRIO_L;
		break;
	default:
		MSD_CTRL_REG.mn_priority = ATV_MN_PRIO_MONO2;
		MSD_CTRL_REG.dkl_priority = ATV_DKL_PRIO_DK;
		break;
	}

	AIO_WriteRegister(AUDIO_msd_crtl_word_reg, MSD_CTRL_REG.regValue);

	return ATV_OK;
}


#ifndef USE_PACFIC_STYLE


#else

/**
 * Query current ATV Sound Standard
 *
 * @param <p_sound_std>	{ current Sound Standard }
 * @return				{ ATV_OK or AIO_ERROR_CODE }
 * @ingroup lib_audio
 */
int32_t Audio_AtvGetSoundStd(ATV_SOUND_INFO *p_sound_info)
{
	audio_msd_crtl_word_RBUS			MSD_CTRL_REG;
	//	audio_msd_result_RBUS				MSD_RESULT_REG;
	//	audio_mode_detect_RBUS			MODE_DETECT_REG;
	//	audio_nicam_decode_status_RBUS	MODE_NICAM_REG;
	//	 ATV_NONBTSC_SOUND_MODE soundmode;
	//audio_down_sample_control_for_playback_RBUS down_sample_control_for_playback;

	// std
	/*  20101/10/25 // mark for btsc  using fm mono decode
	MSD_RESULT_REG.regValue = AIO_ReadRegister(AUDIO_msd_result_reg);
	p_sound_info->sound_std = MSD_RESULT_REG.reg_std;
	*/
	p_sound_info->sound_std = (ATV_SOUND_STD)g_CurrentStd;

	if (AtvIsNicamSystem(p_sound_info->sound_std) == 1)
		p_sound_info->isNicamSystem = 1;
	else
		p_sound_info->isNicamSystem = 0;

	p_sound_info->isNicamhiErrorRate = 0;

	// get sound select
	MSD_CTRL_REG.regValue = AIO_ReadRegister(AUDIO_msd_crtl_word_reg);

	if ((p_sound_info->isNicamSystem)) {

		p_sound_info->isNicamhiErrorRate = (g_NicamSignalStable == 0);

		p_sound_info->std_type = ATV_MAIN_STD_NICAM;

		if (MSD_CTRL_REG.sound_select == ATV_SOUND_SEL_FMAM)
			p_sound_info->isPlayDigital = 0;
		else
			p_sound_info->isPlayDigital = 1;

		p_sound_info->ana_soundmode = ATV_SOUND_MODE_MONO;

		// get digital sound_mode
		//	MODE_NICAM_REG.regValue = AIO_ReadRegister(AUDIO_nicam_decode_status_reg);

		//	switch(MODE_NICAM_REG.c1c2c3)
		switch (g_nicam_soundmode) {
		case ATV_SOUND_MODE_STEREO:
			p_sound_info->dig_soundmode = ATV_SOUND_MODE_STEREO;
			if (MSD_CTRL_REG.sound_select == ATV_SOUND_SEL_FMAM)
				p_sound_info->current_select = ATV_SOUND_SELECT_MONO;
			else
				p_sound_info->current_select = ATV_SOUND_SELECT_STEREO;

			break;
		case ATV_SOUND_MODE_DUAL:
			p_sound_info->dig_soundmode = ATV_SOUND_MODE_DUAL;
			if (MSD_CTRL_REG.sound_select == ATV_SOUND_SEL_FMAM)
				p_sound_info->current_select = ATV_SOUND_SELECT_MONO;
			else if (MSD_CTRL_REG.sound_select == 3)
				p_sound_info->current_select = ATV_SOUND_SELECT_LANGB;
			else if (MSD_CTRL_REG.sound_select == 2)
				p_sound_info->current_select = ATV_SOUND_SELECT_LANGA;
			else
				p_sound_info->current_select = ATV_SOUND_SELECT_LANGAB;

			break;
		default :
			//case 4:// mono
		case ATV_SOUND_MODE_MONO:
			p_sound_info->dig_soundmode = ATV_SOUND_MODE_MONO;
			if (MSD_CTRL_REG.sound_select == ATV_SOUND_SEL_FMAM)
				p_sound_info->current_select = ATV_SOUND_SELECT_MONO;
			else
				p_sound_info->current_select = ATV_SOUND_SELECT_MONO;

			break;

		}

	} else  if (AtvIsBTSCSystem(p_sound_info->sound_std)) {
		p_sound_info->isNicamSystem = 0;
		p_sound_info->isPlayDigital = 0;
		//drv_audio_get_btscsoundmode(&soundmode);
		p_sound_info->dig_soundmode = ATV_SOUND_MODE_MONO;
		p_sound_info->std_type = ATV_MAIN_STD_BTSC;

		switch (g_btsc_soundmode) {
		default:
		case ATV_SOUND_MODE_MONO :
			p_sound_info->ana_soundmode = ATV_SOUND_MODE_MONO;
			p_sound_info->current_select = ATV_SOUND_SELECT_MONO;
			break;
		case ATV_SOUND_MODE_STEREO   :
			//down_sample_control_for_playback.regValue = AIO_ReadRegister( AUDIO_down_sample_control_for_playback_reg);
			p_sound_info->ana_soundmode = ATV_SOUND_MODE_STEREO;

			/*
			if(g_UserTVBTSCISStereo == 0)
			    p_sound_info->current_select= ATV_NONBTSC_SOUND_SELECT_MONO;
			else
			    p_sound_info->current_select= ATV_NONBTSC_SOUND_SELECT_STEREO;
			*/


			if (MSD_CTRL_REG.sound_select == ATV_SOUND_SEL_FMAM)
				p_sound_info->current_select = ATV_SOUND_SELECT_MONO;
			// Clayton 2013/1/3
			// [Audio][ATV]Update BTSC sound mode setting method

			else
				p_sound_info->current_select = ATV_SOUND_SELECT_STEREO;

			break;
		case	ATV_SOUND_MODE_SAP_MONO :
			p_sound_info->ana_soundmode = ATV_SOUND_MODE_SAP_MONO;
			/*
			if(g_UserTVBTSCSAP == 0)
			    p_sound_info->current_select= ATV_NONBTSC_SOUND_SELECT_MONO;
			else
			    p_sound_info->current_select= ATV_BTSC_SOUND_SELECT_SAP;
			*/

			if (MSD_CTRL_REG.sound_select == ATV_SOUND_SEL_STEREO_A)
				p_sound_info->current_select = ATV_SOUND_SELECT_MONO;
			else
				p_sound_info->current_select = ATV_SOUND_SELECT_SAP;

			break;
		case ATV_SOUND_MODE_SAP_STEREO :
			// Clayton 2013/1/3
			// [Audio][ATV]Update BTSC sound mode setting method
			//down_sample_control_for_playback.regValue = AIO_ReadRegister( AUDIO_down_sample_control_for_playback_reg);
			p_sound_info->ana_soundmode = ATV_SOUND_MODE_SAP_STEREO;

			/*
			if(g_UserTVBTSCSAP == 1)
			    p_sound_info->current_select= ATV_BTSC_SOUND_SELECT_SAP;
			else if(g_UserTVBTSCISStereo == 0)
			    p_sound_info->current_select= ATV_NONBTSC_SOUND_SELECT_MONO;
			else
			    p_sound_info->current_select= ATV_NONBTSC_SOUND_SELECT_STEREO;
			*/

			// Clayton 2013/1/3
			// [Audio][ATV]Update BTSC sound mode setting method
			if (MSD_CTRL_REG.sound_select == ATV_SOUND_SEL_STEREO_B)
				p_sound_info->current_select = ATV_SOUND_SELECT_SAP;
			else if (MSD_CTRL_REG.sound_select == ATV_SOUND_SEL_FMAM)
				p_sound_info->current_select = ATV_SOUND_SELECT_MONO;
			else
				p_sound_info->current_select = ATV_SOUND_SELECT_STEREO;

			break;
		}
	} else if (AtvIsA2System(p_sound_info->sound_std)) {
		p_sound_info->isPlayDigital = 0;
		p_sound_info->dig_soundmode = ATV_SOUND_MODE_MONO;
		p_sound_info->std_type = ATV_MAIN_STD_A2;

		// get analog sound_mode
		//MODE_DETECT_REG.regValue = AIO_ReadRegister(AUDIO_mode_detect_reg);
		switch (g_A2_soundmode) {
		case ATV_SOUND_MODE_STEREO:
			p_sound_info->ana_soundmode = ATV_SOUND_MODE_STEREO;
			if (MSD_CTRL_REG.sound_select == ATV_SOUND_SEL_FMAM)
				p_sound_info->current_select = ATV_SOUND_SELECT_MONO;
			else
				p_sound_info->current_select = ATV_SOUND_SELECT_STEREO;

			break;
		case ATV_SOUND_MODE_DUAL: // Mono(A2) or Stereo+SAP(BTSC)
			p_sound_info->ana_soundmode = ATV_SOUND_MODE_DUAL;

			if (MSD_CTRL_REG.sound_select == ATV_SOUND_SEL_STEREO_B)
				p_sound_info->current_select = ATV_SOUND_SELECT_LANGB;
			else if (MSD_CTRL_REG.sound_select == ATV_SOUND_SEL_STEREO_A)
				p_sound_info->current_select = ATV_SOUND_SELECT_LANGA;
			else
				p_sound_info->current_select = ATV_SOUND_SELECT_LANGAB;

			break;
		case ATV_SOUND_MODE_MONO:
		default:
			p_sound_info->ana_soundmode = ATV_SOUND_MODE_MONO;
			p_sound_info->current_select = ATV_SOUND_SELECT_MONO;
			break;
		}

	} else { // mono
		p_sound_info->dig_soundmode = ATV_SOUND_MODE_MONO;
		if (AtvIsMonoSystem(p_sound_info->sound_std))
			p_sound_info->std_type = ATV_MAIN_STD_MONO;
		else
			p_sound_info->std_type = ATV_MAIN_STD_UNKNOW;

		p_sound_info->isPlayDigital = 0;
		p_sound_info->ana_soundmode = ATV_SOUND_MODE_MONO;
		p_sound_info->current_select = ATV_SOUND_SELECT_MONO;

	}

	/*
	    alog_info("isNicamSystem %x \n", p_sound_info->isNicamSystem);
	    alog_info("nicam er %x \n", p_sound_info->isNicamhiErrorRate);
	    ATV_LOG( "isPlayDigital %x \n", p_sound_info->isPlayDigital);
	    ATV_LOG( "current_select %x \n", p_sound_info->current_select);
	    ATV_LOG( "sound_std %x \n", p_sound_info->sound_std);
	    ATV_LOG( "soundmode %x \n", p_sound_info->ana_soundmode);
	    ATV_LOG( "soundmode d %x \n \n", p_sound_info->dig_soundmode);
	*/
	return ATV_OK;
}


#endif




/**
 * Scan/Find current ATV Sound Standard
 *
 * @param <p_sound_std>	{ result of scanning }
 * @prarm <flag>		{ refer to ATV_MSD_OPT in audio_atv.h }
 * @return				{ ATV_OK or AIO_ERROR_CODE }
 * @ingroup lib_audio
 */


#if 0
void AtvPrintScanTime(struct timeval*  timeval1, struct timeval*  timeval2, int index){
	int needtime;
	int needsec;

	if(timeval1->tv_sec == timeval2->tv_sec){
		needsec = 0;
		needtime = timeval2->tv_usec - timeval1->tv_usec;
	} else {
		needtime = (1000000 - timeval1->tv_usec) + timeval2->tv_usec;
		needsec = timeval2->tv_sec - timeval1->tv_sec -1;
	}

	ATV_LOG( "scan %2d %2d sec %8d usec \n", index, needsec , needtime);
}

#else
#define  AtvPrintScanTime( v1, v2, v3)
#endif

//USER:Peter_Lin DATE:2011/04/18
// fix HXXX COMPANY maintone too low

uint32_t AtvGetNicamErrorRate(uint32_t CheckNum);


int32_t AtvIsUnNormalSignal(uint32_t  regValue)
{
	audio_msd_status_RBUS amsd_status;

	amsd_status.regValue = regValue;

	return amsd_status.deviation >= 0x4; // 200K


}

int32_t AtvScanSoundStd_LG(ATV_SOUND_STD *p_sound_std, uint32_t flag)
{

	uint32_t toneenergy[4];
	uint32_t maxid, maxengery, i, secondenergy;

	audio_msd_result_RBUS msd_result;

	audio_bw_threshold_RBUS bw_threshold;



	audio_msd_mag_4_5_RBUS amsd_mag_4_5_RBUS;
	audio_msd_mag_5_5_RBUS amsd_mag_5_5_RBUS;
	audio_msd_mag_6_RBUS amsd_mag_6_RBUS;
	audio_msd_carrier_6_5_RBUS amsd_carrier_6_5_RBUS;

	AtvSetFwCarrierFreq(ATV_DISABLE, 0, 0, 0);


	// disable all interrupt
	AtvEnableTvInterrupt(ATV_DISABLE);

	//	audio_enable_hw_update_std_result(AUD_DISABLE); // default is disable

	bw_threshold.regValue	 = AIO_ReadRegister(AUDIO_bw_threshold_reg);
	bw_threshold.bw_dev_thresh_hd = g_AudioTVNormalBWThredhold; // default
	bw_threshold.bw_dev_thresh = g_AudioTVNormalBWThredhold;
	AIO_WriteRegister(AUDIO_bw_threshold_reg, bw_threshold.regValue);

	amsd_mag_4_5_RBUS.regValue = AIO_ReadRegister(AUDIO_msd_mag_4_5_reg);
	toneenergy[0] = amsd_mag_4_5_RBUS.reg_mag_4_5;

	amsd_mag_5_5_RBUS.regValue = AIO_ReadRegister(AUDIO_msd_mag_5_5_reg);
	toneenergy[1] = amsd_mag_5_5_RBUS.reg_mag_5_5;

	amsd_mag_6_RBUS.regValue = AIO_ReadRegister(AUDIO_msd_mag_6_reg);
	toneenergy[2] = amsd_mag_6_RBUS.reg_mag_6;

	amsd_carrier_6_5_RBUS.regValue = AIO_ReadRegister(AUDIO_msd_carrier_6_5_reg);

	toneenergy[3] = amsd_carrier_6_5_RBUS.reg_mag_6_5;

	maxid = 0;
	maxengery = 0;
	secondenergy = 0;




	for (i = 0; i < 4; i++) {
		if (toneenergy[i] >= maxengery) {
			secondenergy = maxengery;
			maxid = i;
			maxengery = toneenergy[i];
		} else if (toneenergy[i] >= secondenergy) {
			secondenergy = toneenergy[i];
		}

		alog_info("new tone energy  %x  \n", toneenergy[i]);
	}

	AtvAdjuseMainCarrierThreshold(g_AudioTVNormalMainToneThredhold_High, g_AudioTVNormalMainToneThredhold_Low);
	msd_result.hw_detected_std = AtvHwDetectResult(2, 0); // get deviation value


	if (p_sound_std != NULL)
		*p_sound_std = (ATV_SOUND_STD)msd_result.hw_detected_std;

	return ATV_OK;
	;
}

int32_t Audio_AtvScanSoundStd(ATV_SOUND_STD *p_sound_std, uint32_t flag)
{
	uint32_t toneenergy[4], lowthreadflag;
	uint32_t maxid, maxengery, i, secondenergy;
	uint32_t mainFreqPos, mainFreqPos2, a;

	audio_msd_crtl_word_RBUS msd_crtl_word;
	//	audio_msd_second_reg_std_RBUS msd_second_reg_std;
	audio_msd_result_RBUS msd_result, msd_result2;

	audio_bw_threshold_RBUS bw_threshold;

	//USER:Peter_Lin DATE:2011/04/18
	// fix HXXX COMPANY maintone too low
	
	uint32_t NicamErrorRate;
	

	//struct timeval timeval1, timeval2, timeval3, timeval4, timeval5;
	//gettimeofday(&timeval1, NULL);

	audio_msd_mag_4_5_RBUS amsd_mag_4_5_RBUS;
	audio_msd_mag_5_5_RBUS amsd_mag_5_5_RBUS;
	audio_msd_mag_6_RBUS amsd_mag_6_RBUS;
	audio_msd_carrier_6_5_RBUS amsd_carrier_6_5_RBUS;

	// disable now
	msd_crtl_word.regValue = AIO_ReadRegister(AUDIO_msd_crtl_word_reg);
	msd_crtl_word.fw_scan_freq = ATV_FW_SCAN_HW_ONLY;    // Clayton, 2013/1/11

	msd_crtl_word.msd_en = FALSE;
	msd_crtl_word.update_en = FALSE; // on interrupt
	msd_crtl_word.carrier_shift_scan_en = FALSE;  // old function
	AIO_WriteRegister(AUDIO_msd_crtl_word_reg, msd_crtl_word.regValue);

	AtvSetFwCarrierFreq(ATV_DISABLE, 0, 0, 0);

	// disable all interrupt
	AtvEnableTvInterrupt(ATV_DISABLE);

	//	audio_enable_hw_update_std_result(AUD_DISABLE); // default is disable

	// normal detect
	AtvSetHwDetecteMode(ATV_HW_DISABLE);

	msd_result.hw_detected_std = ATV_SOUND_STD_UNKNOWN;

	// shift case
	AtvSetHwDetecteMode(ATV_HW_CARRIER_NO_SHIFT_NO_BANDWIDTH);
	AtvCleanOldStd(); //

	//gettimeofday(&timeval2, NULL);

	bw_threshold.bw_dev_thresh_hd = g_AudioTVNormalBWThredhold; // default
	bw_threshold.bw_dev_thresh = g_AudioTVNormalBWThredhold;
	AIO_WriteRegister(AUDIO_bw_threshold_reg, bw_threshold.regValue);

	amsd_mag_4_5_RBUS.regValue = AIO_ReadRegister(AUDIO_msd_mag_4_5_reg);
	toneenergy[0] = amsd_mag_4_5_RBUS.reg_mag_4_5;

	amsd_mag_5_5_RBUS.regValue = AIO_ReadRegister(AUDIO_msd_mag_5_5_reg);
	toneenergy[1] = amsd_mag_5_5_RBUS.reg_mag_5_5;

	amsd_mag_6_RBUS.regValue = AIO_ReadRegister(AUDIO_msd_mag_6_reg);
	toneenergy[2] = amsd_mag_6_RBUS.reg_mag_6;

	amsd_carrier_6_5_RBUS.regValue = AIO_ReadRegister(AUDIO_msd_carrier_6_5_reg);

	toneenergy[3] = amsd_carrier_6_5_RBUS.reg_mag_6_5;

	maxid = 0;
	maxengery = 0;
	secondenergy = 0;
	lowthreadflag = 0;

	for (i = 0; i < 4; i++) {
		if (toneenergy[i] >= maxengery) {
			secondenergy = maxengery;
			maxid = i;
			maxengery = toneenergy[i];
		} else if (toneenergy[i] >= secondenergy) {
			secondenergy = toneenergy[i];
		}

		alog_info("tone energy  %x  \n", toneenergy[i]);
	}

	//gettimeofday(&timeval3, NULL);

	//USER:Peter_Lin DATE:2011/01/27
	// fix HXXX COMPANY maintone too low

	if (((maxengery - secondenergy) < (g_AudioTVNormalMainToneThredhold_High + 500)) && (maxengery >= g_AudioTVNormalMainToneThredhold_High))
		lowthreadflag = 1;
	else
		lowthreadflag = 0;

	if (lowthreadflag == 1 && ((g_AudioTVControlFlag&ENABLE_MAINTONE_THRESHOLD_ADJUST) == ENABLE_MAINTONE_THRESHOLD_ADJUST)) {
		// for h company
		alog_info("low thd case \n");

		msd_crtl_word.regValue = AIO_ReadRegister(AUDIO_msd_crtl_word_reg);
		msd_crtl_word.msd_debounce_cnt = 0; // sync  at version
		AIO_WriteRegister(AUDIO_msd_crtl_word_reg, msd_crtl_word.regValue);

		AtvSetHwDetecteMode(ATV_HW_CARRIER_NO_SHIFT_NO_BANDWIDTH);

		AtvAdjuseMainCarrierThreshold(g_AudioTVLOWTHDMainToneThredhold_High, g_AudioTVLOWTHDNormalMainToneThredhold_Low);
		msd_result.hw_detected_std = AtvHwDetectResult(3, 1); // get deviation value

		//USER:Peter_Lin DATE:2011/04/18
		// fix HXXX COMPANY maintone too low
		
		if (((msd_result.hw_detected_std == ATV_SOUND_STD_FM_MONO_NO_I) || (msd_result.hw_detected_std == ATV_SOUND_STD_NICAM_I))) {
			// Check NICAM DK
			AtvSetSoundStd(ATV_SOUND_STD_NICAM_DK);
			i = 10;
			while (i--) {
				audio_hw_usleep(500000); // 500 ms
				NicamErrorRate = AtvGetNicamErrorRate(1);

				if (NicamErrorRate <= 0x300) {
					msd_result.hw_detected_std = ATV_SOUND_STD_NICAM_DK;
					alog_info("low thd ok %x %x  \n", i, NicamErrorRate);
					break;
				} else {
					alog_info("low thd %x %x  \n", i, NicamErrorRate);
				}

			}
		}
		
	} else {

		msd_crtl_word.regValue = AIO_ReadRegister(AUDIO_msd_crtl_word_reg);
#ifdef TV001_BOARD
if(g_user_config == AUDIO_USER_CONFIG_TV001){
		msd_crtl_word.msd_debounce_cnt = 0;
}
else{ //#else
		msd_crtl_word.msd_debounce_cnt = 1; //Owen 20160913, fix sometimes HW dectect is too late to update std whecn atv scan
}
#endif
		AIO_WriteRegister(AUDIO_msd_crtl_word_reg, msd_crtl_word.regValue);

		AtvSetHwDetecteMode(ATV_HW_CARRIER_SHIFT_BANDWIDTH);

		AtvAdjuseMainCarrierThreshold(g_AudioTVNormalMainToneThredhold_High, g_AudioTVNormalMainToneThredhold_Low);
		msd_result.hw_detected_std = AtvHwDetectResult(2, 0); // get deviation value

#if 0
		if ((msd_result.hw_detected_std == 0x7) ||
		    (msd_result.hw_detected_std == 0x4)) {
			while(1)
				audio_hw_usleep(500000);	// 500 ms
		}
#endif
	}

	//gettimeofday(&timeval4, NULL);

	// Nicam  high deviation detect , old
	if (AtvIsMonoSystem(msd_result.hw_detected_std)
#ifdef NO_USE_HIGHBW
	    && (AtvIsUnNormalSignal(g_Std_msd_status.regValue) == 1)
#endif
	   ) {
		alog_info("over mode  %x \n", g_Std_msd_status.regValue);
#ifndef NO_USE_HIGHBW
		// high BW threshold
		bw_threshold.bw_dev_thresh_hd = g_AudioTVHighBWThredhold;
		bw_threshold.bw_dev_thresh = g_AudioTVHighBWThredhold;
		AIO_WriteRegister(AUDIO_bw_threshold_reg, bw_threshold.regValue);
#endif
		AtvSetHwDetecteMode(ATV_HW_CARRIER_NO_SHIFT_NO_BANDWIDTH);
		AtvCleanOldStd();

#ifndef NO_USE_HIGHBW
		AtvSetHwDetecteMode(ATV_HW_CARRIER_SHIFT_BANDWIDTH);
#endif
		//	CleanOldStd();
		if (lowthreadflag == 1 && ((g_AudioTVControlFlag&ENABLE_MAINTONE_THRESHOLD_ADJUST) == ENABLE_MAINTONE_THRESHOLD_ADJUST))
			AtvAdjuseMainCarrierThreshold(g_AudioTVLOWTHDMainToneThredhold_High, g_AudioTVLOWTHDNormalMainToneThredhold_Low);
		else
			AtvAdjuseMainCarrierThreshold(g_AudioTVNormalMainToneThredhold_High, g_AudioTVNormalMainToneThredhold_Low);

		msd_result2.hw_detected_std = AtvHwDetectResult(4, 0);


		AtvGetFreqPos(msd_result.hw_detected_std, &mainFreqPos, NULL);
		AtvGetFreqPos(msd_result2.hw_detected_std, &mainFreqPos2, NULL);

		/*
		    if(lowthreadflag == 1 && ((g_AudioTVControlFlag & ENABLE_MAINTONE_THRESHOLD_ADJUST) == ENABLE_MAINTONE_THRESHOLD_ADJUST))
		    {
			if(mainFreqPos != mainFreqPos2) // error std2
			msd_result2.hw_detected_std = msd_result.hw_detected_std;
		    }
		*/

		if ((msd_result2.hw_detected_std != ((unsigned int)ATV_SOUND_STD_UNKNOWN))
#ifndef NO_USE_HIGHBW
		    && (AtvIsNicamSystem((ATV_SOUND_STD)msd_result2.hw_detected_std) == 1)
#endif
		   ) {
			msd_result.hw_detected_std = msd_result2.hw_detected_std;
		}
	}

	if (p_sound_std != NULL)
		*p_sound_std = (ATV_SOUND_STD)msd_result.hw_detected_std;

	a = 0;

#if 0
	AtvPrintScanTime(&timeval1, &timeval2, 12);
	AtvPrintScanTime(&timeval2, &timeval3, 23);
	AtvPrintScanTime(&timeval3, &timeval4, 34);
	AtvPrintScanTime(&timeval4, &timeval5, 45);
#endif

	return ATV_OK;

}

// Clayton 2014/1/3
// Add new API for RF radio auto scan
// Audio tone is always fixed at 4.5MHz
int32_t Audio_AtvScanSoundStd_FMRadio(ATV_SOUND_STD *p_sound_std, ATV_Carrier_INFO *p_ATV_Carrier_INFO)
{
	uint32_t toneenergy[4], lowthreadflag;
	uint32_t maxid, maxengery, i, secondenergy;
	//uint32_t mainFreqPos, mainFreqPos2;
	uint32_t a;
	uint8_t ATV_Carrier_shift_value, ATV_Carrier_deviation;

	audio_msd_crtl_word_RBUS msd_crtl_word;
	audio_msd_result_RBUS msd_result;
	//audio_msd_result_RBUS msd_result2;
	//audio_msd_second_reg_std_RBUS msd_second_reg_std;
	audio_msd_status_RBUS msd_status;

	audio_bw_threshold_RBUS bw_threshold;

	//USER:Peter_Lin DATE:2011/04/18
	// fix HXXX COMPANY maintone too low

	//uint32_t NicamErrorRate;
	//struct timeval timeval1, timeval2, timeval3, timeval4, timeval5;

	//gettimeofday(&timeval1, NULL);

	audio_msd_mag_4_5_RBUS amsd_mag_4_5_RBUS;
	audio_msd_mag_5_5_RBUS amsd_mag_5_5_RBUS;
	audio_msd_mag_6_RBUS amsd_mag_6_RBUS;
	audio_msd_carrier_6_5_RBUS amsd_carrier_6_5_RBUS;

	// Set FM Radio flag
	#if 0
	g_FMRadioscanFlag = 1;
	#endif

	if (ATV_GetFmRadioMode() != AUDIO_ATV_FM_RADIO_SCAN)
	{
		*p_sound_std = ATV_SOUND_STD_UNKNOWN;
		memset(p_ATV_Carrier_INFO, 0, sizeof(ATV_Carrier_INFO));
		return -1;
	}
	// disable now
	msd_crtl_word.regValue = AIO_ReadRegister(AUDIO_msd_crtl_word_reg);
	msd_crtl_word.fw_scan_freq = ATV_FW_SCAN_HW_ONLY;    // Clayton, 2013/1/11

	msd_crtl_word.msd_en = FALSE;
	msd_crtl_word.update_en = FALSE; // on interrupt
	msd_crtl_word.carrier_shift_scan_en = FALSE;  // old function
	AIO_WriteRegister(AUDIO_msd_crtl_word_reg, msd_crtl_word.regValue);

	AtvSetFwCarrierFreq(ATV_DISABLE, 0, 0, 0);

	// disable all interrupt
	AtvEnableTvInterrupt(ATV_DISABLE);

	//	audio_enable_hw_update_std_result(AUD_DISABLE); // default is disable

	// normal detect
	AtvSetHwDetecteMode(ATV_HW_DISABLE);

	msd_result.hw_detected_std = ATV_SOUND_STD_UNKNOWN;

	// shift case
	AtvSetHwDetecteMode(ATV_HW_CARRIER_NO_SHIFT_NO_BANDWIDTH);
	AtvCleanOldStd(); //

	//gettimeofday(&timeval2, NULL);

	bw_threshold.bw_dev_thresh_hd = g_AudioTVNormalBWThredhold; // default //Clayton: Need to fix me
	bw_threshold.bw_dev_thresh = g_AudioTVNormalBWThredhold;    //Clayton: Need to fix me
	AIO_WriteRegister(AUDIO_bw_threshold_reg, bw_threshold.regValue);

	amsd_mag_4_5_RBUS.regValue = AIO_ReadRegister(AUDIO_msd_mag_4_5_reg);
	toneenergy[0] = amsd_mag_4_5_RBUS.reg_mag_4_5;

	amsd_mag_5_5_RBUS.regValue = AIO_ReadRegister(AUDIO_msd_mag_5_5_reg);
	toneenergy[1] = amsd_mag_5_5_RBUS.reg_mag_5_5;

	amsd_mag_6_RBUS.regValue = AIO_ReadRegister(AUDIO_msd_mag_6_reg);
	toneenergy[2] = amsd_mag_6_RBUS.reg_mag_6;

	amsd_carrier_6_5_RBUS.regValue = AIO_ReadRegister(AUDIO_msd_carrier_6_5_reg);

	toneenergy[3] = amsd_carrier_6_5_RBUS.reg_mag_6_5;

	maxid = 0;
	maxengery = 0;
	secondenergy = 0;
	lowthreadflag = 0;

	for (i = 0; i < 4; i++) {
		if (toneenergy[i] >= maxengery) {
			secondenergy = maxengery;
			maxid = i;
			maxengery = toneenergy[i];
		} else if (toneenergy[i] >= secondenergy) {
			secondenergy = toneenergy[i];
		}

		alog_info("FM Radio tone energy  %x  \n", toneenergy[i]);
	}

	//gettimeofday(&timeval3, NULL);

	msd_crtl_word.regValue = AIO_ReadRegister(AUDIO_msd_crtl_word_reg);
	msd_crtl_word.msd_debounce_cnt = g_FMRadio_para.ATV_STD_FMRadio_MSD_DEBOUNCE;
	//msd_crtl_word.calc_time_sel = 1;	// choose 3ms update per energy point for speed up
	AIO_WriteRegister(AUDIO_msd_crtl_word_reg, msd_crtl_word.regValue);

	AtvSetHwDetecteMode(ATV_HW_MONO_ONLY);  // Clayton 2014/1/7, ONLY for FM Radio

	// Clayton 2014/1/3
	// Special for FM Radio
	AtvAdjuseMainCarrierThreshold(g_FMRadio_para.ATV_STD_FMRadio_THRESHOLD_HIGH, g_FMRadio_para.ATV_STD_FMRadio_THRESHOLD_LOW);
	msd_result.hw_detected_std = AtvHwDetectResult_FMRadio(2, 0); // get deviation value

	//gettimeofday(&timeval4, NULL);
	//gettimeofday(&timeval5, NULL);

	// Clyaton 2014/1/3
	// ONLY for FM Radio
	// [Start]
	//Rt_Sleep(50);	// delay 50msec after final STD is detected
	msd_status.regValue = AIO_ReadRegister(AUDIO_msd_status_reg);
	ATV_Carrier_shift_value = msd_status.shift_value;
	ATV_Carrier_deviation = msd_status.deviation;

	// constrain1: STD should only be MN MONO or BTSC
	// constrain2: shift value should smaller than +/-200kHz
	//if ((msd_result.hw_detected_std > ATV_SOUND_STD_BTSC) || (ATV_Carrier_shift_value > ATV_CARRIER_SHIFT_VALUE_PLUS_200K)) // Audio Tone is unlocked with carrier shift
	if (msd_result.hw_detected_std > ATV_SOUND_STD_BTSC) { //625
		alog_info("[ATV][Audio]FM Radio unlocked, hw_detected_std = 0x%x ; Carrier shift = %d ; Carrier deviation = %d \n", msd_result.hw_detected_std, msd_status.shift_value, msd_status.deviation);
		msd_result.hw_detected_std = ATV_SOUND_STD_UNKNOWN;
	} else { //6550
		alog_info("[ATV][Audio]FM Radio locked, hw_detected_std = 0x%x ; Carrier shift = %d ; Carrier deviation = %d \n", msd_result.hw_detected_std, msd_status.shift_value, msd_status.deviation);
	}

	p_ATV_Carrier_INFO->Carrier_shif_value = msd_status.shift_value;
	p_ATV_Carrier_INFO->Carrier_deviation = msd_status.deviation;
	// [End]
	if (p_sound_std != NULL)
		*p_sound_std = (ATV_SOUND_STD)msd_result.hw_detected_std;

	a = 0;

#if 0
	AtvPrintScanTime(&timeval1, &timeval2, 12);
	AtvPrintScanTime(&timeval2, &timeval3, 23);
	AtvPrintScanTime(&timeval3, &timeval4, 34);
	AtvPrintScanTime(&timeval4, &timeval5, 45);
#endif

	// Clyaton 2014/1/3
	// ONLY for FM Radio
	// Disable MONO only detection & shif/deviation detection before exit FM Radio auto scan
	AtvSetHwDetecteMode(ATV_HW_CARRIER_NO_SHIFT_NO_BANDWIDTH);
	#if 0
	g_FMRadioscanFlag = 0; // Jump out FM Radio auto scan
	#else
	Audio_Hw_SetFmRadioMode(AUDIO_ATV_FM_RADIO_STOP);
	#endif

	return ATV_OK;
}

void Atv_FMRadio_SetPara(ATV_FIELD_AREA area)
{
	switch (area) {
	case ATV_AREA_GEN: //general area
	case ATV_AREA_IND:
		memcpy((void *)&g_FMRadio_para, (void *)&fm_radio_parameter_gen, sizeof(FM_RADIO_PARA));
		alog_info("FMRadio in GEN\n");
		break;
	case ATV_AREA_RMD:
		memcpy((void *)&g_FMRadio_para, (void *)&fm_radio_parameter_rmd, sizeof(FM_RADIO_PARA));
		alog_info("FMRadio in RMD\n");
		break;
	default:
		alog_info("[%s]FMRadio para error %d\n", __FUNCTION__, (int32_t)area);
		break;

	}
}

void Audio_AtvSetArea(ATV_FIELD_AREA area)
{
	Atv_FMRadio_SetPara(area);
}

ATV_TASK_STATUS AtvGetCurrState(void)
{
	return TV_CurrentWorkState;
}

ATV_TASK_STATUS AtvRestoreState(void)
{
	ATV_TASK_STATUS state;

	if (down_interruptible(&audio_sem_atv)) {
		alog_warning("interrupted, no semaphore held\n");
		return TV_CurrentWorkState;
	}

	state = TV_OldWorkState;
	if (TV_CurrentWorkState != state) {
		TV_OldWorkState = TV_CurrentWorkState;
		TV_CurrentWorkState = state;
		TV_ChangeStateFlag = true;
		alog_debug("change atv task state %d -> %d\n",
			  TV_OldWorkState,
			  TV_CurrentWorkState);
	}

	up(&audio_sem_atv);
	return TV_CurrentWorkState;
}

ATV_TASK_STATUS AtvUpdateState(const ATV_TASK_STATUS state)
{
	if (down_interruptible(&audio_sem_atv)) {
		alog_warning("interrupted, no semaphore held\n");
		return TV_CurrentWorkState;
	}

	if (TV_CurrentWorkState != state) {
		TV_OldWorkState = TV_CurrentWorkState;
		TV_CurrentWorkState = state;
		TV_ChangeStateFlag = true;
		alog_debug("change atv task state %d -> %d\n",
			  TV_OldWorkState,
			  TV_CurrentWorkState);
	}

	up(&audio_sem_atv);
	return TV_CurrentWorkState;
}

void Audio_AtvSetDataSrc(ATV_DATA_SRC para)
{
	Audio_HwpSetSIFDataSource((SIF_INPUT_SOURCE)para);
}

int32_t Audio_AtvGetMNStatus(int32_t *p_status, int32_t *p_energy)
{
	int32_t retry;
	audio_msd_mag_4_5_RBUS	MSD_MAG_4P5_REG;
	audio_msd_flags_RBUS		MSD_FLAG_REG;

	for (retry = 0; retry < 10; retry++) {
		audio_hw_usleep(50000);  // 50ms
		MSD_MAG_4P5_REG.regValue = AIO_ReadRegister(AUDIO_msd_mag_4_5_reg);
		*p_energy = MSD_MAG_4P5_REG.reg_mag_4_5;
		MSD_FLAG_REG.regValue = AIO_ReadRegister(AUDIO_msd_flags_reg);
		*p_status = MSD_FLAG_REG.flag_4_5;
		if (*p_status == 1)
			break;
		;
	}

	return ATV_OK;
}

int32_t Audio_HwpAADSIFInit(ATV_CFG *p_cfg)
{
	#ifdef TV001_BOARD
	Audio_AioSemInit();
	Audio_AppInit();
	#endif
	Audio_AtvInit(p_cfg);

	return ATV_OK;
}

int32_t Audio_AtvInit(ATV_CFG *p_cfg)
{
	//int32_t	res, res_atv, res_sif;
	//audio_msd_result_RBUS MSD_RESULT_REG;
	audio_nicam_demod_auto_recovery_RBUS nicam_demod_auto_recovery;
	audio_nicam_decode_ctrl_RBUS nicam_decode_ctrl;
	audio_sif_agc2_ctrl_RBUS asif_agc2_ctrl;
	audio_sif_agc_threshold_RBUS asif_agc_threshold;
	audio_a2_eiaj_demod_RBUS a2_eiaj_demod;
	audio_btsc_pilot_thres_RBUS abtsc_pilot_thres_RBUS;
	audio_btsc_sap_thresh_RBUS abtsc_sap_thresh_RBUS;
	audio_btsc_sap_noise_th_RBUS abtsc_sap_noise_th_RBUS;
	audio_btsc_sap_debounce_RBUS btsc_sap_debounce;
	audio_btsc_pilot_status_RBUS btsc_pilot_status;
	audio_phase_error_pi_gain_RBUS phase_error_pi_gain;
	audio_analog_pga_RBUS analog_pga;
	audio_eq_tvd_bp_control_RBUS eq_tvd_bp_control;
	audio_tvdemod_digital_volume_control_RBUS tvdemod_digital_volume_control;
	audio_sif_agc3_ctrl_RBUS sif_ac3_ctrl;
	ATV_CFG null_cfg = {0};

	// output_bpf_input_div2 = input divide by 2
	sif_ac3_ctrl.regValue = AIO_ReadRegister(AUDIO_sif_agc3_ctrl_reg);
	sif_ac3_ctrl.output_bpf_input_div2 = 1;
	AIO_WriteRegister(AUDIO_sif_agc3_ctrl_reg, sif_ac3_ctrl.regValue);
	// PGA mini gain = -4.5dB
	analog_pga.regValue = AIO_ReadRegister(AUDIO_analog_pga_reg);
	analog_pga.option_gain = AIO_DISABLE;
	AIO_WriteRegister(AUDIO_analog_pga_reg, analog_pga.regValue);
	// Enable SIF DVC
	tvdemod_digital_volume_control.regValue = AIO_ReadRegister(AUDIO_TVdemod_Digital_Volume_Control_reg);
	tvdemod_digital_volume_control.dvol_enable_tvd = AIO_ENABLE;
	tvdemod_digital_volume_control.mode_sel_tvd = 0; // manual mode
	AIO_WriteRegister(AUDIO_TVdemod_Digital_Volume_Control_reg, tvdemod_digital_volume_control.regValue);
	// Owen 2016.08.17, SIF-EQ has truncation "Chik Chik" sound in Peru field stream BTSC SAP, change back to use HW-EQ
	// Disable SIF EQ
	eq_tvd_bp_control.regValue = AIO_ReadRegister(AUDIO_EQ_tvd_bp_Control_reg);
	eq_tvd_bp_control.eq_tvd_deq_enable = AIO_DISABLE;
	AIO_WriteRegister(AUDIO_EQ_tvd_bp_Control_reg, eq_tvd_bp_control.regValue);

	//if p_cfg = null_cfg, using default table.
	if(memcmp(&null_cfg, p_cfg, sizeof(ATV_CFG)) == 0)
		p_cfg = &m_atv_cfg_default;

	atv_flag = 0;   // default disable all flags
	
	alog_info("init atv driver -- start ----\n");
#if defined(ENABLE_AUDIO_ATV_BTSC_ONLY)
	atv_flag &= ~ATV_INIT_SUPPORT_STD_MASK;
	atv_flag |= ATV_INIT_SUPPORT_STD_BTSC;
	alog_debug("Support BTSC Only\n");
#else
	atv_flag &= ~ATV_INIT_SUPPORT_STD_MASK;
	atv_flag |= ATV_INIT_SUPPORT_STD_ALL;
	alog_debug("Support All Standards\n");
#endif

#if defined(ENABLE_AUDIO_ATV_BTSC_LANGUANGE_SELECT)
	atv_flag |= ATV_INIT_BTSC_LANG_SELECT;
	alog_debug("Support BTSC Language Select\n");
#endif

#if defined(ENABLE_AUDIO_ATV_SOUND_MODE_AUTO_DETECT)
	atv_flag |= ATV_INIT_SOUND_MODE_AUTO_DETECT;
	alog_debug("Support Sound Mode Auto Detect\n");
#endif

	//	if(atv_flag & ATV_INIT_SUPPORT_STD_A2M)
	{
		atv_flag &= ~ATV_INIT_DEV_M_MASK;

		//#if defined(ENABLE_AUDIO_ATV_DEV_MODE_M_HIGH)
		atv_flag &= ~ATV_INIT_DEV_M_MASK;
		atv_flag |= ATV_INIT_DEV_M_HIGH;
		alog_debug("Support A2M DEV_MODE:High\n");
		//#endif

		/*
		#if defined(ENABLE_AUDIO_ATV_DEV_MODE_M_SUPER)
		    atv_flag &= ~ATV_INIT_DEV_M_MASK;
		    atv_flag |= ATV_INIT_DEV_M_SUPER;
		    alog_info("Support A2M DEV_MODE:Super\n");
		#endif
		#if defined(ENABLE_AUDIO_ATV_DEV_MODE_M_ULTRA)
		    atv_flag &= ~ATV_INIT_DEV_M_MASK;
		    atv_flag |= ATV_INIT_DEV_M_ULTRA;
		    alog_info("Support A2M DEV_MODE:Ultra\n");
		#endif
		*/
	}

	//	if( (atv_flag & ATV_INIT_SUPPORT_STD_BG) ||
	//		(atv_flag & ATV_INIT_SUPPORT_STD_DK) ||
	//		(atv_flag & ATV_INIT_SUPPORT_STD_I)	)
	{

		atv_flag &= ~ATV_INIT_DEV_BGDKI_MASK;
		atv_flag &= ~ATV_INIT_DEV_BGDKI_MASK;
		atv_flag |= ATV_INIT_DEV_BGDKI_HIGH;
		alog_debug("Support BG/DK/I DEV_MODE:High\n");

		/*
		#if defined(ENABLE_AUDIO_ATV_DEV_MODE_BGDKI_SUPER)
		    atv_flag &= ~ATV_INIT_DEV_BGDKI_MASK;
		    atv_flag |= ATV_INIT_DEV_BGDKI_SUPER;
		    alog_info("Support BG/DK/I DEV_MODE:Super\n");
		#endif
		#if defined(ENABLE_AUDIO_ATV_DEV_MODE_BGDKI_ULTRA)
		    atv_flag &= ~ATV_INIT_DEV_BGDKI_MASK;
		    atv_flag |= ATV_INIT_DEV_BGDKI_ULTRA;
		    alog_info("Support BG/DK/I DEV_MODE:Ultra\n");
		#endif
		*/
	}

	{
		atv_flag &= ~ATV_INIT_DEV_NICAM_BGDKI_MASK;
		/*
	    #if defined(ENABLE_AUDIO_ATV_DEV_NICAM_BGDKI_HIGH)
		    atv_flag &= ~ATV_INIT_DEV_NICAM_BGDKI_MASK;
		    atv_flag |= ATV_INIT_DEV_NICAM_BGDKI_HIGH;
		    alog_info("Support BG/DK/I NICAM DEV_MODE:High\n");
	    #endif
	    #if defined(ENABLE_AUDIO_ATV_DEV_NICAM_BGDKI_SUPER)
		    atv_flag &= ~ATV_INIT_DEV_NICAM_BGDKI_MASK;
		    atv_flag |= ATV_INIT_DEV_NICAM_BGDKI_SUPER;
		    alog_info("Support BG/DK/I NICAM DEV_MODE:Super\n");
	    #endif
	    #if defined(ENABLE_AUDIO_ATV_DEV_NICAM_BGDKI_ULTRA)
		    atv_flag &= ~ATV_INIT_DEV_NICAM_BGDKI_MASK;
		    atv_flag |= ATV_INIT_DEV_NICAM_BGDKI_ULTRA;
		    alog_info("Support BG/DK/I NICAM DEV_MODE:Ultra\n");
	    #endif
	    */
	}

#ifdef ENABLE_AUDIO_ATV_FREQ_SHIFT_500K_DETECT
	atv_flag &= ~ATV_INIT_FREQ_SHIFT_MASK;
	atv_flag |= ATV_INIT_FREQ_SHIFT_500K;
	alog_debug("Support freq. shift up to 500K\n");
#endif

#ifdef ENABLE_AUDIO_ATV_HDEV_MODE_CARRIER_DETECT
	atv_flag |= ATV_INIT_HDEV_CARRIER_DETECT;
	alog_debug("Support HDEV carrier detect\n");
#endif

	if (p_cfg != NULL) {
		memcpy((void *)&atv_cfg, (void *)p_cfg, sizeof(ATV_CFG));
		alog_debug("init. global constants\n");
		alog_debug("m_vol_comp_btsc_sap    =0x%08x\n", atv_cfg.m_vol_comp_btsc_sap);
		alog_debug("m_vol_comp_btsc_stereo =0x%08x\n", atv_cfg.m_vol_comp_btsc_stereo);
		alog_debug("m_vol_comp_btsc_mono   =0x%08x\n", atv_cfg.m_vol_comp_btsc_mono);

		alog_debug("btsc_pilot_threshold_high =0x%08x\n", atv_cfg.m_btsc_pilot_threshold_high);
		alog_debug("btsc_pilot_threshold_low  =0x%08x\n", atv_cfg.m_btsc_pilot_threshold_low);
		alog_debug("btsc_sap_threshold_high   =0x%08x\n", atv_cfg.m_btsc_sap_threshold_high);
		alog_debug("btsc_sap_threshold_low    =0x%08x\n", atv_cfg.m_btsc_sap_threshold_low);
		alog_debug("btsc_sap_noise_threshold_high =0x%08x\n", atv_cfg.m_btsc_sap_noise_threshold_high);
		alog_debug("btsc_sap_noise_threshold_low  =0x%08x\n", atv_cfg.m_btsc_sap_noise_threshold_low);

		alog_debug("m_vol_comp_mn_dual   =0x%08x\n", atv_cfg.m_vol_comp_mn_dual);
		alog_debug("m_vol_comp_mn_stereo =0x%08x\n", atv_cfg.m_vol_comp_mn_stereo);
		alog_debug("m_vol_comp_mn_mono   =0x%08x\n", atv_cfg.m_vol_comp_mn_mono);
	}

	// A2-related
	if (A2_Th_Table == NULL)
		A2_Th_Table = A2_Th_MN_Table; //default use MN system

	// BTSC-related
	abtsc_pilot_thres_RBUS.regValue = AIO_ReadRegister(AUDIO_btsc_pilot_thres_reg);
	abtsc_pilot_thres_RBUS.pilot_hithresh = (atv_cfg.m_btsc_pilot_threshold_high);
	abtsc_pilot_thres_RBUS.pilot_lothresh = (atv_cfg.m_btsc_pilot_threshold_low);
	abtsc_pilot_thres_RBUS.bypass_com_bpf = 1;  // For LG BTSC Stereo separation
	abtsc_pilot_thres_RBUS.bypass_com_hpf = 0;  // For Peru filed issue
	AIO_WriteRegister(AUDIO_btsc_pilot_thres_reg, abtsc_pilot_thres_RBUS.regValue);

	abtsc_sap_thresh_RBUS.regValue = AIO_ReadRegister(AUDIO_btsc_sap_thresh_reg);
	abtsc_sap_thresh_RBUS.sap_hithresh = atv_cfg.m_btsc_sap_threshold_high;
	abtsc_sap_thresh_RBUS.sap_lothresh = atv_cfg.m_btsc_sap_threshold_low;
	AIO_WriteRegister(AUDIO_btsc_sap_thresh_reg, abtsc_sap_thresh_RBUS.regValue);

	abtsc_sap_noise_th_RBUS.regValue = AIO_ReadRegister(AUDIO_btsc_sap_noise_th_reg);
	abtsc_sap_noise_th_RBUS.sap_noise_hi_thresh = atv_cfg.m_btsc_sap_noise_threshold_high;
	abtsc_sap_noise_th_RBUS.sap_noise_lo_thresh = atv_cfg.m_btsc_sap_noise_threshold_low;
	AIO_WriteRegister(AUDIO_btsc_sap_noise_th_reg, abtsc_sap_noise_th_RBUS.regValue);

	// For LG BTSC Stereo separation
	
	btsc_pilot_status.regValue = AIO_ReadRegister(AUDIO_btsc_pilot_status_reg);
	btsc_pilot_status.out_hpf_en = 1;
	AIO_WriteRegister(AUDIO_btsc_pilot_status_reg, btsc_pilot_status.regValue);

	phase_error_pi_gain.regValue = AIO_ReadRegister(AUDIO_phase_error_pi_gain_reg);
	phase_error_pi_gain.locked_i_gain = 0xa;
	phase_error_pi_gain.locked_p_gain = 0xa;
	phase_error_pi_gain.unlock_i_gain = 0xa;
	phase_error_pi_gain.unlock_p_gain = 0xa;
	AIO_WriteRegister(AUDIO_phase_error_pi_gain_reg, phase_error_pi_gain.regValue);

	AtvSetSoundStd(ATV_SOUND_STD_UNKNOWN);

	nicam_demod_auto_recovery.regValue = AIO_ReadRegister(AUDIO_nicam_demod_auto_recovery_reg);
	nicam_demod_auto_recovery.enable = 1; //enable  auto recovery , no lock cr  , force to reset
	AIO_WriteRegister(AUDIO_nicam_demod_auto_recovery_reg, nicam_demod_auto_recovery.regValue);

	// Clayton 2012/12/13
	// Fix TSB E50-related NICAM CIB nonstardard issue

	nicam_decode_ctrl.regValue = AIO_ReadRegister(AUDIO_nicam_decode_ctrl_reg);
	nicam_decode_ctrl.cib_mask = 1;
	nicam_decode_ctrl.bypass_interpol = 0;  // Clayton 2014/6/12 Interpolation when bit error sample to improve NICAM sound
	AIO_WriteRegister(AUDIO_nicam_decode_ctrl_reg, nicam_decode_ctrl.regValue);

	btsc_sap_debounce.regValue = AIO_ReadRegister(AUDIO_btsc_sap_debounce_reg);
	btsc_sap_debounce.sap_debounce_en = 0; // sw debounce
	AIO_WriteRegister(AUDIO_btsc_sap_debounce_reg, btsc_sap_debounce.regValue);

	// DAGC2 ,
	// fix DK can decode I

	asif_agc2_ctrl.regValue = AIO_ReadRegister(AUDIO_sif_agc2_ctrl_reg);
	asif_agc2_ctrl.agc2_gain_a = 0;
	asif_agc2_ctrl.agc2_gain_b = 0;
	AIO_WriteRegister(AUDIO_sif_agc2_ctrl_reg, asif_agc2_ctrl.regValue);

#ifdef USE_PACFIC_STYLE
	if (IS_ERR_OR_NULL(audio_atv_thread)) {
		AtvThreadState = false;
		audio_atv_thread = kthread_run(AtvThread, NULL, "AtvThread%d", 0);
		if (IS_ERR(audio_atv_thread))
			alog_err("audio_atv_thread creation failed\n");
		else
			alog_info("audio_atv_thread creation ok\n");
		}
#endif

	// ryanliao 20161123
	// K3L set agc_threshold -2dB for auto gain control
	asif_agc_threshold.regValue = AIO_ReadRegister(AUDIO_sif_agc_threshold_reg);
	asif_agc_threshold.ovf_th = 0x32d;
	AIO_WriteRegister(AUDIO_sif_agc_threshold_reg, asif_agc_threshold.regValue);

	AtvSetHwAGC(ATV_ENABLE, 0, 0);

	// enable normalize
	a2_eiaj_demod.regValue = AIO_ReadRegister(AUDIO_a2_eiaj_demod_reg);
	// Clayton 2013/11/28
	// Due to most project, it had better roll back to original setting
	// Keep a2_eiaj_demod.hdv_compen_en = 1 (HW default)
	// [Start]
	a2_eiaj_demod.hdv_compen_en = 1;
	// [End]
	AIO_WriteRegister(AUDIO_a2_eiaj_demod_reg, a2_eiaj_demod.regValue);

	// testing only
	//Audio_AtvSetBtscMtsVolume(APP_VOL_0DB, APP_VOL_STEP_1DB*2, APP_VOL_STEP_1DB*9);
	//alog_info(" TVControlFlag ad 0x%x  PrintFlag ad 0x%x  \n", (uint32_t)&g_AudioTVControlFlag , (uint32_t)&g_AudioTVPrintFlag);
	//
	//USER:Peter_Lin DATE:2010/12/10
	// wait ifd to finish init
	
	g_WaitIFDInitFinish = WAIT_IFD_INIT;
	g_KR_A2_TH_CHG = 0;
	
	g_ap_mute_pb_cnt = USR_MUTE_NUM;
	g_ap_mute_ts_cnt = USR_MUTE_NUM;
	g_HighDevOnOff = false;

	if(g_user_config != AUDIO_USER_CONFIG_TV001)
	{
		g_Atvpath_PB = 1;
		g_Atvpath_TS = 1;
		alog_debug("atv path init %x %x\n", g_Atvpath_PB, g_Atvpath_TS);
	}

	alog_info("init atv driver -- end ------\n");

	return ATV_OK;

}

/**
 * DeInit. LasVegas ATV Audio
 *
 * @return				{ ATV_OK or AIO_ERROR_CODE }
 * @ingroup lib_audio
 */
int32_t Audio_AtvDeInit(void)
{
	int32_t res;

	alog_info("go into ATV DeInit\n");

#ifdef USE_PACFIC_STYLE
	if (!IS_ERR(audio_atv_thread)) {
		res = kthread_stop(audio_atv_thread);
		if (res) {
			alog_info("audio_atv_thread cancellation failed %d\n", res);
			audio_atv_thread = NULL;
		} else {
			alog_info("audio_atv_thread cancellation ok\n");
			audio_atv_thread = NULL;
		}
	}
#endif

	return ATV_OK;
}

int32_t Audio_HwpAADSIFFinalize(void)
{
	Audio_AioSemDeInit();
	Audio_AppSemDeInit();
	return Audio_AtvDeInit();
}

/**
 * turn on/off AGC
 *
 * @param 	<para>	{ ATV_ENABLE/ATV_DISABLE }
 * @return			{ void }
 * @ingroup drv_aio
 */
static void AtvSetHwAGC(int32_t para, uint32_t fix_gain, uint32_t afe_pga_vol)
{
	audio_sif_agc_eval_cnt_RBUS AGC_EVAL_REG;
	audio_analog_pga_RBUS analog_pga;

	if (para == AIO_ENABLE) {
		// auto mode
		AGC_EVAL_REG.regValue = AIO_ReadRegister(AUDIO_sif_agc_eval_cnt_reg);
		AGC_EVAL_REG.hw_agc_en = para;
		AIO_WriteRegister(AUDIO_sif_agc_eval_cnt_reg, AGC_EVAL_REG.regValue);
	} else {
		// manual mode
		AGC_EVAL_REG.regValue = AIO_ReadRegister(AUDIO_sif_agc_eval_cnt_reg);
		AGC_EVAL_REG.hw_agc_en = para;
		AIO_WriteRegister(AUDIO_sif_agc_eval_cnt_reg, AGC_EVAL_REG.regValue);
		// set manual gain
		analog_pga.regValue = AIO_ReadRegister(AUDIO_analog_pga_reg);
		analog_pga.fix_gain = fix_gain;
		analog_pga.afe_pga_vol = afe_pga_vol;
		AIO_WriteRegister(AUDIO_analog_pga_reg, analog_pga.regValue);
	}
}

#ifdef USE_PACFIC_STYLE
int AtvThread(void *arg)
{
	uint32_t loop_cnt = 0;
	ATV_TASK_STATUS task_status = ATV_TASK_STOP;
	uint32_t check_cnt = DIV_ROUND_UP(ATV_TICK_PACFIC_TIME,
					  ATV_TICK_THREAD_TIME);

	alog_info("AtvThread ceate...\n");

	(void)arg;  /* suppress compile warning */

	AtvThreadState = true;

	set_freezable();

	do {
		wait_event_freezable_timeout(audio_atv_wait,
					     (TV_ChangeStateFlag ||
					      kthread_should_stop()),
					     usecs_to_jiffies(ATV_TICK_THREAD_TIME));
		
		if (down_interruptible(&audio_sem_atv)) {
			alog_warning("interrupted, no semaphore held\n");
			break;
		}

		if (TV_ChangeStateFlag)
			TV_ChangeStateFlag = false;

		task_status = AtvGetCurrState();
		if (task_status == ATV_TASK_RUN) {
			if ((loop_cnt++ % check_cnt) == 0)
			{
				AtvCheckTask();
				#ifndef RTD289X
				if (isSIFEQOverflow()) {
					CleanSIFEQOverflow();
					alog_info("sif eq of \n");
				}
				#endif
			}
		} else if (task_status == ATV_TASK_PAUSE) {
			/* do nothing */
			//alog_info("atv task pause\n");
		} else if (task_status == ATV_TASK_STOP) {
			/* do nothing */
			//alog_info("atv task stop\n");
		}

		up(&audio_sem_atv);
	} while (!kthread_should_stop());
	
	AtvThreadState = false;

	alog_info("AtvThread exiting\n");

	return 0;
}
#endif /* USE_PACFIC_STYLE */

static void AtvSetPrescaleDeemphasis(uint32_t sound_std)
{
	audio_a2_eiaj_demod_RBUS FM_CTRL_REG;
	audio_am_RBUS AM_CTRL_REG;
	audio_nicam_demod_RBUS NICAM_DEMO_REG;
	//audio_md_status_1_RBUS md_status_1;

	FM_CTRL_REG.regValue = AIO_ReadRegister(AUDIO_a2_eiaj_demod_reg);
	AM_CTRL_REG.regValue = AIO_ReadRegister(AUDIO_am_reg);

	NICAM_DEMO_REG.regValue = AIO_ReadRegister(AUDIO_nicam_demod_reg);
	NICAM_DEMO_REG.psf_sel = ATV_NICAM_BW_250KHZ;

	switch (sound_std) {
	case ATV_SOUND_STD_EIAJ:
		// Clayton 2013/1/28, Remove "eiaj_sub_deviation" related
		
		/*
			if(hdev_mode)
			FM_CTRL_REG.eiaj_sub_deviation = atv_psde_special_tab[sound_std].eiaj_sub;
			else
			FM_CTRL_REG.eiaj_sub_deviation = atv_psde_normal_tab[sound_std].eiaj_sub;
		*/
	case ATV_SOUND_STD_BTSC:
	case ATV_SOUND_STD_MN_MONO:
		if (g_DevBySoundStd == ATV_DEV_CHANGE_BY_SOUND_STD) {
			FM_CTRL_REG.a2_bw_sel = atv_psde_normal_tab[sound_std].a2_bw_sel;
			FM_CTRL_REG.de_emphasis_time = atv_psde_normal_tab[sound_std].de_emphasis;
			FM_CTRL_REG.fm1_deviation_gain = atv_psde_normal_tab[sound_std].fm1_dev_gain;
			FM_CTRL_REG.fm2_deviation_gain = atv_psde_normal_tab[sound_std].fm2_dev_gain;
		} else if (g_DevBySoundStd == ATV_DEV_CHANGE_BY_USER) {
			FM_CTRL_REG.de_emphasis_time = atv_psde_normal_tab[sound_std].de_emphasis;
			FM_CTRL_REG.fm1_deviation_gain = atv_psde_normal_tab[sound_std].fm1_dev_gain;
			FM_CTRL_REG.fm2_deviation_gain = atv_psde_normal_tab[sound_std].fm2_dev_gain;
			FM_CTRL_REG.hdv_compen_en = 1;
		}
		break;

	case ATV_SOUND_STD_A2_M:
		if (g_DevBySoundStd == ATV_DEV_CHANGE_BY_SOUND_STD) {
			FM_CTRL_REG.a2_bw_sel = atv_psde_normal_tab[sound_std].a2_bw_sel;
			FM_CTRL_REG.de_emphasis_time = atv_psde_normal_tab[sound_std].de_emphasis;
			FM_CTRL_REG.fm1_deviation_gain = atv_psde_normal_tab[sound_std].fm1_dev_gain;
			FM_CTRL_REG.fm2_deviation_gain = atv_psde_normal_tab[sound_std].fm2_dev_gain;
		} else if (g_DevBySoundStd == ATV_DEV_CHANGE_BY_USER) {
			FM_CTRL_REG.de_emphasis_time = atv_psde_normal_tab[sound_std].de_emphasis;
			FM_CTRL_REG.a2_sub_bw_sel = ATV_A2_SUB_BW_SEL_70KHZ;
			//A2 new function
			if (g_CurSifType == ATV_AUDIO_SIF_KOREA_A2_SELECT) {
				FM_CTRL_REG.fm1_deviation_gain = atv_psde_normal_tab[sound_std].fm1_dev_gain;
				FM_CTRL_REG.fm2_deviation_gain = atv_psde_normal_tab[sound_std].fm2_dev_gain;
				FM_CTRL_REG.down_6db = 0;
			} else if (g_CurSifType == ATV_AUDIO_SIF_KOREA_A2_SELECT) { //674
				FM_CTRL_REG.fm1_deviation_gain = ATV_FM1_DEVIATION_28KHZ;
				FM_CTRL_REG.fm2_deviation_gain = ATV_FM2_DEVIATION_28KHZ;
				FM_CTRL_REG.down_6db = 1;
			} else { //dk
				FM_CTRL_REG.fm1_deviation_gain = ATV_FM1_DEVIATION_100KHZ;
				FM_CTRL_REG.fm2_deviation_gain = ATV_FM2_DEVIATION_100KHZ;
				FM_CTRL_REG.down_6db = 1;
			}

			FM_CTRL_REG.hdv_compen_en = 1;
			#ifdef TV001_BOARD
			//change outputlevel only for K3L CN model ryanliao 20161103
			if (g_CurSifType == ATV_AUDIO_SIF_DVB_CN_SELECT) {
				g_sif_offset = 48; // SIF gain 6dB
				HwpSetVolume_SIF(g_sif_offset);
			}
			#endif
			
		}
		break;

	case ATV_SOUND_STD_NICAM_I:
	case ATV_SOUND_STD_FM_MONO_NO_I:
		if (sound_std == ATV_SOUND_STD_NICAM_I) {
			NICAM_DEMO_REG.psf_sel = atv_psde_normal_tab[sound_std].nicam_psf;
		}

		if (g_DevBySoundStd == ATV_DEV_CHANGE_BY_SOUND_STD) {
			FM_CTRL_REG.a2_bw_sel = atv_psde_normal_tab[sound_std].a2_bw_sel;
			FM_CTRL_REG.de_emphasis_time = atv_psde_normal_tab[sound_std].de_emphasis;
			FM_CTRL_REG.fm1_deviation_gain = atv_psde_normal_tab[sound_std].fm1_dev_gain;
			FM_CTRL_REG.fm2_deviation_gain = atv_psde_normal_tab[sound_std].fm2_dev_gain;
		} else if (g_DevBySoundStd == ATV_DEV_CHANGE_BY_USER) {
			FM_CTRL_REG.de_emphasis_time = atv_psde_normal_tab[sound_std].de_emphasis;
			FM_CTRL_REG.fm1_deviation_gain = atv_psde_normal_tab[sound_std].fm1_dev_gain;
			FM_CTRL_REG.fm2_deviation_gain = atv_psde_normal_tab[sound_std].fm2_dev_gain;
			FM_CTRL_REG.hdv_compen_en = 1;
		}
		break;

	case ATV_SOUND_STD_NICAM_BG:
	case ATV_SOUND_STD_BG_MONO:
	case ATV_SOUND_STD_A2_BG:
		if (sound_std == ATV_SOUND_STD_NICAM_BG) {
			NICAM_DEMO_REG.psf_sel = atv_psde_normal_tab[sound_std].nicam_psf;
		}

		if (g_DevBySoundStd == ATV_DEV_CHANGE_BY_SOUND_STD) {
			FM_CTRL_REG.a2_bw_sel = atv_psde_normal_tab[sound_std].a2_bw_sel;
			FM_CTRL_REG.de_emphasis_time = atv_psde_normal_tab[sound_std].de_emphasis;
			FM_CTRL_REG.fm1_deviation_gain = atv_psde_normal_tab[sound_std].fm1_dev_gain;
			FM_CTRL_REG.fm2_deviation_gain = atv_psde_normal_tab[sound_std].fm2_dev_gain;
		} else if (g_DevBySoundStd == ATV_DEV_CHANGE_BY_USER) {
			FM_CTRL_REG.de_emphasis_time = atv_psde_normal_tab[sound_std].de_emphasis;
			if (((g_CurSifType == ATV_AUDIO_SIF_DVB_AJJA_SELECT) && g_HighDevOnOff)) {
				FM_CTRL_REG.fm1_deviation_gain = ATV_FM1_DEVIATION_180KHZ;
				FM_CTRL_REG.fm2_deviation_gain = ATV_FM2_DEVIATION_180KHZ;
				FM_CTRL_REG.hdv_compen_en = 0;
				#ifdef TV001_BOARD
				//change outputlevel for K3L AJJA model, and India's THD_N need to similer the Asia model. ryanliao 2017/02/09
				g_sif_offset = -5;
				HwpSetVolume_SIF(g_sif_offset);	// SIF gain -0.625dB
				#endif
			}
			else if(((g_CurSifType == ATV_AUDIO_SIF_DVB_IN_SELECT) && g_HighDevOnOff)) {
				FM_CTRL_REG.fm1_deviation_gain = ATV_FM1_DEVIATION_180KHZ;
				FM_CTRL_REG.fm2_deviation_gain = ATV_FM2_DEVIATION_180KHZ;
				FM_CTRL_REG.hdv_compen_en = 0;
				#ifdef TV001_BOARD
				//change outputlevel for K3L AJJA model, and India's THD_N need to similer the Asia model. ryanliao 2017/02/09
				g_sif_offset = -5; // SIF gain -0.625dB

				//customer TV001 doesn't want to increase +12dB in M/W in India model,
				//so moving compensation gain +12dB to driver side.
				FM_CTRL_REG.down_6db = 0; // +6dB
				g_sif_offset += 48; // SIF gain 6dB
				HwpSetVolume_SIF(g_sif_offset);
				#endif
			} else {
				FM_CTRL_REG.fm1_deviation_gain = atv_psde_normal_tab[sound_std].fm1_dev_gain;
				FM_CTRL_REG.fm2_deviation_gain = atv_psde_normal_tab[sound_std].fm2_dev_gain;
				FM_CTRL_REG.hdv_compen_en = 1;
				//alog_info("DBG.......%d %d\n",g_CurSifType, g_HighDevOnOff);
			}
		}
		break;

	case ATV_SOUND_STD_NICAM_DK:
	case ATV_SOUND_STD_DK_MONO:
	case ATV_SOUND_STD_A2_DK1:
	case ATV_SOUND_STD_A2_DK2:
	case ATV_SOUND_STD_A2_DK3:
		if (sound_std == ATV_SOUND_STD_NICAM_DK) {
			NICAM_DEMO_REG.psf_sel = atv_psde_normal_tab[sound_std].nicam_psf;
		}

		if (g_DevBySoundStd == ATV_DEV_CHANGE_BY_SOUND_STD) {
			FM_CTRL_REG.a2_bw_sel = atv_psde_normal_tab[sound_std].a2_bw_sel;
			FM_CTRL_REG.de_emphasis_time = atv_psde_normal_tab[sound_std].de_emphasis;
			FM_CTRL_REG.fm1_deviation_gain = atv_psde_normal_tab[sound_std].fm1_dev_gain;
			FM_CTRL_REG.fm2_deviation_gain = atv_psde_normal_tab[sound_std].fm2_dev_gain;
		} else if (g_DevBySoundStd == ATV_DEV_CHANGE_BY_USER) {
			FM_CTRL_REG.de_emphasis_time = atv_psde_normal_tab[sound_std].de_emphasis;
			FM_CTRL_REG.fm1_deviation_gain = atv_psde_normal_tab[sound_std].fm1_dev_gain;
			FM_CTRL_REG.fm2_deviation_gain = atv_psde_normal_tab[sound_std].fm2_dev_gain;
			FM_CTRL_REG.hdv_compen_en = 1;
		}
		break;

	case ATV_SOUND_STD_AM_MONO:
	case ATV_SOUND_STD_NICAM_L:
		if (g_DevBySoundStd == ATV_DEV_CHANGE_BY_SOUND_STD) {
			AM_CTRL_REG.hw_am_prescale = atv_psde_normal_tab[sound_std].hw_am_prescale;
			FM_CTRL_REG.hdv_compen_en = 1;
		}
		break;

	default:
		alog_info("[%s] std unknown\n", __FUNCTION__);
		return;
	}

	AIO_WriteRegister(AUDIO_a2_eiaj_demod_reg, FM_CTRL_REG.regValue);
	AIO_WriteRegister(AUDIO_am_reg, AM_CTRL_REG.regValue);
	AIO_WriteRegister(AUDIO_nicam_demod_reg, NICAM_DEMO_REG.regValue);
}

static void AtvSetModeDebounceCoef(uint32_t sound_std)
{
	audio_md_ctrl_RBUS			MD_CTRL_REG;
	audio_md_status_2_RBUS			md_status_2;
	audio_md_status_3_RBUS			md_status_3;
	audio_nicam_decode_ctrl_RBUS	NICAM_DEC_REG;

	//audio_btsc_sap_debounce_RBUS  btsc_sap_debounce;
	if (sound_std != ATV_SOUND_STD_UNKNOWN) {
		switch (sound_std) {
		case ATV_SOUND_STD_NICAM_L:
		case ATV_SOUND_STD_NICAM_DK:
		case ATV_SOUND_STD_NICAM_I:
		case ATV_SOUND_STD_NICAM_BG:
			NICAM_DEC_REG.regValue = AIO_ReadRegister(AUDIO_nicam_decode_ctrl_reg);
			NICAM_DEC_REG.status_debounce_cnt = atv_mode_tab[sound_std].debounce_cnt;
			AIO_WriteRegister(AUDIO_nicam_decode_ctrl_reg, NICAM_DEC_REG.regValue);
			break;
		case ATV_SOUND_STD_EIAJ:
		case ATV_SOUND_STD_A2_M:
		case ATV_SOUND_STD_A2_BG:
		case ATV_SOUND_STD_A2_DK1:
		case ATV_SOUND_STD_A2_DK2:
		case ATV_SOUND_STD_A2_DK3:
			MD_CTRL_REG.regValue = AIO_ReadRegister(AUDIO_md_ctrl_reg);
			md_status_2.regValue = AIO_ReadRegister(AUDIO_md_status_2_reg);
			md_status_3.regValue = AIO_ReadRegister(AUDIO_md_status_3_reg);
			// Clayton 2013/12/17
			// change back to normal sound mode detection setting for stability
			
			md_status_3.debounce_time = atv_mode_tab[sound_std].debounce_cnt;       // A2 HW debounce = 0x2, HW default
			md_status_2.lpf_coef_sel = ATV_LPF_COEF_SEL_14; //ATV_LPF_COEF_SEL_12;		// For generally nomal run case: The stable & slowest parameter of LPF
			md_status_2.lpf_coef_sel_lock = ATV_LPF_COEF_SEL_14; //ATV_LPF_COEF_SEL_12;	// For generally nomal run case: The stable & slowest parameter of LPF
									     
			MD_CTRL_REG.enable = TRUE;
			//MD_CTRL_REG.debounce_cnt = atv_mode_tab[sound_std].debounce_cnt;	// Clayton 2013/1/28
			MD_CTRL_REG.high_threshold = atv_mode_tab[sound_std].hi_threshold;
			MD_CTRL_REG.low_threshold = atv_mode_tab[sound_std].lo_threshold;
			//MD_CTRL_REG.accu_num = atv_mode_tab[sound_std].accu_num;	// Clayton, 2013/1/28, Remove accu_num
			AIO_WriteRegister(AUDIO_md_ctrl_reg, MD_CTRL_REG.regValue);
			AIO_WriteRegister(AUDIO_md_status_2_reg, md_status_2.regValue);
			AIO_WriteRegister(AUDIO_md_status_3_reg, md_status_3.regValue);
			break;
		case ATV_SOUND_STD_BTSC:
			/* configure BTSC debounce in init. reg stage */
			//	btsc_sap_debounce.regValue = AIO_ReadRegister(AUDIO_btsc_sap_debounce_reg);
			//				btsc_sap_debounce.sap_debounce = 0xF;
			//				AIO_WriteRegister(AUDIO_btsc_sap_debounce_reg, btsc_sap_debounce.regValue);
			break;
		case ATV_SOUND_STD_MN_MONO:
		case ATV_SOUND_STD_BG_MONO:
		case ATV_SOUND_STD_DK_MONO:
		case ATV_SOUND_STD_FM_MONO_NO_I:
		case ATV_SOUND_STD_AM_MONO:
		default:
			break;
		}
	}

}
#if 0//ndef TV001_BOARD
//add AtvSetA2ModeDebounceTime function by Wu Yi-Chiao 2013/08/09
static void AtvSetA2ModeDebounceTime(ATV_A2_DEBOUNCE_TIME debounce_time)
{
	audio_md_status_3_RBUS md_status_3_reg;

	md_status_3_reg.regValue = AIO_ReadRegister(AUDIO_md_status_3_reg);
	md_status_3_reg.debounce_time = debounce_time;
	AIO_WriteRegister(AUDIO_md_status_3_reg, md_status_3_reg.regValue);

}
#endif
// Clayton 2013/12/17
// Speed up A2 sound mode detection
// Generally, it only can be used when switch channel.
// After switch channel 1st sound mode out, it has to change back to normal setting
static void AtvSpeedupA2SoundModeDetect(ATV_SOUND_STD sound_std)
{
	audio_md_ctrl_RBUS			MD_CTRL_REG;
	audio_md_status_2_RBUS			md_status_2;
	audio_md_status_3_RBUS			md_status_3;

	MD_CTRL_REG.regValue = AIO_ReadRegister(AUDIO_md_ctrl_reg);
	md_status_2.regValue = AIO_ReadRegister(AUDIO_md_status_2_reg);
	md_status_3.regValue = AIO_ReadRegister(AUDIO_md_status_3_reg);

#if 0
	md_status_3.debounce_time = atv_mode_preset_tab[sound_std].debounce_cnt;  // A2 HW debounce = 0
	MD_CTRL_REG.max_threshold = ATV_MODE_MAX_TH_0;  // Max_TH=0
	md_status_2.lpf_coef_sel = ATV_LPF_COEF_SEL_12;
	md_status_2.lpf_coef_sel_lock= ATV_LPF_COEF_SEL_12;
	MD_CTRL_REG.high_threshold = atv_mode_preset_tab[sound_std].hi_threshold;   // Easily for detecting Stereo/dual
	MD_CTRL_REG.low_threshold = atv_mode_preset_tab[sound_std].lo_threshold;
#else
	if (g_CurrentStd == ATV_SOUND_STD_A2_M && g_CurSifType == ATV_AUDIO_SIF_KOREA_A2_SELECT) {
		md_status_3.debounce_time = A2_Th_Table[g_A2_TH_sel].debounce_time;
		MD_CTRL_REG.max_threshold = A2_Th_Table[g_A2_TH_sel].max_threshold;
		MD_CTRL_REG.high_threshold = A2_Th_Table[g_A2_TH_sel].hi_threshold;
		MD_CTRL_REG.low_threshold = A2_Th_Table[g_A2_TH_sel].lo_threshold;
		md_status_2.lpf_coef_sel = A2_Th_Table[g_A2_TH_sel].lpf_coef_sel;
		md_status_2.lpf_coef_sel_lock = A2_Th_Table[g_A2_TH_sel].lpf_coef_sel_lock;
	} else { // BG
		md_status_3.debounce_time = atv_mode_preset_tab[sound_std].debounce_cnt;  // A2 HW debounce = 0
		MD_CTRL_REG.max_threshold = ATV_MODE_MAX_TH_0;  // Max_TH=0
		md_status_2.lpf_coef_sel = ATV_LPF_COEF_SEL_12;
		md_status_2.lpf_coef_sel_lock = ATV_LPF_COEF_SEL_12;
		MD_CTRL_REG.high_threshold = atv_mode_preset_tab[sound_std].hi_threshold;   // Easily for detecting Stereo/dual
		MD_CTRL_REG.low_threshold = atv_mode_preset_tab[sound_std].lo_threshold;
	}

#endif

	AIO_WriteRegister(AUDIO_md_ctrl_reg, MD_CTRL_REG.regValue);
	AIO_WriteRegister(AUDIO_md_status_2_reg, md_status_2.regValue);
	AIO_WriteRegister(AUDIO_md_status_3_reg, md_status_3.regValue);
}
#if 0//ndef TV001_BOARD
static void AtvNormalA2SoundModeDetect(void)
{
	audio_md_ctrl_RBUS			MD_CTRL_REG;
	audio_md_status_2_RBUS			md_status_2;
	audio_md_status_3_RBUS			md_status_3;

	MD_CTRL_REG.regValue = AIO_ReadRegister(AUDIO_md_ctrl_reg);
	md_status_2.regValue = AIO_ReadRegister(AUDIO_md_status_2_reg);
	md_status_3.regValue = AIO_ReadRegister(AUDIO_md_status_3_reg);
	md_status_3.debounce_time = ATV_A2_DEBOUNCE_1P0S;       // A2 HW debounce = 0x2, HW default
	MD_CTRL_REG.max_threshold = ATV_MODE_MAX_TH_2000;       // Max_TH=0x2000, HW default
	md_status_2.lpf_coef_sel = ATV_LPF_COEF_SEL_14;     // The stable & slowest parameter of LPF
	md_status_2.lpf_coef_sel_lock = ATV_LPF_COEF_SEL_14; // The stable & slowest parameter of LPF
	MD_CTRL_REG.high_threshold = ATV_MODE_HI_TH_2P00T;  // Easily for detecting Stereo/dual
	MD_CTRL_REG.low_threshold = ATV_MODE_LO_TH_1P50T;
	AIO_WriteRegister(AUDIO_md_ctrl_reg, MD_CTRL_REG.regValue);
	AIO_WriteRegister(AUDIO_md_status_2_reg, md_status_2.regValue);
	AIO_WriteRegister(AUDIO_md_status_3_reg, md_status_3.regValue);
}
#endif
void AtvPresetModeDebounceCoef(uint32_t sound_std)
{
	audio_md_ctrl_RBUS			MD_CTRL_REG;
	audio_nicam_decode_ctrl_RBUS	NICAM_DEC_REG;

	if (sound_std != ATV_SOUND_STD_UNKNOWN) {
		switch (sound_std) {
		case ATV_SOUND_STD_NICAM_L:
		case ATV_SOUND_STD_NICAM_DK:
		case ATV_SOUND_STD_NICAM_I:
		case ATV_SOUND_STD_NICAM_BG:
			NICAM_DEC_REG.regValue = AIO_ReadRegister(AUDIO_nicam_decode_ctrl_reg);
			NICAM_DEC_REG.status_debounce_cnt = atv_mode_preset_tab[sound_std].debounce_cnt;
			AIO_WriteRegister(AUDIO_nicam_decode_ctrl_reg, NICAM_DEC_REG.regValue);
			break;
		case ATV_SOUND_STD_EIAJ:
		case ATV_SOUND_STD_A2_M:
		case ATV_SOUND_STD_A2_BG:
		case ATV_SOUND_STD_A2_DK1:
		case ATV_SOUND_STD_A2_DK2:
		case ATV_SOUND_STD_A2_DK3:
			MD_CTRL_REG.regValue = AIO_ReadRegister(AUDIO_md_ctrl_reg);
			MD_CTRL_REG.enable = TRUE;
			//MD_CTRL_REG.debounce_cnt = atv_mode_preset_tab[sound_std].debounce_cnt;	// Clayton 2013/1/28
			MD_CTRL_REG.high_threshold = atv_mode_preset_tab[sound_std].hi_threshold;
			MD_CTRL_REG.low_threshold = atv_mode_preset_tab[sound_std].lo_threshold;
			//MD_CTRL_REG.accu_num = atv_mode_preset_tab[sound_std].accu_num;	// Clayton, 2013/1/28, Remove
			AIO_WriteRegister(AUDIO_md_ctrl_reg, MD_CTRL_REG.regValue);
			break;
		case ATV_SOUND_STD_BTSC:
			/* configure BTSC debounce in init. reg stage */


		case ATV_SOUND_STD_MN_MONO:
		case ATV_SOUND_STD_BG_MONO:
		case ATV_SOUND_STD_DK_MONO:
		case ATV_SOUND_STD_FM_MONO_NO_I:
		case ATV_SOUND_STD_AM_MONO:
		default:
			break;
		}
	}

}

static void AtvSetA2Parameter(void)
{
	audio_md_ctrl_RBUS			MD_CTRL_REG;
	audio_md_status_2_RBUS			md_status_2;
	audio_md_status_3_RBUS			md_status_3;

	MD_CTRL_REG.regValue = AIO_ReadRegister(AUDIO_md_ctrl_reg);
	md_status_2.regValue = AIO_ReadRegister(AUDIO_md_status_2_reg);
	md_status_3.regValue = AIO_ReadRegister(AUDIO_md_status_3_reg);

	md_status_3.debounce_time = A2_Th_Table[g_A2_TH_sel].debounce_time;
	MD_CTRL_REG.max_threshold = A2_Th_Table[g_A2_TH_sel].max_threshold;
	MD_CTRL_REG.high_threshold = A2_Th_Table[g_A2_TH_sel].hi_threshold;
	MD_CTRL_REG.low_threshold = A2_Th_Table[g_A2_TH_sel].lo_threshold;
	md_status_2.lpf_coef_sel = A2_Th_Table[g_A2_TH_sel].lpf_coef_sel;

	AIO_WriteRegister(AUDIO_md_ctrl_reg, MD_CTRL_REG.regValue);
	AIO_WriteRegister(AUDIO_md_status_2_reg, md_status_2.regValue);
	AIO_WriteRegister(AUDIO_md_status_3_reg, md_status_3.regValue);
}

static void AtvSetFwCarrierFreq(uint32_t para, uint32_t fc_main, uint32_t fc_sub, uint32_t fc_3rd)
{
	audio_carrier_freq_deviation_ctrl_RBUS	FW_CARRIER_CTRL_REG;
	audio_carrier_phase_delta_RBUS			FW_CARRIER_FREQ_REG;

	if (para == ATV_DISABLE) {
		FW_CARRIER_CTRL_REG.regValue = AIO_ReadRegister(AUDIO_carrier_freq_deviation_ctrl_reg);
		FW_CARRIER_CTRL_REG.tone_det_en = FALSE;
		FW_CARRIER_CTRL_REG.freq_manual_en = FALSE;
		AIO_WriteRegister(AUDIO_carrier_freq_deviation_ctrl_reg, FW_CARRIER_CTRL_REG.regValue);
	} else {
		FW_CARRIER_FREQ_REG.main_phase_delta = (fc_main << 14) / 24576;
		FW_CARRIER_FREQ_REG.sub_phase_delta = (fc_sub << 14) / 24576;
		FW_CARRIER_CTRL_REG.phase_3rd_delta = (fc_3rd << 14) / 24576;

		FW_CARRIER_CTRL_REG.regValue = AIO_ReadRegister(AUDIO_carrier_freq_deviation_ctrl_reg);
		FW_CARRIER_CTRL_REG.tone_det_en = TRUE;
		FW_CARRIER_CTRL_REG.freq_manual_en = TRUE;
		AIO_WriteRegister(AUDIO_carrier_phase_delta_reg, FW_CARRIER_FREQ_REG.regValue);
		AIO_WriteRegister(AUDIO_carrier_freq_deviation_ctrl_reg, FW_CARRIER_CTRL_REG.regValue);
	}
}

// For HAL layer use
void Audio_AtvSetHWMute(int32_t para, uint32_t ch_id)
{
	alog_info("Audio_AtvSetHWMute %x %x %x\n", para, g_Atvpath_PB,
	     g_Atvpath_TS);

	if ((g_Atvpath_PB == 1) || (para == 0)) {
		/* Unmute: Do it / Mute: check path, Only for LG case */
		Audio_HwpSetMute(para, ch_id, AP_MUTE_ID);
	}

	if ((g_Atvpath_TS == 1) || (para == 0)) {
		/* Unmute: Do it / Mute: check path, Only for LG case */
		Audio_HwpSetMuteTS(para, ch_id, AP_MUTE_ID);
	}

	if (((g_Atvpath_PB == 1) || (g_Atvpath_TS == 1)) && (para == 1))
		audio_hw_usleep(50000); /* 50 ms */
}

//#ifdef USE_ATV_SW_MUTE
static void AtvSetMuteSW(int32_t para)
{
	if (para) {
		alog_info("SW Mute PB %d TS %d\n", g_Atvpath_PB, g_Atvpath_TS);
		if (g_Atvpath_PB == 1 || g_Atvpath_TS == 1)
			Audio_AtvMuteDecoder(TRUE);
		
		alog_info("SIF Mute\n");
		set_sif_mute(TRUE);
	} else {
		alog_info("SIF Unmute\n");
		set_sif_mute(FALSE);
		alog_info("SW Unmute\n");
		audio_hw_usleep(50000); /* delay 50ms */
		g_SetMode_Mute = 0;
		Audio_AtvMuteDecoder(FALSE);
	}
}
//#else
static void AtvSetMuteHW(int32_t para)
{
	int ori_numTvMute;

	ori_numTvMute = g_numTVMute;
	if (para == ATV_ENABLE)
		g_numTVMute++;
	else if (g_numTVMute > 0)
		g_numTVMute--;

	alog_info("tv Mute = %x \n", g_numTVMute);

	if ((AtvGetCurrState() != ATV_TASK_RUN) && (g_numTVMute > 0)) { /* 585 */
		para = ATV_DISABLE;
		g_numTVMute = 0;
	}

	if (para) {
		alog_info("Mute PB %d TS %d\n", g_Atvpath_PB, g_Atvpath_TS);
		if (((g_numTVMute != 0) && ori_numTvMute == 0) ||
		    (g_numTVMute == 0)/*&& ori_numTvMute != 0*/) {
			if (g_Atvpath_PB == 1)
				Audio_HwpSetMute(para, ATV_CH_ID_L|ATV_CH_ID_R,
						 ATV_MUTE_ID);

			if (g_Atvpath_TS == 1)
				Audio_HwpSetMuteTS(para, ATV_CH_ID_L|ATV_CH_ID_R,
						   ATV_MUTE_ID);
		}
		alog_info("SIF Mute\n");

		set_sif_mute(TRUE);
	} else {
		alog_info("SIF UNmute\n");

		set_sif_mute(FALSE);

		alog_info("UNmute\n");

		if (((g_numTVMute != 0) && ori_numTvMute == 0) ||
		    (g_numTVMute == 0)/*&& ori_numTvMute != 0*/) {
			if (g_Atvpath_PB == 1) {
				Audio_HwpSetMute(para, ATV_CH_ID_L|ATV_CH_ID_R,
						 ATV_MUTE_ID);
			}

			if (g_Atvpath_TS == 1) {
				Audio_HwpSetMuteTS(para, ATV_CH_ID_L|ATV_CH_ID_R,
						   ATV_MUTE_ID);
			}
		}
	}
}
//#endif

static void AtvSetMute(int32_t para)
{
	#if 0
	if (down_interruptible(&audio_sem_sif)) {
		alog_warning("interrupted, no semaphore held\n");
		return;
	}
	#endif

	down(&audio_sem_sif);
	AtvSetMuteSW(para);
	up(&audio_sem_sif);
}

#ifdef USE_PACFIC_STYLE
void AtvCleanTVMuteNum(void)
{
	g_numTVMute = 0;
}
#endif



#ifdef USE_PACFIC_STYLE

// internel use data
void AtvCleanStatusData(void)
{

	//	ATV_LOG( "[audio ] Clean internel data , need to do \n");


	AtvEnableTvInterrupt(ATV_DISABLE);

	// clean all data
	//	drvif_audio_set_standard(ATV_SOUND_DK, ATV_SOUND_STD_UNKNOWN);

	g_ChangeStdStatus = CHANGESTDSTATUS_INIT;
	g_UserStd = ATV_SOUND_STD_UNKNOWN;
	//	g_isAutoDetect = 0; // do not to reset
	g_SetStdFlag = 0;
	g_CurrentStd  = ATV_SOUND_STD_UNKNOWN;

	AtvResetDefaultBW();
	//	SettingSifAGC(SIF_OVF_TH_DEFAULT, SIF_OPT_TH_DEFAULT);


	//USER:Peter_Lin DATE:2010/12/16
	// add tv volume compensate
	


	//USER:Peter_Lin DATE:2010/12/14
	// Fix Nicam singal /4 HW issue
	
	//	AtvResetFifoScale(); //2010/12/16

	//USER:Peter_Lin DATE:2010/12/16
	// add tv volume compensate
	
	//AtvSetVolumeCompensate(g_TVM_VolumeCompensate_Zero);
	

	//AtvRestartIFDAGCGain();	//Clayton 2015/4/29 No need to use here
	AtvResetMSD();
	//	ResetAMPrescale();
	//	drv_audio_reset_nicam_overflow();

	//USER:Peter_Lin DATE:2010/12/29
	// add detect no signal method , default use video
	
	g_CurrentHWDetectStd = ATV_SOUND_STD_UNKNOWN;
	g_CurrentHWDetectUpdate = 0;
}

void AadConnect_CleanStatusData(void)
{
	alog_info("[%s]", __FUNCTION__);
	AtvEnableTvInterrupt(ATV_DISABLE);
	AtvResetMSD();
}

void AtvAdjuseMainCarrierThreshold(uint32_t  threadholdHigh, uint32_t  threadholdLow)
{
	audio_main_tone_threshold_RBUS main_tone_threshold;

	main_tone_threshold.regValue = AIO_ReadRegister(AUDIO_main_tone_threshold_reg);

	main_tone_threshold.main_thresh = threadholdHigh;
	main_tone_threshold.main_thresh_low = threadholdLow;

	AIO_WriteRegister(AUDIO_main_tone_threshold_reg, main_tone_threshold.regValue);
}

void AtvEnableTvInterrupt(uint32_t isEnable)
{
	audio_interrupt_en_RBUS  interrupt_en;
	audio_interrupt_status_RBUS interrupt_status;

	interrupt_en.regValue = AIO_ReadRegister(AUDIO_interrupt_en_reg);

	// disable TV-related interrupts temporarily.
	interrupt_en.int_nicam_true_detect_en = FALSE;  // Clayton, 2013/1/24
	interrupt_en.int_msd_decision_done_en = FALSE;
	interrupt_en.int_msd_fw_scan_done_en = FALSE;
	interrupt_en.int_btsc_mode_chg_en = FALSE;
	interrupt_en.int_nicam_level_status_en = FALSE;
	interrupt_en.int_nicam_hierr_change_en = FALSE;
	interrupt_en.int_sif_nopt_en = FALSE;
	interrupt_en.int_msd_change_en = FALSE;
	interrupt_en.int_msd_timeout_en = FALSE;
	interrupt_en.int_mode_det_status_change_en = FALSE;
	interrupt_en.int_sif_ovf_en = FALSE;

	AIO_WriteRegister(AUDIO_interrupt_en_reg, interrupt_en.regValue);

	// clean all interrupt pending status.
	interrupt_status.regValue = 0;
	interrupt_status.int_nicam_true_detect = TRUE;  // Clayton, 2013/1/24
	interrupt_status.int_msd_decision_done = TRUE;
	interrupt_status.int_msd_fw_scan_done = TRUE;
	interrupt_status.int_btsc_mode_chg = TRUE; // need to modify

	interrupt_status.int_nicam_level_status = TRUE;
	interrupt_status.int_nicam_hierr_change = TRUE;
	interrupt_status.int_sif_nopt = TRUE;
	interrupt_status.int_msd_change = TRUE;
	interrupt_status.int_msd_timeout = TRUE;
	interrupt_status.int_mode_det_status_change = TRUE;
	interrupt_status.int_sif_ovf = TRUE;

	AIO_WriteRegister(AUDIO_interrupt_status_reg, interrupt_status.regValue);

	if (isEnable) {}
}

void AtvSetHwDetecteMode(ATV_HW_MSD_DETECT_MODE mode)
{
	audio_msd_crtl_word_RBUS	msd_crtl_word;


	audio_msd_second_reg_std_RBUS msd_second_reg_std;

	if (mode == ATV_HW_CARRIER_NO_SHIFT_NO_BANDWIDTH) {

		msd_second_reg_std.regValue = AIO_ReadRegister(AUDIO_msd_second_reg_std_reg);
		msd_second_reg_std.reg_bw_detect_en = FALSE;
		msd_second_reg_std.reg_cari_sft_detect_en = FALSE;
		msd_second_reg_std.mono_std_sel = FALSE;
		AIO_WriteRegister(AUDIO_msd_second_reg_std_reg, msd_second_reg_std.regValue);

		msd_crtl_word.regValue = AIO_ReadRegister(AUDIO_msd_crtl_word_reg);
		msd_crtl_word.fw_scan_freq = ATV_FW_SCAN_HW_ONLY;    // Clayton, 2013/1/11
		msd_crtl_word.msd_en = TRUE;
		msd_crtl_word.carrier_shift_scan_en = FALSE;  // old function
		AIO_WriteRegister(AUDIO_msd_crtl_word_reg, msd_crtl_word.regValue);

	} else if (mode == ATV_HW_CARRIER_SHIFT_BANDWIDTH) {
		msd_second_reg_std.regValue = AIO_ReadRegister(AUDIO_msd_second_reg_std_reg);
		msd_second_reg_std.reg_bw_detect_en = TRUE;
		msd_second_reg_std.reg_cari_sft_detect_en = TRUE;
		msd_second_reg_std.mono_std_sel = FALSE;
		AIO_WriteRegister(AUDIO_msd_second_reg_std_reg, msd_second_reg_std.regValue);

		msd_crtl_word.regValue = AIO_ReadRegister(AUDIO_msd_crtl_word_reg);
		msd_crtl_word.fw_scan_freq = ATV_FW_SCAN_HW_ONLY;    // Clayton, 2013/1/11
		msd_crtl_word.msd_en = TRUE;
		msd_crtl_word.carrier_shift_scan_en = FALSE;  // old function
		AIO_WriteRegister(AUDIO_msd_crtl_word_reg, msd_crtl_word.regValue);

	} else if (mode == ATV_HW_CARRIER_SHIFT_NO_BANDWIDTH) {
		msd_second_reg_std.regValue = AIO_ReadRegister(AUDIO_msd_second_reg_std_reg);
		msd_second_reg_std.reg_bw_detect_en = FALSE;
		msd_second_reg_std.reg_cari_sft_detect_en = TRUE;
		msd_second_reg_std.mono_std_sel = FALSE;
		AIO_WriteRegister(AUDIO_msd_second_reg_std_reg, msd_second_reg_std.regValue);

		msd_crtl_word.regValue = AIO_ReadRegister(AUDIO_msd_crtl_word_reg);
		msd_crtl_word.fw_scan_freq = ATV_FW_SCAN_HW_ONLY;    // Clayton, 2013/1/11
		msd_crtl_word.msd_en = TRUE;
		msd_crtl_word.carrier_shift_scan_en = FALSE;  // old function
		AIO_WriteRegister(AUDIO_msd_crtl_word_reg, msd_crtl_word.regValue);

	} else if (mode == ATV_HW_CARRIER_NO_SHIFT) {
		msd_second_reg_std.regValue = AIO_ReadRegister(AUDIO_msd_second_reg_std_reg);
		msd_second_reg_std.reg_bw_detect_en = TRUE;
		msd_second_reg_std.reg_cari_sft_detect_en = FALSE;
		msd_second_reg_std.mono_std_sel = FALSE;
		AIO_WriteRegister(AUDIO_msd_second_reg_std_reg, msd_second_reg_std.regValue);

		msd_crtl_word.regValue = AIO_ReadRegister(AUDIO_msd_crtl_word_reg);
		msd_crtl_word.fw_scan_freq = ATV_FW_SCAN_HW_ONLY;    // Clayton, 2013/1/11
		msd_crtl_word.msd_en = TRUE;
		msd_crtl_word.carrier_shift_scan_en = FALSE;  // old function
		AIO_WriteRegister(AUDIO_msd_crtl_word_reg, msd_crtl_word.regValue);

		//		CheckifShiftZero();
	} else	 if (mode == ATV_FW_CARRIER_SHIFT_HW_DETECT) {
		msd_second_reg_std.regValue = AIO_ReadRegister(AUDIO_msd_second_reg_std_reg);
		msd_second_reg_std.reg_bw_detect_en = FALSE;
		msd_second_reg_std.reg_cari_sft_detect_en = FALSE;
		msd_second_reg_std.mono_std_sel = FALSE;
		AIO_WriteRegister(AUDIO_msd_second_reg_std_reg, msd_second_reg_std.regValue);

		msd_crtl_word.regValue = AIO_ReadRegister(AUDIO_msd_crtl_word_reg);
		msd_crtl_word.fw_scan_freq = ATV_FW_SCAN_HW_ONLY;    // Clayton, 2013/1/11
		msd_crtl_word.msd_en = TRUE;
		msd_crtl_word.carrier_shift_scan_en = TRUE;  // old function
		AIO_WriteRegister(AUDIO_msd_crtl_word_reg, msd_crtl_word.regValue);
	} else if (mode == ATV_HW_MONO_ONLY) {
		msd_second_reg_std.regValue = AIO_ReadRegister(AUDIO_msd_second_reg_std_reg);
		msd_second_reg_std.reg_bw_detect_en = FALSE;
		msd_second_reg_std.reg_cari_sft_detect_en = FALSE;
		msd_second_reg_std.mono_std_sel = TRUE;
		AIO_WriteRegister(AUDIO_msd_second_reg_std_reg, msd_second_reg_std.regValue);

		msd_crtl_word.regValue = AIO_ReadRegister(AUDIO_msd_crtl_word_reg);
		msd_crtl_word.fw_scan_freq = ATV_FW_SCAN_HW_ONLY;    // Clayton, 2013/1/11
		msd_crtl_word.msd_en = TRUE;
		msd_crtl_word.carrier_shift_scan_en = FALSE;  // old function
		AIO_WriteRegister(AUDIO_msd_crtl_word_reg, msd_crtl_word.regValue);

	} else if (mode == ATV_HW_DISABLE) {
		msd_crtl_word.regValue = AIO_ReadRegister(AUDIO_msd_crtl_word_reg);
		msd_crtl_word.msd_en = FALSE;
		AIO_WriteRegister(AUDIO_msd_crtl_word_reg, msd_crtl_word.regValue);

	} else if (mode == ATV_HW_MONO_ONLY_CARRIER_SHIFT_BANDWIDTH) {
		msd_second_reg_std.regValue = AIO_ReadRegister(AUDIO_msd_second_reg_std_reg);
		msd_second_reg_std.reg_bw_detect_en = TRUE;
		msd_second_reg_std.reg_cari_sft_detect_en = TRUE;
		msd_second_reg_std.mono_std_sel = TRUE;
		AIO_WriteRegister(AUDIO_msd_second_reg_std_reg, msd_second_reg_std.regValue);

		msd_crtl_word.regValue = AIO_ReadRegister(AUDIO_msd_crtl_word_reg);
		msd_crtl_word.fw_scan_freq = ATV_FW_SCAN_HW_ONLY;    // Clayton, 2013/1/11
		msd_crtl_word.msd_en = TRUE;
		msd_crtl_word.carrier_shift_scan_en = FALSE;  // old function
		AIO_WriteRegister(AUDIO_msd_crtl_word_reg, msd_crtl_word.regValue);
	} else if (mode == ATV_HW_MONO_ONLY_CARRIER_SHIFT_NO_BANDWIDTH) {
		msd_second_reg_std.regValue = AIO_ReadRegister(AUDIO_msd_second_reg_std_reg);
		msd_second_reg_std.reg_bw_detect_en = FALSE;
		msd_second_reg_std.reg_cari_sft_detect_en = TRUE;
		msd_second_reg_std.mono_std_sel = TRUE;
		AIO_WriteRegister(AUDIO_msd_second_reg_std_reg, msd_second_reg_std.regValue);

		msd_crtl_word.regValue = AIO_ReadRegister(AUDIO_msd_crtl_word_reg);
		msd_crtl_word.fw_scan_freq = ATV_FW_SCAN_HW_ONLY;    // Clayton, 2013/1/11
		msd_crtl_word.msd_en = TRUE;
		msd_crtl_word.carrier_shift_scan_en = FALSE;  // old function
		AIO_WriteRegister(AUDIO_msd_crtl_word_reg, msd_crtl_word.regValue);

	} else if (mode == ATV_HW_CARRIER_SHIFT_BANDWIDTH_MONO_ONLY) {
		msd_second_reg_std.regValue = AIO_ReadRegister(AUDIO_msd_second_reg_std_reg);
		msd_second_reg_std.reg_bw_detect_en = TRUE;
		msd_second_reg_std.reg_cari_sft_detect_en = TRUE;
		msd_second_reg_std.mono_std_sel = TRUE;
		AIO_WriteRegister(AUDIO_msd_second_reg_std_reg, msd_second_reg_std.regValue);

		msd_crtl_word.regValue = AIO_ReadRegister(AUDIO_msd_crtl_word_reg);
		msd_crtl_word.fw_scan_freq = ATV_FW_SCAN_HW_ONLY;    // Clayton, 2013/1/11
		msd_crtl_word.msd_en = TRUE;
		msd_crtl_word.carrier_shift_scan_en = FALSE;  // old function
		AIO_WriteRegister(AUDIO_msd_crtl_word_reg, msd_crtl_word.regValue);
	} else if (mode == ATV_HW_CARRIER_NO_SHIFT_NO_BANDWIDTH_MONO_ONLY) { //595
		msd_second_reg_std.regValue = AIO_ReadRegister(AUDIO_msd_second_reg_std_reg);
		msd_second_reg_std.reg_bw_detect_en = FALSE;
		msd_second_reg_std.reg_cari_sft_detect_en = FALSE;
		msd_second_reg_std.mono_std_sel = TRUE;
		AIO_WriteRegister(AUDIO_msd_second_reg_std_reg, msd_second_reg_std.regValue);

		msd_crtl_word.regValue = AIO_ReadRegister(AUDIO_msd_crtl_word_reg);
		msd_crtl_word.fw_scan_freq = ATV_FW_SCAN_HW_ONLY;    // Clayton, 2013/1/11
		msd_crtl_word.msd_en = TRUE;
		msd_crtl_word.carrier_shift_scan_en = FALSE;  // old function
		AIO_WriteRegister(AUDIO_msd_crtl_word_reg, msd_crtl_word.regValue);
	}

}

void AtvCleanOldStd(void)
{
	int32_t i, j;
	audio_msd_result_RBUS msd_result;
	audio_interrupt_status_RBUS interrupt_status;

	AtvAdjuseMainCarrierThreshold(0xFFFF, 0xFFFF);

	j = 2;
	i = 0;
	while (j--) {
		interrupt_status.regValue = 0;

		interrupt_status.int_msd_decision_done = 1; // only clean msd
		AIO_WriteRegister(AUDIO_interrupt_status_reg, interrupt_status.regValue); // clean int

		//	ATV_LOG( "clean %x \n", j);

		i = 500; //50*20 = 1000
		while (i--) {


			interrupt_status.regValue = AIO_ReadRegister(AUDIO_interrupt_status_reg);
			msd_result.regValue = AIO_ReadRegister(AUDIO_msd_result_reg);

			if (interrupt_status.int_msd_decision_done == 1) {
				if (j == 0) {
					if (msd_result.hw_detected_std == ATV_SOUND_STD_UNKNOWN) // debounce issuse
						break;
				} else
					break;
			}
			audio_hw_usleep(20000);	/* 20 ms */
		}
	}

	if (msd_result.hw_detected_std != ATV_SOUND_STD_UNKNOWN) // debounce issuse
		alog_info("clean failed 2\n");

	if (i <= 0) {
		alog_info("clean failed\n");
	}
}

ATV_SOUND_STD AtvHwDetectResult(uint32_t id, uint32_t islowThread)
{
	uint32_t std, i;
	uint32_t main_std;

	for (i = 0; i < 10; i++) {
		audio_hw_usleep(50000);

		std = AtvGetHWStd();
		main_std = AtvGetMainSystem(std);

		if (main_std == ATV_SOUND_MN_SYSTEM) {
			if ((g_Std_energy_45 < g_Std_energy_55) || (g_Std_energy_45 < g_Std_energy_65) || (g_Std_energy_45 < g_Std_energy_6)) {
				std = ATV_SOUND_STD_UNKNOWN;
				alog_info("[Scan]Fake MN, change to UNKNOWN\n");
			}
		} else if (main_std == ATV_SOUND_BG_SYSTEM) {
			if ((g_Std_energy_55 < g_Std_energy_6 && ((AtvGetFwPriority() & AUDIO_ATV_FW_PRIORITY_I) != 0)) || (g_Std_energy_55 < g_Std_energy_65) || (g_Std_energy_55 < g_Std_energy_45)) {
				std = ATV_SOUND_STD_UNKNOWN;
				alog_info("[Scan]Fake BG, change to UNKNOWN\n");
			}
		} else if (main_std == ATV_SOUND_I_SYSTEM) {
			if ((g_Std_energy_6 < g_Std_energy_55) || (g_Std_energy_6 < g_Std_energy_65) || (g_Std_energy_6 < g_Std_energy_45)) {
				std = ATV_SOUND_STD_UNKNOWN;
				alog_info("[Scan]Fake I, change to UNKNOWN\n");
			}
		} else if (main_std == ATV_SOUND_DK_SYSTEM) {
			if ((g_Std_energy_65 < g_Std_energy_55) || (g_Std_energy_65 < g_Std_energy_6) || (g_Std_energy_65 < g_Std_energy_45)) {
				std = ATV_SOUND_STD_UNKNOWN;
				alog_info("[Scan]Fake DK, change to UNKNOWN\n");
			}
		} else if (main_std == ATV_SOUND_L_SYSTEM) {
			if ((g_Std_energy_65 < g_Std_energy_55) || (g_Std_energy_65 < g_Std_energy_6) || (g_Std_energy_65 < g_Std_energy_45)) {
				std = ATV_SOUND_STD_UNKNOWN;
				alog_info("[Scan]Fake L, change to UNKNOWN\n");
			}
		}

		if (std != ATV_SOUND_STD_UNKNOWN) {
			alog_info("[HW auto  %x ] %x\n", id,  std);
			break; //

		} else {
			alog_info("[HW auto %x ] unknow \n", id);
		}
	}

	return (ATV_SOUND_STD)std;
}

ATV_SOUND_STD AtvHwDetectResult_FMRadio(uint32_t id, uint32_t islowThread)
{
	uint32_t   std, pre_std, i;

	audio_hw_usleep(100000);      // Speed up auto scan
	pre_std = AtvGetHWStd();

	for (i = 0; i < 4; i++) { //625
		audio_hw_usleep(100000);

		std = AtvGetHWStd();

		if (std == pre_std) {
			break;
		} else {
			pre_std = std;
		}
	}

	return (ATV_SOUND_STD)std;
}

uint32_t  AtvCheckAGCFlag(void)
{
	audio_analog_pga_RBUS analog_pg;

	analog_pg.regValue = AIO_ReadRegister(AUDIO_analog_pga_reg);

	if (analog_pg.afe_pga_vol == 0x3F)
		return 0;
	else
		return 1;
}

uint32_t AtvIsMonoSystem(uint32_t std)
{
	uint32_t ret = 0;

	switch (std) {
	case ATV_SOUND_STD_FM_MONO_NO_I:
	case ATV_SOUND_STD_AM_MONO:
	case ATV_SOUND_STD_DK_MONO:
	case ATV_SOUND_STD_BG_MONO:
	case ATV_SOUND_STD_MN_MONO:
		ret = 1;
		break;
	default :
		ret = 0;
		break;
	}

	return ret;
}

void AtvGetFreqPos(uint32_t std, uint32_t *main, uint32_t *sub)
{
	if (std > 	ATV_SOUND_STD_NICAM_I) {
		if (main != NULL)
			*main = 0;

		if (sub != NULL)
			*sub = 0;
	} else {

		if (main != NULL)
			*main = TVFreqPos[std].MainTone;

		if (sub != NULL)
			*sub = TVFreqPos[std].SubTone;
	}


}

uint32_t AtvIsNicamSystem(ATV_SOUND_STD std)
{

	uint32_t isNicam;

	switch (std) {
	default :
	case ATV_SOUND_STD_BG_MONO:
	case ATV_SOUND_STD_DK_MONO:
	case ATV_SOUND_STD_FM_MONO_NO_I:
	case ATV_SOUND_STD_A2_BG:
	case ATV_SOUND_STD_A2_DK1:
	case ATV_SOUND_STD_A2_DK2:
	case ATV_SOUND_STD_A2_DK3:
	case ATV_SOUND_STD_A2_M:
	case ATV_SOUND_STD_EIAJ:
	case ATV_SOUND_STD_BTSC:
	case ATV_SOUND_STD_AM_MONO:
	case ATV_SOUND_STD_UNKNOWN:
		isNicam = 0;
		break;
	case ATV_SOUND_STD_NICAM_I:
	case ATV_SOUND_STD_NICAM_BG:
	case ATV_SOUND_STD_NICAM_DK:
	case ATV_SOUND_STD_NICAM_L:
		isNicam = 1;
		break;

	}

	return isNicam;

}

uint32_t AtvIsMNSystem(ATV_SOUND_STD std)
{

	uint32_t isMN;

	switch (std) {
	default :
	case ATV_SOUND_STD_BG_MONO:
	case ATV_SOUND_STD_DK_MONO:
	case ATV_SOUND_STD_FM_MONO_NO_I:
	case ATV_SOUND_STD_A2_BG:
	case ATV_SOUND_STD_A2_DK1:
	case ATV_SOUND_STD_A2_DK2:
	case ATV_SOUND_STD_A2_DK3:
	case ATV_SOUND_STD_EIAJ:
	case ATV_SOUND_STD_AM_MONO:
	case ATV_SOUND_STD_UNKNOWN:
	case ATV_SOUND_STD_NICAM_I:
	case ATV_SOUND_STD_NICAM_BG:
	case ATV_SOUND_STD_NICAM_DK:
	case ATV_SOUND_STD_NICAM_L:
		isMN = 0;
		break;
	case ATV_SOUND_STD_MN_MONO:
	case ATV_SOUND_STD_BTSC:
	case ATV_SOUND_STD_A2_M:
		isMN = 1;
		break;

	}

	return isMN;
}

void AtvResetDefaultBW(void)
{
#ifdef USE_PACFIC_STYLE
	audio_bw_threshold_RBUS bw_threshold;

	bw_threshold.bw_dev_thresh_hd = g_AudioTVNormalBWThredhold;
	bw_threshold.bw_dev_thresh = g_AudioTVNormalBWThredhold;

	AIO_WriteRegister(AUDIO_bw_threshold_reg, bw_threshold.regValue);
#endif //#ifdef USE_PACFIC_STYLE
}

void AtvSwitchScanTyep(uint32_t isUseHW)
{
	audio_msd_crtl_word_RBUS	msd_ctrl_word;

	msd_ctrl_word.regValue = AIO_ReadRegister(AUDIO_msd_crtl_word_reg);

	if (isUseHW) {
		msd_ctrl_word.fw_scan_freq = ATV_FW_SCAN_HW_ONLY;    // Clayton, 2013/1/11
		msd_ctrl_word.msd_en = 1;
		//	ATV_LOG( "to hw scan \n");

	} else {
		msd_ctrl_word.fw_scan_freq = ATV_FW_SCAN_HW_ONLY;    // Clayton, 2013/1/11
		msd_ctrl_word.msd_en = 0;
		AIO_WriteRegister(AUDIO_msd_crtl_word_reg, msd_ctrl_word.regValue);
		//	ATV_LOG( "to sw scan \n");
		msd_ctrl_word.fw_scan_freq = ATV_FW_SCAN_FW_ONLY;    // Clayton, 2013/1/11
		msd_ctrl_word.msd_en = 1;
		AIO_WriteRegister(AUDIO_msd_crtl_word_reg, msd_ctrl_word.regValue);


	}

	AIO_WriteRegister(AUDIO_msd_crtl_word_reg, msd_ctrl_word.regValue);
}

uint32_t AtvGetHWStd(void)
{
	audio_main_sub_ratio_RBUS main_sub_ratio;
	uint32_t ratio;
	audio_nicam_decode_status_RBUS nicam_decode_status;
	audio_msd_crtl_word_RBUS msd_crtl_word;
	int nicam_sub_check = 0;
	uint32_t nicam_main_tone, nicam_sub_tone, sub_thresh;

	g_Std_msd_result.regValue = AIO_ReadRegister(AUDIO_msd_result_reg);
	g_Std_energy_625 = AIO_ReadRegister(AUDIO_msd_mag_6_25_reg);
	g_Std_energy_6552 = AIO_ReadRegister(AUDIO_msd_mag_6_552_reg);
	g_Std_energy_674 = AIO_ReadRegister(AUDIO_msd_carrier_6_74_reg);
	g_Std_msd_status.regValue =  AIO_ReadRegister(AUDIO_msd_status_reg);

	g_Std_energy_574 = AIO_ReadRegister(AUDIO_msd_mag_5_74_reg);
	g_Std_energy_6 = AIO_ReadRegister(AUDIO_msd_mag_6_reg);
	g_Std_energy_585  = AIO_ReadRegister(AUDIO_msd_carrier_5_85_reg);
	g_Std_energy_595 = AIO_ReadRegister(AUDIO_msd_carrier_5_95_reg);
	g_Std_energy_65 =  AIO_ReadRegister(AUDIO_msd_carrier_6_5_reg);

	g_Std_energy_45 = AIO_ReadRegister(AUDIO_msd_mag_4_5_reg);
	g_Std_energy_472 = AIO_ReadRegister(AUDIO_msd_mag_4_72_reg);
	g_Std_energy_428 = AIO_ReadRegister(AUDIO_msd_mag_4_28_reg);
	g_Std_energy_fix_45_55 = AIO_ReadRegister(AUDIO_msd_main_mag_ori1_reg);
	g_Std_energy_fix_60_65 = AIO_ReadRegister(AUDIO_msd_main_mag_ori2_reg);
	g_Std_energy_55 = AIO_ReadRegister(AUDIO_msd_mag_5_5_reg);
	g_Std_energy_525 =  AIO_ReadRegister(AUDIO_msd_mag_5_25_reg);

	main_sub_ratio.regValue = AIO_ReadRegister(AUDIO_main_sub_ratio_reg);
	ratio = main_sub_ratio.main_sub_ratio;
	// Clayton 2014/2/25
	// Debug info.
	
	alog_debug("g_Std_energy_45= 0x%x ; g_Std_energy_472= 0x%x \n", g_Std_energy_45, g_Std_energy_472);
	alog_debug("g_Std_energy_428= 0x%x \n", g_Std_energy_428);
	alog_debug("g_Std_energy_fix_45_55= 0x%x \n", g_Std_energy_fix_45_55);
	alog_debug("g_Std_energy_fix_60_65= 0x%x \n", g_Std_energy_fix_60_65);

	alog_debug("g_Std_energy_55= 0x%x ; g_Std_energy_525= 0x%x \n", g_Std_energy_55, g_Std_energy_525);
	alog_debug("g_Std_energy_574= 0x%x ; g_Std_energy_585= 0x%x \n", g_Std_energy_574, g_Std_energy_585);
	alog_debug("g_Std_energy_595= 0x%x ; g_Std_energy_6= 0x%x \n", g_Std_energy_595, g_Std_energy_6);
	alog_debug("g_Std_energy_625= 0x%x msd= %x %x\n", g_Std_energy_625, g_Std_msd_result.hw_detected_std, g_Std_msd_result.reg_std);

	alog_debug("g_Std_energy_625= 0x%x ; g_Std_energy_65= 0x%x \n", g_Std_energy_625, g_Std_energy_65);
	alog_debug("g_Std_energy_6552 0x%x ; g_Std_energy_674= 0x%x \n", g_Std_energy_6552, g_Std_energy_674);
	

	//USER:Peter_Lin DATE:2010/4/26
	// FIX P/S ratio is too high > 31db
	if ((AtvCheckAGCFlag() != 1) && (g_Std_msd_result.hw_detected_std != ATV_SOUND_STD_UNKNOWN)) {
		alog_info(" afc normal  %x \n",   g_Std_msd_result.hw_detected_std);
		//	if( (g_AudioTVControlFlag & ENABLE_PS_RATION_MORETHAN_30DB_MASK) == ENABLE_PS_RATION_MORETHAN_30DB )
		{
			if ((g_Std_msd_status.shift_value == 0)/*&& (g_Std_msd_status.deviation == 1) && (g_Std_msd_result.hw_detected_std==ATV_SOUND_STD_A2_BG)*/) {
				alog_debug("keep normal \n");
			} else {
				alog_err("no keep normal %x \n",  g_Std_msd_status.regValue);
				//USER:Peter_Lin DATE:2012/03/29
				// remove  ::FIX P/S ratio is too high > 31db
				//g_Std_msd_result.hw_detected_std = ATV_SOUND_STD_UNKNOWN;
				//end
			}
		}
		//	else
		{
			//			ATV_LOG( "no keep 2 normal %x \n",  g_Std_msd_status.regValue );
			//			g_Std_msd_result.hw_detected_std = ATV_SOUND_STD_UNKNOWN;
		}
	}

#ifdef MONITOR_NICAM_SIGNAL  // Force NICAM monitor when mono state
#if 0 //stop force nicam
	//hw_detect_std = mono
	if( AtvIsMonoSystem( (ATV_SOUND_STD) g_CurrentStd ) ){
		audio_nicam_decode_status_RBUS			nicam_decode_status;
		ATV_SOUND_STD  sound_std;

		sound_std = (ATV_SOUND_STD) g_CurrentStd;
		nicam_decode_status.regValue = AIO_ReadRegister(AUDIO_nicam_decode_status_reg);
		if(nicam_decode_status.true_detect == 1){
			//alog_info("std(%d %d) true_detect=1\n",g_Std_msd_result.hw_detected_std, sound_std);
			if(sound_std == ATV_SOUND_STD_BG_MONO){
				g_Std_msd_result.hw_detected_std = ATV_SOUND_STD_NICAM_BG;
			} else if(sound_std == ATV_SOUND_STD_DK_MONO){
				g_Std_msd_result.hw_detected_std = ATV_SOUND_STD_NICAM_DK;
			} else if(sound_std == ATV_SOUND_STD_AM_MONO){
				g_Std_msd_result.hw_detected_std = ATV_SOUND_STD_NICAM_L;
			} else if(sound_std == ATV_SOUND_STD_FM_MONO_NO_I){
				g_Std_msd_result.hw_detected_std = ATV_SOUND_STD_NICAM_I;
			} else {
				alog_info("std(%d %d) sound_std not expect\n",g_Std_msd_result.hw_detected_std, sound_std);
			}
		} else if(AtvIsNicamSystem((ATV_SOUND_STD)g_Std_msd_result.hw_detected_std)){ //6550
			audio_carrier_freq_deviation_ctrl_RBUS  CARRIER_FREQ_DEVIATION_CTRL_REG;
			ATV_SOUND_STD org_sound_std;
			audio_msd_result_RBUS msd_result;
			msd_result.regValue = AIO_ReadRegister(AUDIO_msd_result_reg);
			org_sound_std = (ATV_SOUND_STD) msd_result.reg_std;

			if(org_sound_std == ATV_SOUND_STD_BG_MONO){
				msd_result.reg_std = ATV_SOUND_STD_NICAM_BG;
			} else if(org_sound_std == ATV_SOUND_STD_DK_MONO){
				msd_result.reg_std = ATV_SOUND_STD_NICAM_DK;
			} else if(org_sound_std == ATV_SOUND_STD_FM_MONO_NO_I){
				msd_result.reg_std = ATV_SOUND_STD_NICAM_I;
			} else if(org_sound_std == ATV_SOUND_STD_AM_MONO){
				msd_result.reg_std = ATV_SOUND_STD_NICAM_L;
			} else {
				alog_info("NICAM5 reset condition fail %d\n",org_sound_std);
			}
			//AIO_WriteRegister(AUDIO_msd_result_reg, msd_result.regValue);

			AtvSetSoundStd((ATV_SOUND_STD)msd_result.reg_std);
			g_Std_msd_result.hw_detected_std = g_CurrentStd; //mono

			AtvSetSoundStd(org_sound_std);

			//CARRIER_FREQ_DEVIATION_CTRL_REG.regValue =  AIO_ReadRegister(AUDIO_carrier_freq_deviation_ctrl_reg);
			//CARRIER_FREQ_DEVIATION_CTRL_REG.force_nicam_en = 0;
			//AIO_WriteRegister(AUDIO_carrier_freq_deviation_ctrl_reg, CARRIER_FREQ_DEVIATION_CTRL_REG.regValue);
			//audio_hw_usleep(10000);//10ms

			//msd_result.regValue = AIO_ReadRegister(AUDIO_msd_result_reg);
			//msd_result.reg_std = org_sound_std;
			//AIO_WriteRegister(AUDIO_msd_result_reg, msd_result.regValue);

			//CARRIER_FREQ_DEVIATION_CTRL_REG.regValue =  AIO_ReadRegister(AUDIO_carrier_freq_deviation_ctrl_reg);
			//CARRIER_FREQ_DEVIATION_CTRL_REG.force_nicam_en = 1;
			//AIO_WriteRegister(AUDIO_carrier_freq_deviation_ctrl_reg, CARRIER_FREQ_DEVIATION_CTRL_REG.regValue);

			alog_info("NICAM4 reset condition fail mono %x\n",org_sound_std);
		} else {
			//do nothing, keep mono
			//alog_info("std(%d %d) keep mono\n",g_Std_msd_result.hw_detected_std, g_CurrentStd);
		}
	}
#endif
	if (AtvIsNicamSystem((ATV_SOUND_STD)g_CurrentStd)) {
		audio_nicam_decode_status_RBUS nicam_decode_status;
		audio_msd_crtl_word_RBUS msd_crtl_word;
		//ATV_SOUND_STD  sound_std;

		//sound_std = (ATV_SOUND_STD) g_CurrentStd;
		// get analog sound_mode
		nicam_decode_status.regValue = AIO_ReadRegister(AUDIO_nicam_decode_status_reg);
		msd_crtl_word.regValue = AIO_ReadRegister(AUDIO_msd_crtl_word_reg);

		//alog_info("std(%d %d) true_detect=%d\n",g_Std_msd_result.hw_detected_std, g_CurrentStd,nicam_decode_status.true_detect);
		// [Start]
		if (nicam_decode_status.true_detect == 0) {
			/* 2017.6.22 calling same function redundantly, remove it.
			// [Start]
			if (AtvIsNicamSystem((ATV_SOUND_STD)g_Std_msd_result.hw_detected_std) && msd_crtl_word.sound_select == 0) { //NULL & SetMode
				AtvEnhanceNicamTrueDetect(1);   // Enable
			}
			*/

			/*  //Dummy patch, remove
			      //alog_info("std(%d %d) true_detect=0\n",g_Std_msd_result.hw_detected_std, sound_std);
			      if(sound_std == ATV_SOUND_STD_NICAM_BG && g_Std_msd_result.hw_detected_std == ATV_SOUND_STD_BG_MONO)
			      {
			    g_Std_msd_result.hw_detected_std = ATV_SOUND_STD_BG_MONO;
			      }
			      else if(sound_std == ATV_SOUND_STD_NICAM_DK && g_Std_msd_result.hw_detected_std == ATV_SOUND_STD_DK_MONO)
			      {
			    g_Std_msd_result.hw_detected_std = ATV_SOUND_STD_DK_MONO;
			      }
			      else if(sound_std == ATV_SOUND_STD_NICAM_L && g_Std_msd_result.hw_detected_std == ATV_SOUND_STD_AM_MONO)
			      {
			    g_Std_msd_result.hw_detected_std = ATV_SOUND_STD_AM_MONO;
			      }
			      else if(sound_std == ATV_SOUND_STD_NICAM_I && g_Std_msd_result.hw_detected_std == ATV_SOUND_STD_FM_MONO_NO_I)
			      {
			    g_Std_msd_result.hw_detected_std = ATV_SOUND_STD_FM_MONO_NO_I;
			      }
			      else
			      {
			    //alog_info("std(%d %d) nicam disapper\n",g_Std_msd_result.hw_detected_std, sound_std);
			      }
			*/
		} else {
			if ((g_Std_msd_result.hw_detected_std == ATV_SOUND_STD_BG_MONO) && (g_CurrentStd == ATV_SOUND_STD_NICAM_BG)) {
				g_Std_msd_result.hw_detected_std = ATV_SOUND_STD_NICAM_BG;
				//alog_info("Fake BG MONO, keep BG NICAM\n");
			} else if ((g_Std_msd_result.hw_detected_std == ATV_SOUND_STD_DK_MONO) && (g_CurrentStd == ATV_SOUND_STD_NICAM_DK)) {
				g_Std_msd_result.hw_detected_std = ATV_SOUND_STD_NICAM_DK;
				//alog_info("Fake DK MONO, keep DK NICAM\n");
			} else if ((g_Std_msd_result.hw_detected_std == ATV_SOUND_STD_FM_MONO_NO_I) && (g_CurrentStd == ATV_SOUND_STD_NICAM_I)) {
				g_Std_msd_result.hw_detected_std = ATV_SOUND_STD_NICAM_I;
				//alog_info("Fake I MONO, keep I NICAM\n");
			}

		}

		/*
		if (g_NicamEnhanceTrueDetect == 1)   // Only After Enhance, it needs to disable
			AtvEnhanceNicamTrueDetect(0);   // Disable
		// [End]
		*/
	}

	// Owen 2016.10.27, add for BG NICAM wrong detect to I mono, because unstabe signal when maunal turning begineing.
	if (g_Std_msd_result.hw_detected_std == ATV_SOUND_STD_FM_MONO_NO_I) {
		if ((g_Std_energy_6 < g_Std_energy_55) || (g_Std_energy_6 < g_Std_energy_65) ||
			(g_Std_energy_6 < g_Std_energy_45))
		{
			g_Std_msd_result.hw_detected_std = ATV_SOUND_STD_UNKNOWN;
			alog_info("Fake I MONO, change to UNKNOWN\n");
		}

		if (((AtvGetFwPriority() & AUDIO_ATV_FW_PRIORITY_I) == 0) && g_Std_energy_55 >= 0x1500
				&& g_Std_energy_55 > g_Std_energy_45)
		{
			g_Std_msd_result.hw_detected_std = ATV_SOUND_STD_A2_BG;
			alog_info("audio_debug, change to A2_BG\n");
		}
	}

	// Owen 2016.08.17, add 3rd tone detect function(temporarily only apply in NICAM system)
	if (AtvIsMNSystem((ATV_SOUND_STD)g_CurrentStd) != 1) {
		nicam_decode_status.regValue = AIO_ReadRegister(AUDIO_nicam_decode_status_reg);
		msd_crtl_word.regValue = AIO_ReadRegister(AUDIO_msd_crtl_word_reg);

		nicam_main_tone = 0;
		nicam_sub_tone = 0;
		sub_thresh = 0;

		if (g_Std_msd_result.hw_detected_std == ATV_SOUND_STD_NICAM_BG) {
			nicam_main_tone = g_Std_energy_55;
			nicam_sub_tone = g_Std_energy_585;
			sub_thresh = AtvGetSubThresh((ATV_SUB_TONE_RATIO)ratio, nicam_main_tone);
		} else if (g_Std_msd_result.hw_detected_std == ATV_SOUND_STD_NICAM_DK) {
			nicam_main_tone = g_Std_energy_65;
			nicam_sub_tone = g_Std_energy_585;
			sub_thresh = AtvGetSubThresh((ATV_SUB_TONE_RATIO)ratio, nicam_main_tone);
		} else if (g_Std_msd_result.hw_detected_std == ATV_SOUND_STD_NICAM_I) {
			nicam_main_tone = g_Std_energy_6;
			nicam_sub_tone = g_Std_energy_6552;
			sub_thresh = AtvGetSubThresh((ATV_SUB_TONE_RATIO)ratio, nicam_main_tone);
		} else if (g_Std_msd_result.hw_detected_std == ATV_SOUND_STD_NICAM_L) {
			nicam_main_tone = g_Std_energy_65;
			nicam_sub_tone = g_Std_energy_585;
			sub_thresh = AtvGetSubThresh((ATV_SUB_TONE_RATIO)ratio, nicam_main_tone);
		}

		if (nicam_sub_tone > sub_thresh) {
			nicam_sub_check = 1;
		}

		if ((nicam_decode_status.true_detect == 0) && (AtvIsNicamSystem((ATV_SOUND_STD)g_Std_msd_result.hw_detected_std))) {
			if (nicam_sub_check != 1) {
				if (g_Std_msd_result.hw_detected_std == ATV_SOUND_STD_NICAM_BG) {
					g_Std_msd_result.hw_detected_std = ATV_SOUND_STD_BG_MONO;
				} else if (g_Std_msd_result.hw_detected_std == ATV_SOUND_STD_NICAM_DK) {
					g_Std_msd_result.hw_detected_std = ATV_SOUND_STD_DK_MONO;
				} else if (g_Std_msd_result.hw_detected_std == ATV_SOUND_STD_NICAM_I) {
					g_Std_msd_result.hw_detected_std = ATV_SOUND_STD_FM_MONO_NO_I;
				} else if (g_Std_msd_result.hw_detected_std == ATV_SOUND_STD_NICAM_L) {
					g_Std_msd_result.hw_detected_std = ATV_SOUND_STD_AM_MONO;
				}

				alog_info("Fake NICAM, change to Mono %x\n", g_Std_msd_result.hw_detected_std);
			}
		}
	}

#endif

	// Clayton 2014/3/5 patch for Malaysia & Vietnam field issue
	
	//#ifndef   MONITOR_NICAM_SIGNAL
#if 1//enable weak NICAM patch
#if 1//enable nicam patch
	if (g_Std_msd_result.hw_detected_std == ATV_SOUND_STD_BG_MONO) {
		// Clayton 2014/6/9
		// Remove the patch of A2/NICAM-->MONO will keep original MONO due to some conflict in AP flow
		// [Start]
		/*
		// Clayton 2014/2/13 patch for TXX company on Malaysia/Vietnam issue
		// New STD = MONO, Keep the original STD. It will not affect the sound mode playing
		if((g_CurrentStd == ATV_SOUND_STD_A2_BG) || (g_CurrentStd == ATV_SOUND_STD_NICAM_BG))
		{
		g_Std_msd_result.hw_detected_std = g_CurrentStd;
		alog_info(" [Audio][ATV][BG]Keep orginal STD due to new STD = MONO \n" );
		}
		*/
		// [End]

		// Sync 2648 path of Malaysia field signal
		// fw patch for BG NICAM but detect as BG MONO due to tone of 5.25 is large
		//ATV_LOG( "[Audio][ATV] Enter check BG NICAM or BG MONO\n");
		// 3/64 is the main_sub_ratio = 0x100
		if (g_Std_energy_585 > 0x100) {
			if ((g_Std_energy_574 >= (g_Std_energy_55 / 32)) &&
			    (g_Std_energy_585 >= (g_Std_energy_55 / 32)) &&
			    (g_Std_energy_595 >= (g_Std_energy_55 / 32))) {
				alog_info(" Error BG MONO, should be BG NICAM %4x %4x %4x %4x\n", g_Std_energy_55, g_Std_energy_574, g_Std_energy_585, g_Std_energy_595);
				g_Std_msd_result.hw_detected_std = ATV_SOUND_STD_NICAM_BG;
			}
		}

		if (g_DetectedBGNicam == 1) {
			//keep NICAM, because Nicam STD also can play FM sound. Setting Nicam does not affect FM sound.
			g_Std_msd_result.hw_detected_std = ATV_SOUND_STD_NICAM_BG;
			alog_info(" Keep Nicam STD M-%x S-%x\n", g_Std_energy_55, g_Std_energy_585);
		}

	}

#endif


#endif

	// Clayton 2014/2/13 patch for TXX company on Malaysia/Vietnam issue
	// New STD = MONO, Keep the original STD. It will not affect the sound mode playing
	else if (g_Std_msd_result.hw_detected_std == ATV_SOUND_STD_DK_MONO) {
		// Clayton 2014/6/9
		// Remove the patch of A2/NICAM-->MONO will keep original MONO due to some conflict in AP flow
		// [Start]
		/*
		   if((g_CurrentStd == ATV_SOUND_STD_A2_DK1) || (g_CurrentStd == ATV_SOUND_STD_A2_DK2) || (g_CurrentStd == ATV_SOUND_STD_A2_DK3) || (g_CurrentStd == ATV_SOUND_STD_NICAM_DK))
		   {
		   g_Std_msd_result.hw_detected_std = g_CurrentStd;
		   alog_info(" [Audio][ATV][DK]Keep orginal STD due to new STD = MONO \n" );
		   }
		   */
		// [End]
	}

	
	// no support A2
	if (AtvIsA2System((ATV_SOUND_STD)g_Std_msd_result.hw_detected_std)) {
		//USER:Peter_Lin DATE:2010/4/01
		// FIX Error Std Check,  Mono DK-> A2 DK
		if ((g_AudioTVControlFlag&ENABLE_NEW_A2_DETECTED_MASK) == ENABLE_NEW_CHECK_A2) {
			if (g_Std_msd_result.hw_detected_std == ATV_SOUND_STD_A2_DK1) {
				if ((g_Std_energy_625 >> 1) < g_Std_energy_674) {
					alog_info("Error A2DK1 %x %x \n", g_Std_energy_625, g_Std_energy_674);
					g_Std_msd_result.hw_detected_std = ATV_SOUND_STD_DK_MONO;
				}
			} else if (g_Std_msd_result.hw_detected_std == ATV_SOUND_STD_A2_DK2) {
				if ((g_Std_energy_674 >> 1) < g_Std_energy_625) {
					alog_info("Error A2DK2 %x %x \n", g_Std_energy_625, g_Std_energy_674);
					g_Std_msd_result.hw_detected_std = ATV_SOUND_STD_DK_MONO;
				}
			}
		}

		

		//USER:Peter_Lin DATE:2011/02/24
		// FIX Error Std Check,  574 noise is too strong
		
		if (g_Std_msd_result.hw_detected_std == ATV_SOUND_STD_A2_DK3) {
			if ((g_Std_energy_65 >= A2_DK3_MAIN_THRESHOLD) && (g_Std_energy_574 < A2_DK3_SUB_NOISE_THRESHOLD)) { //NULL & SetMode
				alog_info("Error A2DK3 %x %x \n", g_Std_energy_65, g_Std_energy_574);
				g_Std_msd_result.hw_detected_std = ATV_SOUND_STD_DK_MONO;
			}
		}
		

	}

	// Clayton 2014/2/13 patch for TXX company on Malaysia/Vietnam issue
	// fw patch for audio source fake BG A2 switch
	if (g_Std_msd_result.hw_detected_std == ATV_SOUND_STD_A2_BG) {
		if ((g_Std_energy_595 > (g_Std_energy_574 >> 2)) || (g_Std_energy_525 > (g_Std_energy_574 >> 1))) {
			g_Std_msd_result.hw_detected_std = g_CurrentStd;
			alog_info(" [Audio][ATV]Fake A2 BG \n");
		}

		if ((g_Std_energy_525 > (g_Std_energy_574 >> 2))) {
			alog_info(" Error BG A2, should be BG MONO due to too high deviation\n");
			g_Std_msd_result.hw_detected_std = ATV_SOUND_STD_BG_MONO;
		}
	}

	//Clayton 2014/1/7
	// Patch for FM Radio
	#if 0
	if ((g_FMRadioscanFlag == 1) && (g_Std_energy_45 < g_FMRadio_para.ATV_STD_FMRadio_NORMAL_TH) && (g_Std_msd_result.hw_detected_std == ATV_SOUND_STD_MN_MONO)) {
	#else
	if ((ATV_GetFmRadioMode() == AUDIO_ATV_FM_RADIO_SCAN) &&
		(g_Std_energy_45 < g_FMRadio_para.ATV_STD_FMRadio_NORMAL_TH) &&
		(g_Std_msd_result.hw_detected_std == ATV_SOUND_STD_MN_MONO)) {
	#endif
		uint32_t tone_45_shift = g_FMRadio_para.ATV_STD_FMRadio_TONE_4p5_SHIFT;

		if (((g_Std_energy_45 >> tone_45_shift) < g_Std_energy_472) || ((g_Std_energy_45 >> tone_45_shift) < g_Std_energy_428)) { //11+1
																	  //printf( "Error MN MONO for FM Radio %x %x %x \n", g_Std_energy_45, g_Std_energy_428, g_Std_energy_472);
			g_Std_msd_result.hw_detected_std = ATV_SOUND_STD_UNKNOWN;
		}
	}

	

	g_StdDataIsUpdate = 1;
	// Clayton 2014/2/25
	// Debug info.
	
	alog_debug(" g_Std_msd_result.regValue= 0x%x ; \n", g_Std_msd_result.regValue);
	
	return g_Std_msd_result.hw_detected_std;
}

uint32_t AtvIsA2System(ATV_SOUND_STD std)
{

	uint32_t isA2;

	switch (std) {

	case ATV_SOUND_STD_A2_BG:
	case ATV_SOUND_STD_A2_DK1:
	case ATV_SOUND_STD_A2_DK2:
	case ATV_SOUND_STD_A2_DK3:
	case ATV_SOUND_STD_A2_M:
		isA2 = 1;
		break;
	default :
		isA2 = 0;
		break;
	}

	return isA2;

}

void  AtvSetFwScanFreq(uint32_t Freq, uint32_t index)
{
	uint32_t address;
	audio_msd_programmable_freq_RBUS msd_programmable_freq;

	switch (index) {
	default:
	case 0:
		address = AUDIO_msd_programmable_freq_reg;
		break;
	case 1:
		address = AUDIO_msd_programmable_freq_1_reg;
		break;
	case 2:
		address = AUDIO_msd_programmable_freq_2_reg;
		break;
	case 3:
		address = AUDIO_msd_programmable_freq_3_reg;
		break;
	case 4:
		address = AUDIO_msd_programmable_freq_4_reg;
		break;
	}

	msd_programmable_freq.regValue = AIO_ReadRegister(address);

	msd_programmable_freq.fw_phase_delta =  (Freq << 14) / 24576;

	AIO_WriteRegister(address, msd_programmable_freq.regValue);
}

uint32_t  AtvGetFreqScanResult(uint32_t index)
{
	uint32_t address;
	audio_msd_programmable_freq_RBUS msd_programmable_freq;

	switch (index) {
	default :
	case 0:
		address = AUDIO_msd_programmable_freq_reg;
		break;
	case 1:
		address = AUDIO_msd_programmable_freq_1_reg;
		break;
	case 2:
		address = AUDIO_msd_programmable_freq_2_reg;
		break;
	case 3:
		address = AUDIO_msd_programmable_freq_3_reg;
		break;
	case 4:
		address = AUDIO_msd_programmable_freq_4_reg;
		break;
	}

	msd_programmable_freq.regValue = AIO_ReadRegister(address);

	return msd_programmable_freq.reg_mag_fw;
}

void AtvGetSWFreqShift(uint32_t std, uint32_t isFirstTime, uint32_t SWReset, uint32_t *mainToneEnergy)
{

	uint32_t i, ScanFreq;
	uint32_t tableSize = 0;

	SignalFreqPos FreqPos;
	static uint32_t g_DetectSetIndex = 0;
	static uint32_t g_DetectRecordIndex = 0;

	//	audio_msd_crtl_word_RBUS msd_crtl_word;
	audio_interrupt_status_RBUS interrupt_status;

	//	returnValue =UNKNOW_FREQ_SHIFT; // need to 4 loop to calculate shift value (20 frequence)
	tableSize = sizeof(SignalFreqShfitDetectTable) / sizeof(SignalFreqShfitDetectTable[0]);
	AtvGetFreqPos(std, &(FreqPos.MainTone), &(FreqPos.SubTone));

	if (isFirstTime  !=  1) {
		// get freq
		for (i = 0; i < 5; i++) {

			SignalFreqShfitDetectTable[g_DetectRecordIndex].value = AtvGetFreqScanResult(SignalFreqShfitDetectTable[g_DetectRecordIndex].hwindex);

			if ((g_AudioTVPrintFlag&ATV_PRINT_FLAG_ENABLE_SW_SCAN) == ATV_PRINT_FLAG_ENABLE_SW_SCAN)
				alog_info("read %04d %04d freq = 0x%08x\n", (g_DetectRecordIndex), SignalFreqShfitDetectTable[g_DetectRecordIndex].freq, SignalFreqShfitDetectTable[g_DetectRecordIndex].value);

			if (SignalFreqShfitDetectTable[g_DetectRecordIndex].freq == FreqPos.MainTone) {
				if (mainToneEnergy != NULL)
					*mainToneEnergy = SignalFreqShfitDetectTable[g_DetectRecordIndex].value;
			}

			g_DetectRecordIndex++;


			g_DetectRecordIndex = (g_DetectRecordIndex % tableSize); // next time start index

			if (g_DetectRecordIndex == 0) {
				if ((g_AudioTVPrintFlag&ATV_PRINT_FLAG_ENABLE_SW_SCAN) == ATV_PRINT_FLAG_ENABLE_SW_SCAN)
					alog_info("\n");
			}
		}

	} else {
		g_DetectSetIndex = 0; // first time
		g_DetectRecordIndex = 0;
	}

	if (SWReset == 1) {
		g_DetectSetIndex = 0; // first time
		g_DetectRecordIndex = 0;
	}

	for (i = 0; i < 5; i++) {

		ScanFreq = FreqPos.MainTone + SignalFreqShfitDetectTable[g_DetectSetIndex].shift;
		SignalFreqShfitDetectTable[g_DetectSetIndex].hwindex = i;
		SignalFreqShfitDetectTable[g_DetectSetIndex].freq = ScanFreq;
		AtvSetFwScanFreq(ScanFreq, i);
		g_DetectSetIndex++;
		g_DetectSetIndex = (g_DetectSetIndex % tableSize); // next time start index
								   //	ATV_LOG( " set %x = %x\n", (g_DetectSetIndex+i), SignalFreqShfitDetectTable[g_DetectSetIndex+i].freq);

	}

	//	SwitchScanTyep(0);

	//USER:Peter_Lin DATE:2010/12/20
	// add clean interupt status initial value
	
	interrupt_status.regValue = 0;
	
	interrupt_status.int_msd_fw_scan_done = 1; // only clean msd
	AIO_WriteRegister(AUDIO_interrupt_status_reg, interrupt_status.regValue); // clean int


}

uint32_t AtvGetMainSystem(uint32_t std)
{
	uint32_t system;

	switch (std) {
	case ATV_SOUND_STD_MN_MONO:
	case ATV_SOUND_STD_BTSC:
	case ATV_SOUND_STD_A2_M:
	case ATV_SOUND_STD_EIAJ:
		system = ATV_SOUND_MN_SYSTEM;
		break;
	case ATV_SOUND_STD_BG_MONO:
	case ATV_SOUND_STD_A2_BG:
	case ATV_SOUND_STD_NICAM_BG:
		system = ATV_SOUND_BG_SYSTEM;
		break;
	case ATV_SOUND_STD_DK_MONO:
	case ATV_SOUND_STD_A2_DK1:
	case ATV_SOUND_STD_A2_DK2:
	case ATV_SOUND_STD_A2_DK3:
	case ATV_SOUND_STD_NICAM_DK:
		system = ATV_SOUND_DK_SYSTEM;
		break;
	case ATV_SOUND_STD_AM_MONO:
	case ATV_SOUND_STD_NICAM_L:
		system = ATV_SOUND_L_SYSTEM;
		break;
	case ATV_SOUND_STD_FM_MONO_NO_I:
	case ATV_SOUND_STD_NICAM_I:
		system = ATV_SOUND_I_SYSTEM;
		break;
	case ATV_SOUND_STD_UNKNOWN:
	default:
		system = ATV_SOUND_UNKNOWN_SYSTEM;
		break;
	}

	return system;
}

uint32_t AtvCheckIfStdChangeValid(uint32_t newStd)
{
	uint32_t isValid;
	//	uint32_t newFreq;
	//	uint32_t oldFreq;


	{ // limit change // main freq keep the same

		if ((newStd == ATV_SOUND_STD_UNKNOWN)) {
			if ((g_AudioTVControlFlag&ENABLE_LIMITSTD_CHANGE_NO_UNKNOW_MASK) ==  ENABLE_LIMITSTD_CHANGE_NO_UNKNOW) {
				isValid = 0;
			} else {
				isValid = 1;
			}
		} else {
			if (g_UserStdMainSystem == ATV_SOUND_UNKNOWN_SYSTEM)
				isValid = 1;
			else {
				if (g_UserStdMainSystem == (int)AtvGetMainSystem(newStd))
					isValid = 1;
				else
					isValid = 0; // unvalid change
			}
		}
	}

	return isValid;

}


//USER:Peter_Lin DATE:2010/12/16
// add tv volume compensate


#if 0


//USER:Peter_Lin DATE:2010/12/14
// Fix Nicam singal /4 HW issue

void AtvResetFifoScale(){
	audio_down_sample_fifo_source_sel_RBUS adown_sample_fifo_source_sel;
	adown_sample_fifo_source_sel.regValue = AIO_ReadRegister(AUDIO_DOWN_SAMPLE_FIFO_SOURCE_SEL_VADDR);
	adown_sample_fifo_source_sel.fifo_ch12_scale = 0x5; // 0db
	AIO_WriteRegister(AUDIO_DOWN_SAMPLE_FIFO_SOURCE_SEL_VADDR, adown_sample_fifo_source_sel.regValue);

}


void AtvNicamFifoScale(){
	audio_down_sample_fifo_source_sel_RBUS adown_sample_fifo_source_sel;
	adown_sample_fifo_source_sel.regValue = AIO_ReadRegister(AUDIO_DOWN_SAMPLE_FIFO_SOURCE_SEL_VADDR);
	adown_sample_fifo_source_sel.fifo_ch12_scale = 0x1; // -12db
	AIO_WriteRegister(AUDIO_DOWN_SAMPLE_FIFO_SOURCE_SEL_VADDR, adown_sample_fifo_source_sel.regValue);

}


//USER:Peter_Lin DATE:2010/12/16
// add tv volume compensate

#endif


void AtvChangeStdCleanData(void)
{
	//USER:Peter_Lin DATE:2011/01/25
	// fix nicam hw bug , no signal crash
	
	audio_msd_result_RBUS	msd_result;

	msd_result.regValue = AIO_ReadRegister(AUDIO_msd_result_reg); // reset
	msd_result.reg_std = ATV_SOUND_STD_UNKNOWN;
	AIO_WriteRegister(AUDIO_msd_result_reg, msd_result.regValue); // reset
									

	//	audio_am_RBUS am;
	g_lowRFDebounce  = LOWRFDEBOUNCEMAX;
	g_lowRFFlag = 0;

	g_CurrentDeviation = FM_BW_NORMAL;

	g_lowPSDebounce  = LOWPSDEBOUNCEMAX;
	g_lowPSFlag  = 0;

	g_TVAudioReady = 0;
	AtvResetErrorRateConsNum();
	g_ErrorRateConstNum = 0;

	//	drv_audio_set_tsb_singal(0);

	// reset pga gain
	//	ATV_LOG( "enable pga\n");

	//AtvRestartIFDAGCGain(); //Clayton 2015/4/29 No need to use here
	//	ResetAMPrescale();
	AtvResetNicamOverflow();

	AtvResetMSD();

	//USER:Peter_Lin DATE:2010/12/16
	// add tv volume compensate
	

	//USER:Peter_Lin DATE:2010/12/14
	// Fix Nicam singal /4 HW issue
	
	//	AtvResetFifoScale(); //2010/12/16 mark
	
	//


	//USER:Peter_Lin DATE:2010/12/16
	// add tv volume compensate
	
	// Clayton 2013/6/4
	// No need to adjust prescale setting under ATV
	//AtvSetVolumeCompensate(g_TVM_VolumeCompensate_Zero);
	


	//USER:Peter_Lin DATE:2010/10/12
	// fix btsc sap disapper noise
	
	g_CurrentIsPlaySAP = 0;
	//  [end]


}

//Frank 2015/01/19
//Modify for new design BW. Because new BWs do not meet old design, bandwidth is not exactly the same as old driver.
//Follow old BW setting....
static void AtvSetDeviation(uint32_t sound_std, uint32_t bwid)
{
	audio_a2_eiaj_demod_RBUS a2_eiaj_demod;
	audio_global_ctrl_1_RBUS	global_ctr;

	global_ctr.regValue = AIO_ReadRegister(AUDIO_global_ctrl_1_reg);
	a2_eiaj_demod.regValue = AIO_ReadRegister(AUDIO_a2_eiaj_demod_reg);

	if (g_DevBySoundStd == ATV_DEV_CHANGE_BY_USER)
		return;

	g_CurrentDeviation = bwid;
	alog_info("dev %x  \n", g_CurrentDeviation);

	switch (sound_std) {
	case ATV_SOUND_STD_FM_MONO_NO_I:
	case ATV_SOUND_STD_DK_MONO:
	case ATV_SOUND_STD_BG_MONO:
	case ATV_SOUND_STD_NICAM_I:
	case ATV_SOUND_STD_NICAM_BG:
	case ATV_SOUND_STD_NICAM_DK:
	case ATV_SOUND_STD_NICAM_L:

		// Clayton 2013/1/28
		// update FM BPF BW (Deviation) setting, different from the previous method
		// [Start]
		if ((bwid == FM_BW_SUPER)) {                //+- 370kHz Old...+/-300kHz
			a2_eiaj_demod.a2_bw_sel = 3;
			a2_eiaj_demod.a2_sub_bw_sel = 1;
			global_ctr.hdv_mode_sel = 1;
		} else if (bwid == FM_BW_HIGH) {          //+- 240kHz Old...+/-200kHz
			a2_eiaj_demod.a2_bw_sel = 2;
			a2_eiaj_demod.a2_sub_bw_sel = 1;
			global_ctr.hdv_mode_sel = 1;
		} else {    // Internal sif case
			a2_eiaj_demod.a2_bw_sel = 2;
			a2_eiaj_demod.a2_sub_bw_sel = 2;
			global_ctr.hdv_mode_sel = 0;

		}

		break;
		// Clayton 2014/3/7, Update MN MONO & BTSC vs. deviation setting
		// BTSC can set high deviation due to HW support it.
	case ATV_SOUND_STD_MN_MONO:
		if (bwid == FM_BW_HIGH) { //TODO: change for EU model
			a2_eiaj_demod.a2_bw_sel = 2;
			a2_eiaj_demod.a2_sub_bw_sel = 2;
			global_ctr.hdv_mode_sel = 0;
		} else if (bwid == FM_BW_SUPER) {  // Except A2, other STD can set the BW from WebOS--> HAL:HAL_AUDIO_SIF_SetHighDevMode
			a2_eiaj_demod.a2_bw_sel = 3;
			a2_eiaj_demod.a2_sub_bw_sel = 3;
			global_ctr.hdv_mode_sel = 0;
		} else { // No carrier shift
			a2_eiaj_demod.a2_bw_sel = 0;
			a2_eiaj_demod.a2_sub_bw_sel = 0;
			global_ctr.hdv_mode_sel = 0;
		}

		break;
	case ATV_SOUND_STD_BTSC:
		if (bwid == FM_BW_HIGH) { // Audio Tone is locked and reasonable
			a2_eiaj_demod.a2_bw_sel = 3;
			a2_eiaj_demod.a2_sub_bw_sel = 3;
			global_ctr.hdv_mode_sel = 0;
		} else if (bwid == FM_BW_SUPER) { //Version A
			a2_eiaj_demod.a2_bw_sel = 2;
			a2_eiaj_demod.a2_sub_bw_sel = 1;
			global_ctr.hdv_mode_sel = 1;
		} else { //besides KR model
			a2_eiaj_demod.a2_bw_sel = 2;
			a2_eiaj_demod.a2_sub_bw_sel = 2;
			global_ctr.hdv_mode_sel = 0;
		}

		break;
	case ATV_SOUND_STD_A2_M:
		if (bwid == FM_BW_NORMAL) { // If test ok, K3L will only keep 1 A2_table for all std.
			a2_eiaj_demod.a2_bw_sel = 1;
			a2_eiaj_demod.a2_sub_bw_sel = 0;  //+-60kHz for sub-tone for A2 pilot carrier test
			global_ctr.hdv_mode_sel = 0;
		} else if (bwid == FM_BW_HIGH) { // KR A2 TH =11 case, 1x% must be mono
			a2_eiaj_demod.a2_bw_sel = 2;
			a2_eiaj_demod.a2_sub_bw_sel = 0; //+-60kHz for sub-tone for A2 pilot carrier test
			global_ctr.hdv_mode_sel = 0;
		} else { // KR A2 TH =11 case, 1x% must be mono
			a2_eiaj_demod.a2_bw_sel = 3;
			a2_eiaj_demod.a2_sub_bw_sel = 0; //+-60kHz for sub-tone for A2 pilot carrier test
			global_ctr.hdv_mode_sel = 0;
		}

		break;
	case ATV_SOUND_STD_A2_BG:
	case ATV_SOUND_STD_A2_DK1:
	case ATV_SOUND_STD_A2_DK2:
	case ATV_SOUND_STD_A2_DK3:

		if (bwid == FM_BW_NORMAL) { // KR A2 TH =11 case, 1x% must be mono
			a2_eiaj_demod.a2_bw_sel = 2;
			a2_eiaj_demod.a2_sub_bw_sel = 2;
			global_ctr.hdv_mode_sel = 0;
		} else if (bwid == FM_BW_HIGH) { // linmc@20121206...Resolve ap will be muted when quickly switches tv to other source
			a2_eiaj_demod.a2_bw_sel = 2;
			a2_eiaj_demod.a2_sub_bw_sel = 1;
			global_ctr.hdv_mode_sel = 1;
		} else if (bwid == FM_BW_SUPER) { // For M-system used
			a2_eiaj_demod.a2_bw_sel = 3;
			a2_eiaj_demod.a2_sub_bw_sel = 1;
			global_ctr.hdv_mode_sel = 1;
		} else {  // Speed up auto scan, check count from 10 to 6
			a2_eiaj_demod.a2_bw_sel = 3;
			a2_eiaj_demod.a2_sub_bw_sel = 1;
			global_ctr.hdv_mode_sel = 1;
		}

		break;
	case ATV_SOUND_STD_EIAJ:

	case ATV_SOUND_STD_AM_MONO:

	case ATV_SOUND_STD_UNKNOWN:
	default:
		a2_eiaj_demod.a2_bw_sel = 2;       //+-120K  ...old +/-100kHz
		a2_eiaj_demod.a2_sub_bw_sel = 2;
		global_ctr.hdv_mode_sel = 0;
		break;
	}

	AIO_WriteRegister(AUDIO_a2_eiaj_demod_reg, a2_eiaj_demod.regValue);
	AIO_WriteRegister(AUDIO_global_ctrl_1_reg, global_ctr.regValue);
	
}

void AtvSwitch2NicamAnalog(void)
{
	// change to analog mode

	//	if(g_monitorNicamFlag == 1)
	//		drvif_audio_enable_monitor_nicam(0, NULL);

	//	drv_audio_set_tsb_singal(0);

	/*  // Don't concern L NICAM case
	    // Enalbe AM frequency response compensation when L NICAM switch to AM MONO
	    if(g_CurrentStd == ATV_SOUND_STD_NICAM_L)
	    {
		AtvEnableAMFreqCompensate(1);   // AM MONO, Enable freq response compensatation
	    }
	*/
	if ((atv_flag&ATV_INIT_DEV_NICAM_BGDKI_MASK) == ATV_INIT_DEV_NICAM_BGDKI_NORMAL) {
		AtvChangeDeviation(g_CurrentStd, FM_BW_NORMAL);
	} else if ((atv_flag&ATV_INIT_DEV_NICAM_BGDKI_MASK) == ATV_INIT_DEV_NICAM_BGDKI_HIGH) {
		AtvChangeDeviation(g_CurrentStd, FM_BW_HIGH);
	} else if ((atv_flag&ATV_INIT_DEV_NICAM_BGDKI_MASK) == ATV_INIT_DEV_NICAM_BGDKI_SUPER) {
		AtvChangeDeviation(g_CurrentStd, FM_BW_SUPER);
	} else {
		AtvChangeDeviation(g_CurrentStd, FM_BW_SUPER);
	}

	if (g_CurrentDeviation == FM_BW_SUPER) {
		//ioctl(audio_fd, ATV_CMD_SET_CLOCK, AIO_PATH_SRC_ATV_HDEV);
		//	if(pCAudioInputFilter != NULL)
#if defined(AUDIO_C_MODEL)
		//((AIN*)pCAudioInputFilter->pDerivedObj)
		//    ->SetATVClock(pCAudioInputFilter, AUDIO_IPT_SRC_ATV_HDEV);
#else
		//	 pCAudioInputFilter->SetATVClock(AUDIO_IPT_SRC_ATV_HDEV);
#endif
		//		drv_audio_set_clock_and_sramplerate(AUD_CLK_PLL_AUDIO, AUD_SAMPLE_RATE_96k);
		//	drv_audio_set_compensate_volume(g_TVBGDKIVolumeCompensate);

		//USER:Peter_Lin DATE:2010/12/16
		// add tv volume compensate
		
		//	AtvSetVolumeCompensate(g_TVNICAM_MonoVolumeCompensate_Super);
		
	} else if (g_CurrentDeviation == FM_BW_HIGH) {
		//ioctl(audio_fd, ATV_CMD_SET_CLOCK, AIO_PATH_SRC_ATV_HDEV);
		//	if(pCAudioInputFilter != NULL)
#if defined(AUDIO_C_MODEL)
		//((AIN*)pCAudioInputFilter->pDerivedObj)
		//    ->SetATVClock(pCAudioInputFilter, AUDIO_IPT_SRC_ATV_HDEV);
#else
		//	 pCAudioInputFilter->SetATVClock(AUDIO_IPT_SRC_ATV_HDEV);
#endif
		//	drv_audio_set_clock_and_sramplerate(AUD_CLK_PLL_AUDIO, AUD_SAMPLE_RATE_96k);
		//	drv_audio_set_compensate_volume(g_TVBGDKIVolumeCompensate);


		//USER:Peter_Lin DATE:2010/12/16
		// add tv volume compensate
		
		//	AtvSetVolumeCompensate(g_TVNICAM_MonoVolumeCompensate_High);
		
	} else {
		//drv_audio_set_clock_and_sramplerate(AUD_CLK_PLL_AUDIO, AUD_SAMPLE_RATE_48k);
		//ioctl(audio_fd, ATV_CMD_SET_CLOCK, AIO_PATH_SRC_ATV);
		//	if(pCAudioInputFilter != NULL)
#if defined(AUDIO_C_MODEL)
		//((AIN*)pCAudioInputFilter->pDerivedObj)
		//    ->SetATVClock(pCAudioInputFilter, AUDIO_IPT_SRC_ATV);
#else
		//	 pCAudioInputFilter->SetATVClock(AUDIO_IPT_SRC_ATV);
#endif
		//USER:Peter_Lin DATE:2010/12/16
		// add tv volume compensate
		
		//	AtvSetVolumeCompensate(g_TVNICAM_MonoVolumeCompensate_Normal);
		
	}

	//USER:Peter_Lin DATE:2010/12/16
	// add tv volume compensate
	


	//USER:Peter_Lin DATE:2010/12/14
	// Fix Nicam singal /4 HW issue
	
	//	AtvResetFifoScale(); //2010/12/16 mark
	

	 //2010/12/16

	Audio_AtvSetSoundSelect(ATV_SOUND_SEL_FMAM);
}

void AtvSwitch2NicamDigial(void)
{
	// switch analog to digital
	//	ATV_LOG( "to dig\n");


	//	if(g_monitorNicamFlag == 1)
	//		drvif_audio_enable_monitor_nicam(1, NULL);
	/*  // Don't concern L NICAM case
	  AtvEnableAMFreqCompensate(0);   // Disable AM Freq compensate
	*/
	AtvSetAtvClock(AUDIO_IPT_SRC_ATV_NICAM, __LINE__);
	AtvSetAtvSubClock(AUDIO_IPT_SRC_ATV_NICAM, __LINE__);

	if (g_UserTVNICAMLanguage == 0) // Language A
		Audio_AtvSetSoundSelect(ATV_SOUND_SEL_STEREO_A);
	else  if (g_UserTVNICAMLanguage == 1) // Language B
		Audio_AtvSetSoundSelect(ATV_SOUND_SEL_STEREO_B);
	else
		Audio_AtvSetSoundSelect(ATV_SOUND_SEL_STEREO_AB);


	//USER:Peter_Lin DATE:2010/12/16
	// add tv volume compensate

	//USER:Peter_Lin DATE:2010/12/14
	// Fix Nicam singal /4 HW issue
	
	//	AtvNicamFifoScale(); //2010/12/16 mark
	
	 //2010/12/16

	//USER:Peter_Lin DATE:2010/12/16
	// add tv volume compensate
	
	//	AtvSetVolumeCompensate(g_TVNICAM_Digital_VolumeCompensate);
	

	//ioctl(audio_fd, ATV_CMD_SET_CLOCK, AIO_PATH_SRC_ATV_NICAM);

}

//USER:Peter_Lin DATE:2010/12/16
// add tv volume compensate

/***************
//void AtvSetVolumeCompensate(int vol)
{
    int32_t	a,b,c=0;
#ifndef BUILD_TV010_2_ATV
    return ; // need to check volume compensate and add ts path volume compensate
#endif
    audio_hw_in_pre_scale_RBUS hw_in_pre_scale;

    if(vol > APP_MAX_VOL)	vol = APP_MAX_VOL;
    if(vol < APP_MIN_VOL)	vol = APP_MIN_VOL;

    // change dvol setting to DVOL mode
    hw_in_pre_scale.regValue = AIO_ReadRegister(AUDIO_HW_IN_PRE_SCALE_VADDR);



    c = vol & 0x7;

    a = (vol>>3) / 6;
    b = (vol>>3) % 6;
    if(b < 0) {
    a--;
    b += 6;
    }

    hw_in_pre_scale.ch01_scale_a = a;
    hw_in_pre_scale.ch01_scale_b= b;

    AIO_WriteRegister(AUDIO_HW_IN_PRE_SCALE_VADDR, hw_in_pre_scale.regValue);

}

**************/
void AtvSetNewSoundStd(ATV_SOUND_STD sound_std)
{

	//	AIO_PATH_CFG 		t_path_cfg;
	//audio_msd_result_RBUS MSD_RESULT_REG;

	alog_info("change sound std(%x)\n", sound_std);

	// turn-off F/W carrier setting to change std
	//	AtvSetFwCarrierFreq(ATV_DISABLE, 0, 0, 0);

	//AtvRestartIFDAGCGain();	//Clayton 2015/4/29 No need to use here
	//	ResetAMPrescale();

	Audio_AtvSetPlayChannel(ATV_PLAY_CH_SEL_L, ATV_PLAY_CH_SEL_R);  // reset to stereo

	if (sound_std != ATV_SOUND_STD_AM_MONO) {
		//		SettingSifAGC(SIF_OVF_TH_DEFAULT, SIF_OPT_TH_DEFAULT);
	} else {
		//		if( (g_AudioTVControlFlag & ENABLE_AM_GAIN_MASK) == ENABLE_AM_OPT_THREASHOLD)
		//			SettingSifAGC(SIF_OVF_TH_STD_L, SIF_OPT_TH_STD_L);
		//		else
		//			SettingSifAGC(SIF_OVF_TH_DEFAULT, SIF_OPT_TH_DEFAULT);
	}

	{
		/*
		 * step 1. use MSD to check if standard exist.
		 * step 2. use freq_offset or 2nd_phase to lock standard (move to sub-routine in the future)
		 */

		//	AIO_WriteRegister(AUDIO_msd_crtl_word_reg, MSD_CTRL_REG.regValue);

		//	AtvSetSoundStd(sound_std);

		//	MSD_RESULT_REG.regValue = AIO_ReadRegister(AUDIO_msd_result_reg);

		if (sound_std == ATV_SOUND_STD_UNKNOWN)
			return;

		//	AtvSetDeviation(MSD_RESULT_REG.reg_std);
		AtvSetPrescaleDeemphasis(sound_std);
		AtvPresetModeDebounceCoef(sound_std); // for speed up A2(sound_std);

		//		t_path_cfg.id = AIO_PATH_ID_PB;
		//		Audio_AioGetPathSrc(&t_path_cfg);
		/*
			if( (t_path_cfg.src[0] == AIO_PATH_SRC_ATV_NICAM) ||
			(t_path_cfg.src[0] == AIO_PATH_SRC_ATV_HDEV) ||
			(t_path_cfg.src[0] == AIO_PATH_SRC_ATV) )
		*/
		{

			// TODO: ioctl change Clock/PLL setting
			switch (sound_std) {
			case ATV_SOUND_STD_NICAM_L:
			case ATV_SOUND_STD_NICAM_DK:
			case ATV_SOUND_STD_NICAM_I:
			case ATV_SOUND_STD_NICAM_BG:
				if (((atv_flag&ATV_INIT_DEV_NICAM_BGDKI_MASK) == ATV_INIT_DEV_NICAM_BGDKI_SUPER)) {
					AtvChangeDeviation(sound_std, FM_BW_SUPER);

				} else if (((atv_flag&ATV_INIT_DEV_NICAM_BGDKI_MASK) == ATV_INIT_DEV_NICAM_BGDKI_HIGH)) {
					AtvChangeDeviation(sound_std, FM_BW_HIGH);

				} else {
					AtvChangeDeviation(sound_std, FM_BW_NORMAL);

				}

				AtvSwitch2NicamAnalog(); // default use analog

				break;
			case ATV_SOUND_STD_BG_MONO:
			case ATV_SOUND_STD_DK_MONO:
			case ATV_SOUND_STD_FM_MONO_NO_I:
				if (((atv_flag&ATV_INIT_DEV_BGDKI_MASK) == ATV_INIT_DEV_BGDKI_SUPER))
					AtvChangeDeviation(sound_std, FM_BW_SUPER);
				else if (((atv_flag&ATV_INIT_DEV_BGDKI_MASK) == ATV_INIT_DEV_BGDKI_HIGH))
					AtvChangeDeviation(sound_std, FM_BW_HIGH);
				else
					AtvChangeDeviation(sound_std, FM_BW_NORMAL);

				Audio_AtvSetSoundSelect(ATV_SOUND_SEL_FMAM);

				break;
			case ATV_SOUND_STD_A2_BG:
			case ATV_SOUND_STD_A2_DK1:
			case ATV_SOUND_STD_A2_DK2:
			case ATV_SOUND_STD_A2_DK3:

				//	if(((atv_flag & ATV_INIT_DEV_BGDKI_MASK) == ATV_INIT_DEV_BGDKI_SUPER) )
				//		AtvChangeDeviation(sound_std, FM_BW_SUPER);
				//	else if(((atv_flag & ATV_INIT_DEV_BGDKI_MASK) == ATV_INIT_DEV_BGDKI_HIGH) )
				//		AtvChangeDeviation(sound_std, FM_BW_HIGH);
				//	else if(((atv_flag & ATV_INIT_DEV_BGDKI_MASK) == ATV_INIT_DEV_BGDKI_ULTRA) )
				//		AtvChangeDeviation(sound_std, FM_BW_ULTRA);
				//	else
				AtvChangeDeviation(sound_std, FM_BW_NORMAL);

				//					AtvSetDeviation(sound_std, FM_BW_NORMAL);

				if (g_UserTVA2ISStereo == 1) // stereo
					Audio_AtvSetSoundSelect(ATV_SOUND_SEL_STEREO_A);
				else // mono
					Audio_AtvSetSoundSelect(ATV_SOUND_SEL_FMAM);

				break;
			case ATV_SOUND_STD_MN_MONO:

				if ((atv_flag&ATV_INIT_DEV_M_MASK) == ATV_INIT_DEV_M_HIGH) {
					AtvChangeDeviation(sound_std, FM_BW_HIGH);
				} else if ((atv_flag&ATV_INIT_DEV_M_MASK) == ATV_INIT_DEV_M_SUPER) {
					AtvChangeDeviation(sound_std, FM_BW_SUPER);
				} else {
					AtvChangeDeviation(sound_std, FM_BW_NORMAL);
				}

				Audio_AtvSetSoundSelect(ATV_SOUND_SEL_FMAM);        // force to NICAM digital mode select

				break;
			case ATV_SOUND_STD_A2_M:


				//	if((atv_flag & ATV_INIT_DEV_M_MASK) == ATV_INIT_DEV_M_HIGH) {
				//		AtvChangeDeviation(sound_std, FM_BW_HIGH);
				//	}
				//	else if((atv_flag & ATV_INIT_DEV_M_MASK) == ATV_INIT_DEV_M_SUPER) {
				//	AtvChangeDeviation(sound_std, FM_BW_SUPER);
				//	}
				//	else
				{
					AtvChangeDeviation(sound_std, FM_BW_HIGH);
				}

				if (g_UserTVA2ISStereo == 1) // stereo
					Audio_AtvSetSoundSelect(ATV_SOUND_SEL_STEREO_A);
				else // mono
					Audio_AtvSetSoundSelect(ATV_SOUND_SEL_FMAM);


				break;
			case ATV_SOUND_STD_BTSC:

				if ((atv_flag&ATV_INIT_DEV_M_MASK) == ATV_INIT_DEV_M_HIGH) {
					AtvChangeDeviation(sound_std, FM_BW_HIGH);
				} else if ((atv_flag&ATV_INIT_DEV_M_MASK) == ATV_INIT_DEV_M_SUPER) {
					AtvChangeDeviation(sound_std, FM_BW_SUPER);
				} else {
					AtvChangeDeviation(sound_std, FM_BW_NORMAL);
				}

				Audio_AtvSetSoundSelect(ATV_SOUND_SEL_STEREO_A);
				//USER:Peter_Lin DATE:2010/12/16
				// add tv volume compensate
				
				//	AtvSetVolumeCompensate(g_TVM_BTSC_VolumeCompensate_Normal);
				


				break;
			case ATV_SOUND_STD_AM_MONO:

				AtvChangeDeviation(sound_std, FM_BW_NORMAL);
				Audio_AtvSetSoundSelect(ATV_SOUND_SEL_FMAM);
				//USER:Peter_Lin DATE:2010/12/16
				// add tv volume compensate
				
				//	AtvSetVolumeCompensate(g_TVM_AM_Mono_VolumeCompensate_Normal);
				



				break;
			case ATV_SOUND_STD_EIAJ:
				//USER:Peter_Lin DATE:2010/12/16
				// add tv volume compensate
				

				if ((atv_flag&ATV_INIT_DEV_M_MASK) == ATV_INIT_DEV_M_HIGH) {
					AtvChangeDeviation(sound_std, FM_BW_HIGH);
				} else if ((atv_flag&ATV_INIT_DEV_M_MASK) == ATV_INIT_DEV_M_SUPER) {
					AtvChangeDeviation(sound_std, FM_BW_SUPER);
				} else {
					AtvChangeDeviation(sound_std, FM_BW_NORMAL);
				}

				Audio_AtvSetSoundSelect(ATV_SOUND_SEL_FMAM);
				//	AtvSetVolumeCompensate(g_TVM_EIAJ_VolumeCompensate_Normal);
				//ioctl(audio_fd, ATV_CMD_SET_CLOCK, AIO_PATH_SRC_ATV);

				break;
				
			default:
				AtvSetDeviation(sound_std, FM_BW_NORMAL);
				;
				Audio_AtvSetSoundSelect(ATV_SOUND_SEL_FMAM);

				break;
			}

		}
		/*
		else {
		    // Canal+ application, do not modify clock/PLL setting
		}
		*/

		// TODO: check the correction of the result of F/W Scanning mechanism
		//	if((atv_flag & ATV_INIT_FREQ_SHIFT_MASK) != ATV_INIT_FREQ_SHIFT_DISABLE) {
		//		AtvFwScanInit(ATV_ENABLE);
		//	}else {
		//		AtvFwScanInit(ATV_DISABLE);
		//	}

		//	AtvSetMute(ATV_DISABLE, ATV_CH_ID_L | ATV_CH_ID_R);



		g_ChangeStdStatus = CHANGESTDSTATUS_FIRST_TIME; // FOR all signal

		// update
		AtvSetSoundStd(sound_std);

	}

}

void AtvStdChangeProcess(void)
{
	//USER:Peter_Lin DATE:2010/12/30
	//// speed up to detect no signal method

#define NORMALNOSIGNALDECTEDT (3)

	//USER:Peter_Lin DATE:2012/07/02
	// speed up standard change
	
#define NORMALDECTEDTHD (10)
	
#define NORMALDECTEDTHD_high (30)	// NICAM STD change to A2 case
#define NORMALDECTEDTHD_super (60)	// NICAM/A2 STD change to MONO case
#define HIGHDECTEDTHD (10)

#define STDUNSTABLENORMALCNT (NORMALDECTEDTHD * 3)
#define STDUNSTABLEHIGHCNT (HIGHDECTEDTHD * 3)

#define NOVIDEOSIGNALCNT (15)
#define VIDEOSIGNALSPEEDUPCNT (NOVIDEOSIGNALCNT- 10)
	//USER:Peter_Lin DATE:2010/12/30
	//// speed up to detect no signal method
	
#define NOAUDIOSIGNALCNT (1)

	static uint32_t noVideoSignalCnt = 0;
	static int32_t stdDetNum = 0;
	static uint32_t detectType = 0; // normal

	static uint32_t stdnormalFailed = 0;
	static uint32_t detectStd_normal = ATV_SOUND_STD_UNKNOWN;
	static uint32_t prevdetectStd_normal = ATV_SOUND_STD_UNKNOWN;
	static uint32_t detectStd_normal_cunt = 0;

	static uint32_t prevdetectStd_high = ATV_SOUND_STD_UNKNOWN;
	static uint32_t detectStd_highl_cunt = 0;
	static uint32_t detectStd_high = ATV_SOUND_STD_UNKNOWN;
	static uint32_t detectStd_countTH = NORMALDECTEDTHD;

	uint32_t swScanMainTone;
	#ifndef ATV_NO_VIDEO
	uint32_t videospeedupcnt = 0;
	#endif
	uint32_t newStd, setStdFlag;
	//USER:Peter_Lin DATE:2010/12/30
	//// speed up to detect no signal method
	
	uint32_t noSignalCnt;

	//USER:Peter_Lin DATE:2010/12/16
	// modify current std reference
	//	audio_msd_result_RBUS			msd_result;

	//	audio_bw_threshold_RBUS bw_threshold;
	audio_interrupt_status_RBUS interrupt_status;
	static uint32_t stdlowthreadflag = 0;
	audio_msd_crtl_word_RBUS msd_crtl_word;

	//audio_nicam_decode_status_RBUS			nicam_decode_status;	// Clayton, 2012/12/21
	msd_crtl_word.regValue = AIO_ReadRegister(AUDIO_msd_crtl_word_reg);

	g_StdDataIsUpdate = 0;

	newStd = g_UserStd;
	if (g_SetStdFlag == 1) {
		//	get_system_time(&g_firstStd);
		g_SetStdFlag = 0;
		setStdFlag = 1;
		g_TVAudioReady = 0;
		g_TVAudioNosignalPrev = 0;
		g_TVAudioNosignal = 0;
		noVideoSignalCnt = 0;
	} else {
		setStdFlag = 0;

#ifndef ATV_NO_VIDEO
#if 0
		//USER:Peter_Lin DATE:2010/12/29
		//// add detect no signal method
		
		//	if( (g_AudioTVControlFlag & ENABLE_NO_SIGNAL_DETECT_USE_AUDIO_MASK) ==  ENABLE_NO_SIGNAL_DETECT_USE_AUDIO) //#if 0 // use audio to detected
		{
			if( (g_CurrentHWDetectUpdate == 1) && (g_CurrentHWDetectStd == ATV_SOUND_STD_UNKNOWN) ){

				if(noVideoSignalCnt < NOAUDIOSIGNALCNT ){
					alog_info("audio check %x %x %x \n", noVideoSignalCnt, g_CurrentHWDetectStd, g_CurrentHWDetectUpdate);
					noVideoSignalCnt++;
				}
			} else {
				if( (g_CurrentHWDetectUpdate == 1) && (g_CurrentHWDetectStd != ATV_SOUND_STD_UNKNOWN) ){
					if(noVideoSignalCnt > 0 ){
						alog_info("audio check %x %x %x \n", noVideoSignalCnt, g_CurrentHWDetectStd, g_CurrentHWDetectUpdate);
						noVideoSignalCnt--;
					}
				}
			}
			g_CurrentHWDetectUpdate = 0;

			noSignalCnt = NOAUDIOSIGNALCNT;
			videospeedupcnt = (0);
		}
		//#if 0 // use audio to detected
		//	else
#else
		{
			if ((drvif_module_vdc_CheckHVisLocked() == 1) || (g_NoSignalNeedToMuteFlag == 0)) { //true_detect=0 && g_CurrentStd=mono && hw_detected_std = nicam
				if (noVideoSignalCnt > 0) {
					alog_info("video check %x\n", noVideoSignalCnt);
					noVideoSignalCnt--;
				}
			} else {
				if ((noVideoSignalCnt < NOVIDEOSIGNALCNT) && (g_NoSignalNeedToMuteFlag == 1)) {
					alog_info("video check %x\n", noVideoSignalCnt);
					noVideoSignalCnt++;
				}
			}

			noSignalCnt = NOVIDEOSIGNALCNT;
			videospeedupcnt = (VIDEOSIGNALSPEEDUPCNT);
		}
#endif // if 0
		

		//USER:Peter_Lin DATE:2010/12/29
		//// add detect no signal method
		if (noVideoSignalCnt >= noSignalCnt) {
			g_TVAudioNosignal = 1;
			//	ATV_LOG( "no signal \n");
		} else {
			if (g_TVAudioNosignal == 1) { //nicam && sound select == 0, to doFrank
						      // no signal -> signal speed up
				if (noVideoSignalCnt <= videospeedupcnt) {
					g_TVAudioNosignal = 0;
					noVideoSignalCnt = 0;
				}
			} else {
				if (noVideoSignalCnt == 0)
					g_TVAudioNosignal = 0;
			}
		}

#else //#ifndef ATV_NO_VIDEO
		g_TVAudioNosignal = 0;
		noSignalCnt = 0;

#endif //#ifndef ATV_NO_VIDEO

		// if no signal -> singal
		if ((g_TVAudioNosignalPrev == 1) && (g_TVAudioNosignal == 0)) {
			if ((g_AudioTVControlFlag&ENABLE_NO_SIGNAL_RESTART) ==  ENABLE_NO_SIGNAL_RESTART) {
				alog_info("restart \n");
				newStd = g_CurrentStd;
				setStdFlag = 1;
			}
		}
	}

	if ((g_AudioTVControlFlag&ENABLE_NO_SIGNAL_RESTART) ==  ENABLE_NO_SIGNAL_RESTART) {
		if ((g_TVAudioNosignalPrev == 0) && (g_TVAudioNosignal == 1)) {
			alog_info("no tv signal \n");
			AtvSetMute(ATV_ENABLE);
		}
	}

	g_TVAudioNosignalPrev = g_TVAudioNosignal;

	if (setStdFlag == 1) {
		detectStd_high = newStd;
		detectStd_normal = newStd;
		prevdetectStd_normal = detectStd_normal;
		// next time
		detectType = 1;
		stdDetNum = 0;
		stdlowthreadflag = 0;
		AtvSwitchScanTyep(1);
	} else { // hw detected
#if 1
		if (detectType == 0) {
			// scan main tone
			return;
		} else if (detectType == 1) {
			if (stdDetNum == 0) {
				msd_crtl_word.msd_debounce_cnt = 1; // speed up
				AIO_WriteRegister(AUDIO_msd_crtl_word_reg, msd_crtl_word.regValue); //

				stdDetNum = 1;
				stdnormalFailed = 0;
				detectStd_normal_cunt = 0;

				AtvResetDefaultBW();

				AtvSetHwDetecteMode(ATV_HW_CARRIER_SHIFT_BANDWIDTH);
				//	CleanOldStd();
				if (stdlowthreadflag == 1 && ((g_AudioTVControlFlag&ENABLE_MAINTONE_THRESHOLD_ADJUST) == ENABLE_MAINTONE_THRESHOLD_ADJUST))
					AtvAdjuseMainCarrierThreshold(g_AudioTVLOWTHDMainToneThredhold_High, g_AudioTVLOWTHDNormalMainToneThredhold_Low);
				else
					AtvAdjuseMainCarrierThreshold(g_AudioTVNormalMainToneThredhold_High, g_AudioTVNormalMainToneThredhold_Low);

				//USER:Peter_Lin DATE:2010/12/20
				// add clean interupt status initial value
				
				interrupt_status.regValue = 0;
				
				interrupt_status.int_msd_decision_done = 1; // only clean msd
				AIO_WriteRegister(AUDIO_interrupt_status_reg, interrupt_status.regValue); // clean int

			} else {
				interrupt_status.regValue = AIO_ReadRegister(AUDIO_interrupt_status_reg);
				if (interrupt_status.int_msd_decision_done == 1) {
					stdDetNum++;

					//USER:Peter_Lin DATE:2010/12/20
					// add clean interupt status initial value
					
					interrupt_status.regValue = 0;
					
					interrupt_status.int_msd_decision_done = 1; // only clean msd
					AIO_WriteRegister(AUDIO_interrupt_status_reg, interrupt_status.regValue); // clean int
				} else
					return;

				detectStd_normal = AtvGetHWStd();
				alog_debug("detectStd_normal std = %x\n", detectStd_normal);

				if ((detectStd_normal == prevdetectStd_normal)) {
					detectStd_normal_cunt++;
				} else {
					detectStd_normal_cunt = 0;
				}

				if ((detectStd_normal != (uint32_t)g_CurrentStd) && (g_TVAudioNosignal == 0)) {
					if ((g_AudioTVPrintFlag&ATV_PRINT_FLAG_ENABLE_NORMAL_PRINT) == ATV_PRINT_FLAG_ENABLE_NORMAL_PRINT)
						alog_info(" normal 0x%04x , 0x%04x \n", detectStd_normal, detectStd_normal_cunt);
				}

				// Clayton 2014/2/13
				// patch for unstable NICAM signal
#if 0 //Frank disable
				if(((g_CurrentStd == ATV_SOUND_STD_NICAM_BG) && (detectStd_normal == ATV_SOUND_STD_A2_BG)) || ((g_CurrentStd == ATV_SOUND_STD_NICAM_DK) && (detectStd_normal == ATV_SOUND_STD_A2_DK3))){
					detectStd_countTH = NORMALDECTEDTHD_super;
					//DRV_MSG_NEW(LOGGER_INFO," Super debounce count1, NICAM to A2\n");
				} else if((((g_CurrentStd == ATV_SOUND_STD_NICAM_BG) || (g_CurrentStd == ATV_SOUND_STD_A2_BG)) && (detectStd_normal == ATV_SOUND_STD_BG_MONO)) || (((g_CurrentStd == ATV_SOUND_STD_NICAM_DK) || (g_CurrentStd == ATV_SOUND_STD_A2_DK1) || (g_CurrentStd == ATV_SOUND_STD_A2_DK2) || (g_CurrentStd == ATV_SOUND_STD_A2_DK3)) && (detectStd_normal == ATV_SOUND_STD_DK_MONO))){
					detectStd_countTH = NORMALDECTEDTHD_super;
					//DRV_MSG_NEW(LOGGER_INFO," Super debounce count1\n");
				}
				// Clayton 2014/7/4
				// patch for India, BG_MONO/BG_A2 to fake BG_NICAM
				
				else if(((g_CurrentStd == ATV_SOUND_STD_BG_MONO) || (g_CurrentStd == ATV_SOUND_STD_A2_BG)) && (detectStd_normal == ATV_SOUND_STD_NICAM_BG)){
					detectStd_countTH = NORMALDECTEDTHD_super;
				} else {
					detectStd_countTH = NORMALDECTEDTHD;
					//DRV_MSG_NEW(LOGGER_INFO," Normal debounce count1\n");
				}
#else
				alog_debug("1 g_CurrentHWDetectStd, detectStd_normal= %x %x\n", g_CurrentHWDetectStd, detectStd_normal);
				if (g_TVAudioReady == 1 && g_CurrentHWDetectStd != ATV_SOUND_STD_UNKNOWN) {
					if ((g_CurrentHWDetectStd == ATV_SOUND_STD_NICAM_BG && detectStd_normal == ATV_SOUND_STD_BG_MONO) ||
					    (g_CurrentHWDetectStd == ATV_SOUND_STD_BG_MONO  && detectStd_normal == ATV_SOUND_STD_NICAM_BG)
					   ) {
						detectStd_countTH = NORMALDECTEDTHD_super;
					} else {
						detectStd_countTH = NORMALDECTEDTHD;
					}
				}
#endif
				if (detectStd_normal_cunt >= detectStd_countTH) {
					if ((detectStd_normal != ATV_SOUND_STD_UNKNOWN) && (AtvIsMonoSystem(detectStd_normal) == 1)
#ifdef NO_USE_HIGHBW
					    && ((AtvIsUnNormalSignal(g_Std_msd_status.regValue) == 1))
#endif //#ifdef NO_USE_HIGHBW
					   ) {
						detectType = 2; // tyr high
					} else {
						detectType = 3; // unknow or A2, nicam
						detectStd_high = detectStd_normal;
						alog_debug("go to detectType 3\n");
					}
					stdDetNum = 0;
				}

				//USER:Peter_Lin DATE:2010/12/30
				//// speed up to detect no signal method

				// no audio std speed up
				if ((detectStd_normal == ATV_SOUND_STD_UNKNOWN) && (detectStd_normal_cunt >= NORMALNOSIGNALDECTEDT)) {
					{
						detectType = 3; // unknow case
						detectStd_high = detectStd_normal;
						alog_debug("unknow case\n");
					}
					stdDetNum = 0;
				}

				prevdetectStd_normal = detectStd_normal;

				if (stdDetNum > (STDUNSTABLENORMALCNT + detectStd_countTH)) { // main is strong , sub is weak
					alog_info(" unstable normal \n");
					detectType = 2; // try normal
					stdDetNum = 0;
					stdnormalFailed = 1;
					return;
				}
			}
			return;
		} else if (detectType == 2) {
			if (stdDetNum == 0) {
				stdDetNum = 1;

#ifndef NO_USE_HIGHBW
				bw_threshold.bw_dev_thresh_hd = g_AudioTVHighBWThredhold; // default
				bw_threshold.bw_dev_thresh = g_AudioTVHighBWThredhold;
				AIO_WriteRegister(AUDIO_bw_threshold_reg, bw_threshold.regValue);
#else
				AtvSetHwDetecteMode(ATV_HW_CARRIER_NO_SHIFT_NO_BANDWIDTH);
#endif
				prevdetectStd_high = ATV_SOUND_STD_UNKNOWN;
				detectStd_highl_cunt = 0;
				if (stdlowthreadflag == 1 && ((g_AudioTVControlFlag&ENABLE_MAINTONE_THRESHOLD_ADJUST) == ENABLE_MAINTONE_THRESHOLD_ADJUST))
					AtvAdjuseMainCarrierThreshold(ATV_LOW_TH_THRESHOLD_HIGH, ATV_LOW_TH_THRESHOLD_LOW);
				else
					AtvAdjuseMainCarrierThreshold(ATV_STD_THRESHOLD_HIGH, ATV_STD_THRESHOLD_LOW);

				//USER:Peter_Lin DATE:2010/12/20
				// add clean interupt status initial value
				
				interrupt_status.regValue = 0;
				
				interrupt_status.int_msd_decision_done = 1; // only clean msd
				AIO_WriteRegister(AUDIO_interrupt_status_reg, interrupt_status.regValue); // clean int
			} else {
				interrupt_status.regValue = AIO_ReadRegister(AUDIO_interrupt_status_reg);
				if (interrupt_status.int_msd_decision_done == 1) {
					stdDetNum++;
					//USER:Peter_Lin DATE:2010/12/20
					// add clean interupt status initial value
					
					interrupt_status.regValue = 0;
					
					interrupt_status.int_msd_decision_done = 1; // only clean msd
					AIO_WriteRegister(AUDIO_interrupt_status_reg, interrupt_status.regValue); // clean int
				} else
					return;

				//	if(stdDetNum >= (msd_crtl_word.msd_debounce_cnt +3) )
				{
					detectStd_high = AtvGetHWStd();
					alog_debug("detectStd_high = %x\n", detectStd_high);
					if ((detectStd_high != (uint32_t)g_CurrentStd) && (g_TVAudioNosignal == 0)) {
						if ((g_AudioTVPrintFlag&ATV_PRINT_FLAG_ENABLE_NORMAL_PRINT) == ATV_PRINT_FLAG_ENABLE_NORMAL_PRINT)
							alog_info(" high %x , %x  %x \n", detectStd_high, detectStd_highl_cunt, stdDetNum);
					}

					if ((detectStd_high == ATV_SOUND_STD_UNKNOWN) && (g_TVAudioNosignal == 0)) {
						detectType = 1; // try normal
						stdDetNum = 0;
						alog_info(" high3 %x , %x  %x \n", detectStd_high, detectStd_highl_cunt, stdDetNum);
						return;
					}

					if (stdnormalFailed == 1) {
						// normal is failed
						detectStd_normal = detectStd_high;
					}

					if (AtvGetMainSystem(detectStd_normal) != AtvGetMainSystem(detectStd_high)) { // too noisy
						detectType = 1; // try normal
						stdDetNum = 0;
						return;
					}

					if (detectStd_high == prevdetectStd_high) {
						detectStd_highl_cunt++;
					} else {
						detectStd_highl_cunt = 0;
					}

					prevdetectStd_high = detectStd_high;

					// Clayton 2014/2/13
					// patch for unstable NICAM signal
					
#if 0 //Frank disable
					if(((g_CurrentStd == ATV_SOUND_STD_NICAM_BG) && (detectStd_normal == ATV_SOUND_STD_A2_BG)) || ((g_CurrentStd == ATV_SOUND_STD_NICAM_DK) && (detectStd_normal == ATV_SOUND_STD_A2_DK3))){
						detectStd_countTH = NORMALDECTEDTHD_super;
						//DRV_MSG_NEW(LOGGER_INFO," Super debounce count2, NICAM to A2\n");
					} else if((((g_CurrentStd == ATV_SOUND_STD_NICAM_BG) || (g_CurrentStd == ATV_SOUND_STD_A2_BG)) && (detectStd_normal == ATV_SOUND_STD_BG_MONO)) || (((g_CurrentStd == ATV_SOUND_STD_NICAM_DK) || (g_CurrentStd == ATV_SOUND_STD_A2_DK1) || (g_CurrentStd == ATV_SOUND_STD_A2_DK2) || (g_CurrentStd == ATV_SOUND_STD_A2_DK3)) && (detectStd_normal == ATV_SOUND_STD_DK_MONO))){
						detectStd_countTH = NORMALDECTEDTHD_super;
						//DRV_MSG_NEW(LOGGER_INFO," Super debounce count2\n");
					}
					// Clayton 2014/7/4
					// patch for India, BG_MONO/BG_A2 to fake BG_NICAM
					
					else if(((g_CurrentStd == ATV_SOUND_STD_BG_MONO) || (g_CurrentStd == ATV_SOUND_STD_A2_BG)) && (detectStd_normal == ATV_SOUND_STD_NICAM_BG)){
						detectStd_countTH = NORMALDECTEDTHD_super;
					} else {
						detectStd_countTH = NORMALDECTEDTHD;
						//DRV_MSG_NEW(LOGGER_INFO," Normal debounce count2\n");
					}
#else
					alog_debug("2 g_CurrentHWDetectStd, detectStd_normal= %x %x\n", g_CurrentHWDetectStd, detectStd_normal);
					if (g_TVAudioReady == 1 && g_CurrentHWDetectStd != ATV_SOUND_STD_UNKNOWN) {
						if ((g_CurrentHWDetectStd == ATV_SOUND_STD_NICAM_BG && detectStd_normal == ATV_SOUND_STD_BG_MONO) ||
						    (g_CurrentHWDetectStd == ATV_SOUND_STD_BG_MONO && detectStd_normal == ATV_SOUND_STD_NICAM_BG)) {
							detectStd_countTH = NORMALDECTEDTHD_super;
						} else {
							detectStd_countTH = NORMALDECTEDTHD;
						}
					}
#endif
					if (stdnormalFailed == 1) {
						// noraml is failed
						if (detectStd_highl_cunt >= detectStd_countTH) {
							detectType = 3;
							stdDetNum = 0;
							alog_debug("high go to detectType3\n");
						}

						if (stdDetNum > (STDUNSTABLEHIGHCNT + detectStd_countTH)) {                                    //+- 120kHz Old...+/-100kHz
							alog_info(" unstable h exit 2\n");
							detectType = 1; // try normal
							stdDetNum = 0;
							return;
						}
					} else {
						if (detectStd_highl_cunt >= detectStd_countTH) {
							detectType = 3;
							stdDetNum = 0;
						}

						if (stdDetNum > (STDUNSTABLEHIGHCNT + detectStd_countTH)) {          //+- 120kHz ...old +-100K
							alog_info(" unstable h exit \n");
							detectType = 1; // try normal
							stdDetNum = 0;
							return;
						}
					}
				}
			}
			return;
		} else if (detectType == 3) {
			newStd = detectStd_normal;
			if (detectStd_high != detectStd_normal) {
				if ((detectStd_high != ATV_SOUND_STD_UNKNOWN) && (detectStd_normal != ATV_SOUND_STD_UNKNOWN)) {
#ifndef NO_USE_HIGHBW
					// over mod case
					if ((AtvIsMonoSystem(detectStd_normal) == 1) &&  (AtvIsNicamSystem((ATV_SOUND_STD)detectStd_high) == 1))
#endif
					{
						newStd = detectStd_high;
						alog_debug("3 newStd = %x\n", newStd);
					}
				}
			}

			//USER:Peter_Lin DATE:2012/07/02
			// speed up standard change
			if ((g_AudioTVPrintFlag&ATV_PRINT_FLAG_ENABLE_SW_SCAN) == ATV_PRINT_FLAG_ENABLE_SW_SCAN) // no signal  need to speed up
				detectType = 4;
			else
				detectType = 1;
			stdDetNum = 0;

			if (newStd != (uint32_t)g_CurrentStd) {
				if ((g_AudioTVPrintFlag&ATV_PRINT_FLAG_ENABLE_NORMAL_PRINT) == ATV_PRINT_FLAG_ENABLE_NORMAL_PRINT)
					alog_info("finial std %x  \n", newStd); // remove print
			}

			if ((g_AudioTVPrintFlag&ATV_PRINT_FLAG_ENABLE_NORMAL_PRINT) == ATV_PRINT_FLAG_ENABLE_NORMAL_PRINT)
				alog_info("finial std %x %x  \n", newStd, g_CurrentStd); // remove print

			//USER:Peter_Lin DATE:2010/12/29
			//// add detect no signal method

			g_CurrentHWDetectUpdate = 1;
			g_CurrentHWDetectStd = newStd;
			// print log too often, level down log level.
			alog_debug("Get debounce STD %x\n", g_CurrentHWDetectStd);

		} else if (detectType == 4) {
			//USER:Peter_Lin DATE:2010/12/16
			// modify current std reference
			//	msd_result.regValue = AIO_ReadRegister(AUDIO_msd_result_reg);
			if (stdDetNum == 0) {
				stdDetNum++;
				AtvSwitchScanTyep(0);
				//USER:Peter_Lin DATE:2010/12/16
				// modify current std reference
				
				AtvGetSWFreqShift(g_CurrentStd, 1, 0, NULL);

				//USER:Peter_Lin DATE:2010/12/20
				// add clean interupt status initial value
				interrupt_status.regValue = 0;
				interrupt_status.int_msd_fw_scan_done = 1; // only clean msd
				AIO_WriteRegister(AUDIO_interrupt_status_reg, interrupt_status.regValue); // clean int
			} else {
				interrupt_status.regValue = AIO_ReadRegister(AUDIO_interrupt_status_reg);
				if (interrupt_status.int_msd_fw_scan_done == 1) {
					stdDetNum++;
					swScanMainTone = 0xFFFF; // max value
								 //USER:Peter_Lin DATE:2010/12/16
								 // modify current std reference
					AtvGetSWFreqShift(g_CurrentStd, 0, 0, &swScanMainTone);

					if ((swScanMainTone < g_AudioTVNormalMainToneThredhold_Low) && ((g_AudioTVPrintFlag&ATV_PRINT_FLAG_ENABLE_SW_SCAN) != ATV_PRINT_FLAG_ENABLE_SW_SCAN)) {    //+- 185K  ...old +-150K
						alog_info("skip scan  %x  \n", swScanMainTone);
						// signal is disapper skip sw scan
						detectType = 1;
						stdDetNum = 0;
						AtvSwitchScanTyep(1);
					}
					//USER:Peter_Lin DATE:2010/12/20
					// add clean interupt status initial value
					interrupt_status.regValue = 0;
					interrupt_status.int_msd_fw_scan_done = 1; // only clean msd
					AIO_WriteRegister(AUDIO_interrupt_status_reg, interrupt_status.regValue); // clean int
				}

				if (stdDetNum >= (int32_t)(((sizeof(SignalFreqShfitDetectTable) / sizeof(SignalFreqShfitDetectTable[0])) / 5) + 1)) {
					detectType = 1;
					stdDetNum = 0;
					AtvSwitchScanTyep(1);
				}
			}
			return;
		}

		// if newStd  is from set , new std maybe != g_CurrentHWDetectStd
		if ((g_CurrentStd == (int32_t)newStd) ||  (g_isAutoDetect != ATV_SOUND_STD_AUTO))
			return;

		if (AtvCheckIfStdChangeValid(newStd) == 0) {
			alog_info("AtvCheckIfStdChangeValid return %d\n", newStd);
			return;
		}

		/* // Move into GetHwStd()
		// Clayton, 2012/12/21
		// fw patch for FM over-modulation case: old STD= BG NICAM but error detect as new STD = BG MONO
		    nicam_decode_status.regValue = AIO_ReadRegister(AUDIO_nicam_decode_status_reg);
		    if((g_CurrentStd == ATV_SOUND_STD_NICAM_BG) && (newStd == ATV_SOUND_STD_BG_MONO) && (nicam_decode_status.true_detect == 1))
		    {
			alog_info("Fake BG MONO, keep BG NICAM\n");
			return;
		    }
		//	[end]
		*/

		//USER:Peter_Lin DATE:2012/07/02
		// nicam dont change to fm mono will cause  fm mono switch to nicam is still at weak signal state (MTS issue)
		
#if 0
		// skip nicam -> mono switch
		if(  (AtvIsNicamSystem((ATV_SOUND_STD)g_CurrentStd) == 1) && (AtvIsMonoSystem(newStd) == 1) && (AtvGetMainSystem((ATV_SOUND_STD)g_CurrentStd) == AtvGetMainSystem(newStd)) ){
			if( (g_AudioTVPrintFlag & ATV_PRINT_FLAG_ENABLE_NORMAL_PRINT) == ATV_PRINT_FLAG_ENABLE_NORMAL_PRINT)
			ATV_LOG( "skip std change  %x  %x \n", g_CurrentStd, newStd);
			return;
		}

		// skip A2  -> mono switch
		if(  (AtvIsA2System((ATV_SOUND_STD)g_CurrentStd) == 1) && (AtvIsMonoSystem(newStd) == 1) && (AtvGetMainSystem((ATV_SOUND_STD) g_CurrentStd) == AtvGetMainSystem(newStd)) ){
			if( (g_AudioTVPrintFlag & ATV_PRINT_FLAG_ENABLE_NORMAL_PRINT) == ATV_PRINT_FLAG_ENABLE_NORMAL_PRINT)
			ATV_LOG( "skip std change  %x  %x \n", g_CurrentStd, newStd);
			return;
		}
#endif
		if(g_user_config == AUDIO_USER_CONFIG_TV002)
		{
		// skip A2  -> mono switch
		// if(  (AtvIsA2System((ATV_SOUND_STD)g_CurrentStd) == 1) && (AtvIsMonoSystem(newStd) == 1) && (AtvGetMainSystem((ATV_SOUND_STD) g_CurrentStd) == AtvGetMainSystem(newStd)) )
		//  {
		//  if( (g_AudioTVPrintFlag & ATV_PRINT_FLAG_ENABLE_NORMAL_PRINT) == ATV_PRINT_FLAG_ENABLE_NORMAL_PRINT)
		//  ATV_LOG( "skip std change  %x  %x \n", g_CurrentStd, newStd);
		// printf( "skip std change  %x  %x \n", g_CurrentStd, newStd);
		//  return ;
		// }
		}


		if ((g_CurrentStd != (int32_t)newStd)) {
			if (audioStatusChanageCallBack != NULL)
				audioStatusChanageCallBack(ATV_STATUS_DETECTED_STDANDARD_CHANGE);

			if(g_user_config == AUDIO_USER_CONFIG_TV002)
			{
			// Clayton 2014/6/26
			// The patch of STD change without mute under the specific std case
			/*
			
				nicam_decode_status.regValue = AIO_ReadRegister(AUDIO_nicam_decode_status_reg);
				msd_crtl_word.regValue = AIO_ReadRegister(AUDIO_msd_crtl_word_reg);
			// 1. BG MONO --> BG NICAM or BG A2
				if((g_CurrentStd == ATV_SOUND_STD_BG_MONO) && (((int32_t)newStd == ATV_SOUND_STD_A2_BG) || ((int32_t)newStd == ATV_SOUND_STD_NICAM_BG)))
				{
				g_StdchangeNoMuteFlag = 1;
				ATV_LOG( "HW detect STD change from BG MONO to BG_A2/BG_NICAM, so don't mute\n");
				}
			// 2. DK MONO --> DK NICAM or DK A2
				else if((g_CurrentStd == ATV_SOUND_STD_DK_MONO) && (((int32_t)newStd == ATV_SOUND_STD_A2_DK1) || ((int32_t)newStd == ATV_SOUND_STD_A2_DK2) || ((int32_t)newStd == ATV_SOUND_STD_A2_DK3) || ((int32_t)newStd == ATV_SOUND_STD_NICAM_DK)))
				{
				g_StdchangeNoMuteFlag = 1;
				ATV_LOG( "HW detect STD change from DK MONO to DK_A2/DK_NICAM, so don't mute\n");
				}
			// 3. DK NICAM with soundselect = FM MONO --> DK MONO or DK A2
				else if((g_CurrentStd == ATV_SOUND_STD_NICAM_DK) && ((msd_crtl_word.sound_select == ATV_SOUND_SEL_FMAM) || (nicam_decode_status.true_detect == 0)) && (((int32_t)newStd == ATV_SOUND_STD_A2_DK1) || ((int32_t)newStd == ATV_SOUND_STD_A2_DK2) || ((int32_t)newStd == ATV_SOUND_STD_A2_DK3) || ((int32_t)newStd == ATV_SOUND_STD_DK_MONO)))
				{
				g_StdchangeNoMuteFlag = 1;
				ATV_LOG( "HW detect STD change from DK NICAM with sound select = FM MONO to DK_A2/DK_MONO, so don't mute\n");
				}
			// 4. BG NICAM with soundselect = FM MONO --> BG MONO or BG A2
				else if((g_CurrentStd == ATV_SOUND_STD_NICAM_BG) && ((msd_crtl_word.sound_select == ATV_SOUND_SEL_FMAM) || (nicam_decode_status.true_detect == 0)) && (((int32_t)newStd == ATV_SOUND_STD_A2_BG) || ((int32_t)newStd == ATV_SOUND_STD_BG_MONO)))
				{
				g_StdchangeNoMuteFlag = 1;
				ATV_LOG( "HW detect STD change from BG NICAM with sound select = FM MONO to BG_A2/BG_MONO, so don't mute\n");
				}
			// 5. BG A2 with soundselect = FM MONO --> BG MONO or BG NICAM
				else if((g_CurrentStd == ATV_SOUND_STD_A2_BG) && (msd_crtl_word.sound_select == ATV_SOUND_SEL_FMAM) && (((int32_t)newStd == ATV_SOUND_STD_NICAM_BG) || ((int32_t)newStd == ATV_SOUND_STD_BG_MONO)))
				{
				g_StdchangeNoMuteFlag = 1;
				ATV_LOG( "HW detect STD change from BG A2 with sound select = MONO to BG_NICAM/BG_MONO, so don't mute\n");
				}
			// 6. DK A2 with soundselect = FM MONO --> DK MONO or DK NICAM
				else if(((g_CurrentStd == ATV_SOUND_STD_A2_DK1) || (g_CurrentStd == ATV_SOUND_STD_A2_DK2) || (g_CurrentStd == ATV_SOUND_STD_A2_DK3)) && (msd_crtl_word.sound_select == ATV_SOUND_SEL_FMAM) && (((int32_t)newStd == ATV_SOUND_STD_NICAM_DK) || ((int32_t)newStd == ATV_SOUND_STD_DK_MONO)))
				{
				g_StdchangeNoMuteFlag = 1;
				ATV_LOG( "HW detect STD change from DK A2 with sound select = MONO to DK_NICAM/DK_MONO, so don't mute\n");
				}
			*/
			}
		}

		//USER:Peter_Lin DATE:2010/12/16
		// modify current std reference
		
		//	msd_result.regValue = AIO_ReadRegister(AUDIO_msd_result_reg);
		

#else
		return;
#endif


	}

	alog_info("std change \n");

	//	if(g_monitorNicamFlag == 1)
	//		drvif_audio_enable_monitor_nicam(0, NULL);

	if(g_isAutoDetect == ATV_SOUND_STD_AUTO)
	{
	//	ROS_ENTER_CRITICAL();
	if (g_StdchangeNoMuteFlag == 0)      // if g_StdchangeNoMuteFlag=0,need to mute but if g_StdchangeNoMuteFlag=1 is special case, doesn't mute
		AtvSetMute(ATV_ENABLE);

	if (setStdFlag == 1) {
		if (audioStatusChanageCallBack != NULL)
			audioStatusChanageCallBack(ATV_STATUS_CHANGE_CHANNEL_STDANDARD_CHANGE);

	} else {
		ATV_SOUND_STD_MAIN_SYSTEM mainStd = 0;
		
		AtvChangeStdCleanData();
		mainStd = (ATV_SOUND_STD_MAIN_SYSTEM)AtvGetMainSystem(newStd);
		Audio_AtvSetSoundStd(mainStd, (ATV_SOUND_STD)newStd); // replace AtvSetNewSoundStd()
								      //AtvSetNewSoundStd((ATV_SOUND_STD)newStd);
								      //g_CurrentStd = newStd; //already include in Audio_AtvSetSoundStd()
	}

	/*
	//	drv_audio_set_backendplay(AUD_DISABLE);
	    //AtvSetNewSoundStd((ATV_SOUND_STD)newStd);
	    //g_StdchangeNoMuteFlag = 0;
	    //g_CurrentStd = newStd;
	// [Clayton] 2014/7/4
	// Add this new callback msg for system to restore new STD
	    if(setStdFlag == 0)
	    {
	    if(audioStatusChanageCallBack != NULL)
		audioStatusChanageCallBack(ATV_STATUS_DETECTED_STDANDARD_CHANGE_READY);
	    }
	*/

	//	ROS_EXIT_CRITICAL();
	}

}

uint32_t AtvIsBTSCSystem(ATV_SOUND_STD std)
{

	uint32_t isBTSC;

	switch (std) {
	default :
		isBTSC = 0;
		break;
	case ATV_SOUND_STD_BTSC:

		isBTSC = 1;
		break;

	}

	return isBTSC;

}

uint32_t AtvIsRFLowLeave(void)
{
	// get RF AGC

	uint32_t returnvalue;


#ifndef ATV_NO_VIDEO

	if (drvif_module_vdc_CheckHVisLocked() == 1) {
		returnvalue = drvif_ifd_get_signal_strength(0);
	} else {
		// no signal
		returnvalue = 0; // assume good
	}

#else
	returnvalue = 0; // assume good

#endif


	if (returnvalue == 2) {                        //+-60K  ...old +-50K
		if (g_lowRFDebounce > LOWRFDEBOUNCEMIN)
			g_lowRFDebounce--;

	} else {
		if (g_lowRFDebounce < LOWRFDEBOUNCEMAX)
			g_lowRFDebounce++;
	}

	if (g_lowRFDebounce <= LOWRFDEBOUNCEMIN)
		g_lowRFFlag = 1;
	else
		g_lowRFFlag = 0;

	return g_lowRFFlag == 1;


}

uint32_t AtvIsPSLowLeave(void)
{
	// get RF AGC

#define LOWPSTHRESHOLD (0x30)

	audio_analog_pga_RBUS analog_pga;

	analog_pga.regValue = AIO_ReadRegister(AUDIO_analog_pga_reg);

#ifndef	ATV_NO_VIDEO

	if (drvif_module_vdc_CheckHVisLocked() != 1) {
		// no signal
		analog_pga.afe_pga_vol  = (LOWPSTHRESHOLD - 2); // assume good signal
	}

#else
	analog_pga.afe_pga_vol  = (LOWPSTHRESHOLD - 2); // assume good signal

#endif



	if (analog_pga.afe_pga_vol >= LOWPSTHRESHOLD) {          //+- 185K  ...old +-150K
		if (g_lowPSDebounce > LOWPSDEBOUNCEMIN)
			g_lowPSDebounce--;

	} else {
		if (g_lowPSDebounce < LOWPSDEBOUNCEMAX)
			g_lowPSDebounce++;
	}

	if (g_lowPSDebounce <= LOWPSDEBOUNCEMIN)
		g_lowPSFlag = 1;
	else
		g_lowPSFlag = 0;

	return g_lowPSFlag == 1;

}

void AtvChangeDeviation(uint32_t newStd, uint32_t bwid)
{


	//drv_audio_set_mute(AUD_ENABLE ,AUD_CHAN_ALL ,AUD_TV_MUTE);
	/*
	    drv_audio_set_mute(AUD_ENABLE, ADC_CH_L|ADC_CH_R, AUD_TV_MUTE);
	    drvif_audio_set_audio_out_mute_ctrl(ADC_MUTE, AUD_OUT_00_DB, AUD_TV_MUTE);
	    ROSTimeDly(25); // 250ms
	*/
	switch (newStd) {
	default :
	case ATV_SOUND_STD_MN_MONO :
		if (bwid == FM_BW_NORMAL) {

			AtvSetDeviation(newStd, FM_BW_NORMAL);
			//	drv_audio_set_compensate_volume(g_TV_M_Mono_VolumeCompensate_Normal);
			// Clayton 2013/6/4
			// No need to adjust prescale setting under ATV
			//AtvSetVolumeCompensate(g_TV_M_Mono_VolumeCompensate_Normal);
			AtvSetAtvClock(AUDIO_IPT_SRC_ATV, __LINE__);
			AtvSetAtvSubClock(AUDIO_IPT_SRC_ATV, __LINE__);
			//	tvMonitorOutLevel = AUD_OUT_m8_DB;

		}

		if (bwid == FM_BW_HIGH) {
			AtvSetDeviation(newStd, FM_BW_HIGH);
			// Clayton 2013/6/4
			// No need to adjust prescale setting under ATV
			//AtvSetVolumeCompensate(g_TV_M_Mono_VolumeCompensate_High);
			//	drv_audio_set_compensate_volume(g_TV_M_Mono_VolumeCompensate_High);
			AtvSetAtvClock(AUDIO_IPT_SRC_ATV, __LINE__);
			AtvSetAtvSubClock(AUDIO_IPT_SRC_ATV, __LINE__);
			//	tvMonitorOutLevel = AUD_OUT_m2_DB;
		}

		if (bwid == FM_BW_SUPER) {
			AtvSetDeviation(newStd, FM_BW_SUPER);
			// Clayton 2013/6/4
			// No need to adjust prescale setting under ATV
			//AtvSetVolumeCompensate(g_TV_M_Mono_VolumeCompensate_Super);
			//				drv_audio_set_compensate_volume(g_TV_M_Mono_VolumeCompensate_Supper);
			AtvSetAtvClock(AUDIO_IPT_SRC_ATV, __LINE__);
			AtvSetAtvSubClock(AUDIO_IPT_SRC_ATV, __LINE__);
			//			tvMonitorOutLevel = AUD_OUT_m2_DB;
		}

		break;
	case ATV_SOUND_STD_A2_M:
		if (bwid == FM_BW_NORMAL) {
			AtvSetDeviation(newStd, FM_BW_NORMAL);
			// Clayton 2013/6/4
			// No need to adjust prescale setting under ATV
			//AtvSetVolumeCompensate(g_TVM_A2M_VolumeCompensate_Normal);
			//	drv_audio_set_compensate_volume(g_TVM_A2M_VolumeCompensate_Normal);
			//				drv_audio_set_clock_and_sramplerate(AUD_CLK_PLL_AUDIO, AUD_SAMPLE_RATE_48k);
			//				tvMonitorOutLevel = AUD_OUT_m8_DB;
			AtvSetAtvClock(AUDIO_IPT_SRC_ATV, __LINE__);
			AtvSetAtvSubClock(AUDIO_IPT_SRC_ATV, __LINE__);
		}

		if (bwid == FM_BW_HIGH) {
			AtvSetDeviation(newStd, FM_BW_HIGH);
			// Clayton 2013/6/4
			// No need to adjust prescale setting under ATV
			//AtvSetVolumeCompensate(g_TVM_A2M_VolumeCompensate_High);
			AtvSetAtvClock(AUDIO_IPT_SRC_ATV, __LINE__);
			AtvSetAtvSubClock(AUDIO_IPT_SRC_ATV, __LINE__);
		}

		if (bwid == FM_BW_SUPER) {
			AtvSetDeviation(newStd, FM_BW_SUPER);
			// Clayton 2013/6/4
			// No need to adjust prescale setting under ATV
			//AtvSetVolumeCompensate(g_TVM_A2M_VolumeCompensate_Super);
			AtvSetAtvClock(AUDIO_IPT_SRC_ATV, __LINE__);
			AtvSetAtvSubClock(AUDIO_IPT_SRC_ATV, __LINE__);
		}

		break;
	case ATV_SOUND_STD_BTSC:
		if (bwid == FM_BW_NORMAL) {
			AtvSetDeviation(newStd, FM_BW_NORMAL);
			// Clayton 2013/6/4
			// No need to adjust prescale setting under ATV
			//AtvSetVolumeCompensate(g_TVM_BTSC_VolumeCompensate_Normal);
			AtvSetAtvClock(AUDIO_IPT_SRC_ATV, __LINE__);
			AtvSetAtvSubClock(AUDIO_IPT_SRC_ATV, __LINE__);
		}

		if (bwid == FM_BW_HIGH) {
			AtvSetDeviation(newStd, FM_BW_HIGH);
			// Clayton 2013/6/4
			// No need to adjust prescale setting under ATV
			//AtvSetVolumeCompensate(g_TVM_BTSC_VolumeCompensate_High);
			AtvSetAtvClock(AUDIO_IPT_SRC_ATV, __LINE__);
			AtvSetAtvSubClock(AUDIO_IPT_SRC_ATV, __LINE__);
		}

		if (bwid == FM_BW_SUPER) {
			AtvSetDeviation(newStd, FM_BW_SUPER);
			// Clayton 2013/6/4
			// No need to adjust prescale setting under ATV
			//AtvSetVolumeCompensate(g_TVM_BTSC_VolumeCompensate_Super);
			AtvSetAtvClock(AUDIO_IPT_SRC_ATV, __LINE__);
			AtvSetAtvSubClock(AUDIO_IPT_SRC_ATV, __LINE__);
		}

		break;
	case ATV_SOUND_STD_A2_BG:
	case ATV_SOUND_STD_A2_DK1:
	case ATV_SOUND_STD_A2_DK2:
	case ATV_SOUND_STD_A2_DK3:
		//if(bwid == FM_BW_NORMAL)
		{
			AtvSetDeviation(newStd, FM_BW_NORMAL);
			// Clayton 2013/6/4
			// No need to adjust prescale setting under ATV
			//AtvSetVolumeCompensate(g_TVA2_VolumeCompensate_Normal);
			AtvSetAtvClock(AUDIO_IPT_SRC_ATV, __LINE__);
			AtvSetAtvSubClock(AUDIO_IPT_SRC_ATV, __LINE__);
		}
		/*
		   if(bwid == FM_BW_HIGH)
		   {
		   AtvSetDeviation(newStd, FM_BW_HIGH);
		   AtvSetVolumeCompensate(g_TVA2_VolumeCompensate_High);
		   if(pCAudioInputFilter != NULL)
		   #if defined(AUDIO_C_MODEL)
		       ((AIN*)pCAudioInputFilter->pDerivedObj)
		       ->SetATVClock(pCAudioInputFilter, AUDIO_IPT_SRC_ATV_HDEV);
		   #else
		       pCAudioInputFilter->SetATVClock(AUDIO_IPT_SRC_ATV_HDEV);
		   #endif
		   }
		   if (bwid == FM_BW_SUPER)
		   {
		   AtvSetDeviation(newStd, FM_BW_SUPER);
		   AtvSetVolumeCompensate(g_TVA2_VolumeCompensate_Super);
		   if(pCAudioInputFilter != NULL)
		   #if defined(AUDIO_C_MODEL)
		       ((AIN*)pCAudioInputFilter->pDerivedObj)
		       ->SetATVClock(pCAudioInputFilter, AUDIO_IPT_SRC_ATV_HDEV);
		   #else
		       pCAudioInputFilter->SetATVClock(AUDIO_IPT_SRC_ATV_HDEV);
		   #endif
		   }
	   
		   if (bwid == FM_BW_ULTRA)
		   {
		   AtvSetDeviation(newStd, FM_BW_ULTRA);
		   AtvSetVolumeCompensate(g_TVA2_VolumeCompensate_Ultra);
		   if(pCAudioInputFilter != NULL)
		   #if defined(AUDIO_C_MODEL)
		       ((AIN*)pCAudioInputFilter->pDerivedObj)
		       ->SetATVClock(pCAudioInputFilter, AUDIO_IPT_SRC_ATV);
		   #else
		       pCAudioInputFilter->SetATVClock(AUDIO_IPT_SRC_ATV);
		   #endif
		   }
		   */

		break;
	case ATV_SOUND_STD_BG_MONO:
	case ATV_SOUND_STD_DK_MONO:
	case ATV_SOUND_STD_FM_MONO_NO_I:
		if (bwid == FM_BW_NORMAL) {
			AtvSetDeviation(newStd, FM_BW_NORMAL);
			// Clayton 2013/6/4
			// No need to adjust prescale setting under ATV
			//AtvSetVolumeCompensate(g_TVBGDKIVolumeCompensate_Normal);
			AtvSetAtvClock(AUDIO_IPT_SRC_ATV, __LINE__);
			AtvSetAtvSubClock(AUDIO_IPT_SRC_ATV, __LINE__);
		}

		if (bwid == FM_BW_HIGH) {
			AtvSetDeviation(newStd, FM_BW_HIGH);
			// Clayton 2013/6/4
			// No need to adjust prescale setting under ATV
			//AtvSetVolumeCompensate(g_TVBGDKIVolumeCompensate_High);
			// Clayton 2013/10/24
			// Mag~Sirius, it doesn't need to set High deviation mode due to IC HW modification of all LPF BW under 48kHz base
			AtvSetAtvClock(AUDIO_IPT_SRC_ATV, __LINE__);
			AtvSetAtvSubClock(AUDIO_IPT_SRC_ATV, __LINE__);
		}

		if (bwid == FM_BW_SUPER) {
			AtvSetDeviation(newStd, FM_BW_SUPER);
			// Clayton 2013/6/4
			// No need to adjust prescale setting under ATV
			//AtvSetVolumeCompensate(g_TVBGDKIVolumeCompensate_Super);
			// Clayton 2013/10/24
			// Mag~Sirius, it doesn't need to set High deviation mode due to IC HW modification of all LPF BW under 48kHz base
			AtvSetAtvClock(AUDIO_IPT_SRC_ATV, __LINE__);
			AtvSetAtvSubClock(AUDIO_IPT_SRC_ATV, __LINE__);
		}

		break;
	case ATV_SOUND_STD_NICAM_BG :
	case ATV_SOUND_STD_NICAM_DK:
	case ATV_SOUND_STD_NICAM_I:

		if (bwid == FM_BW_NORMAL) {
			AtvSetDeviation(newStd, FM_BW_NORMAL);
			// Clayton 2013/6/4
			// No need to adjust prescale setting under ATV
			//AtvSetVolumeCompensate(g_TVNICAM_MonoVolumeCompensate_Normal);
			AtvSetAtvClock(AUDIO_IPT_SRC_ATV, __LINE__);
			AtvSetAtvSubClock(AUDIO_IPT_SRC_ATV, __LINE__);
		}

		if (bwid == FM_BW_HIGH) {
			AtvSetDeviation(newStd, FM_BW_HIGH);
			// Clayton 2013/6/4
			// No need to adjust prescale setting under ATV
			//AtvSetVolumeCompensate(g_TVNICAM_MonoVolumeCompensate_High);
			// Clayton 2013/10/24
			// Mag~Sirius, it doesn't need to set High deviation mode due to IC HW modification of all LPF BW under 48kHz base
			AtvSetAtvClock(AUDIO_IPT_SRC_ATV, __LINE__);
			AtvSetAtvSubClock(AUDIO_IPT_SRC_ATV, __LINE__);
		}

		if (bwid == FM_BW_SUPER) {
			AtvSetDeviation(newStd, FM_BW_SUPER);
			// Clayton 2013/6/4
			// No need to adjust prescale setting under ATV
			//AtvSetVolumeCompensate(g_TVNICAM_MonoVolumeCompensate_Super);
			// Clayton 2013/10/24
			// Mag~Sirius, it doesn't need to set High deviation mode due to IC HW modification of all LPF BW under 48kHz base
			AtvSetAtvClock(AUDIO_IPT_SRC_ATV, __LINE__);
			AtvSetAtvSubClock(AUDIO_IPT_SRC_ATV, __LINE__);
		}

		break;
	case ATV_SOUND_STD_EIAJ:
	case ATV_SOUND_STD_AM_MONO:
	case ATV_SOUND_STD_NICAM_L:
		AtvSetDeviation(newStd, FM_BW_NORMAL);
		// Clayton 2013/6/4
		// No need to adjust prescale setting under ATV
		//AtvSetVolumeCompensate(g_TVM_VolumeCompensate_Zero);
		AtvSetAtvClock(AUDIO_IPT_SRC_ATV, __LINE__);
		AtvSetAtvSubClock(AUDIO_IPT_SRC_ATV, __LINE__);
		break;

	}

	//ScalerTimer_DelayXms(200);
	////RTD_Log(LOGGER_INFO, "[Pedro] %s std %d BW %d %x\n", __FUNCTION__, newStd, bwid, rtd_inl(0xb8006708));

	//drvif_audio_set_audio_out_mute_ctrl(ADC_UNMUTE, tvMonitorOutLevel, AUD_TV_MUTE);
	//drv_audio_set_mute(AUD_DISABLE ,AUD_CHAN_ALL ,AUD_TV_MUTE);
}

int GetDeviationIndex(audio_msd_status_RBUS msd_status)
{
	int signalDeivationIndex = 0;

	if ((msd_status.bw_cnt_max == 0x11) || (msd_status.bw_cnt_min == 0x11)) {
		signalDeivationIndex = 6;
	} else {
		signalDeivationIndex = msd_status.deviation;
	}

	return signalDeivationIndex;
}

void AtvMonoSignalProcess(void)
{
	//USER:Peter_Lin DATE:2010/12/16
	// modify current std reference
	
	//	audio_msd_result_RBUS			msd_result;
	

	//	audio_msd_flags_RBUS msd_flags;
	//	uint32_t energy1, energy2;
	static int g_ContinueMonoNum = 0;
#define  FIRSTTIMEMONOCHECKTIME (6)
#define  MONODELAY_CNT (1)  // 19 ->15 -> 1 for video/audio sync by ryanlan
	//	int signalDeivationIndex;
	//	static int changedeviationDebounce = 0;
	//	audio_analog_pga_RBUS analog_pga;
	//	audio_am_RBUS am;

	//USER:Peter_Lin DATE:2010/12/16
	// modify current std reference
	
	//	msd_result.regValue = AIO_ReadRegister(AUDIO_msd_result_reg);
	
	if (CHANGESTDSTATUS_FIRST_TIME == g_ChangeStdStatus) {
		// clean flag
		g_ChangeStdStatus = CHANGESTDSTATUS_DETECT;

		g_ContinueMonoNum = 0;
		//	g_printNicamLoop = 0;

	} else {
		if (g_ContinueMonoNum < (FIRSTTIMEMONOCHECKTIME * 10))
			g_ContinueMonoNum++;

		if (g_ContinueMonoNum == FIRSTTIMEMONOCHECKTIME) {
			//do nothing
			alog_info("m c s %d\n", g_ContinueMonoNum);
		} else if (g_ContinueMonoNum < (FIRSTTIMEMONOCHECKTIME + MONODELAY_CNT)) {
			//do nothing
			alog_info("m c s %d\n", g_ContinueMonoNum);
		} else if (g_ContinueMonoNum == (FIRSTTIMEMONOCHECKTIME + MONODELAY_CNT)) {
			//USER:Peter_Lin DATE:2010/12/16
			// modify current std reference
			
			if (g_CurrentStd != ATV_SOUND_STD_UNKNOWN)
			
			{

				alog_info("m r p s %d\n", g_ContinueMonoNum);


				//				drv_audio_set_backendplay(AUD_ENABLE);
#ifdef    MONITOR_NICAM_SIGNAL
				AtvSetSoundStd((ATV_SOUND_STD)g_CurrentStd);
#endif
				AtvCleanTVMuteNum();
				HwpSetVolume_SIF(0);
				AtvSetMute(ATV_DISABLE);
				//	g_printfTime = 1;
			} else {
				alog_info("m n p\n");
			}

			//	ROS_ENTER_CRITICAL();
			g_TVAudioReady = 1;
			//	ROS_EXIT_CRITICAL();
		} else if (g_ContinueMonoNum >  (FIRSTTIMEMONOCHECKTIME + MONODELAY_CNT)) {
			//USER:Peter_Lin DATE:2010/12/16
			// modify current std reference
			
			if ((g_CurrentStd != ATV_SOUND_STD_AM_MONO))
			
			{
				if (g_TVAudioNosignal == 0) {    //+-240K  ...old +-200K
								 //USER:Peter_Lin DATE:2012/03/20
								 // add dymanic change deviation for Txxxx company
								 
					if (((g_CurrentStd == ATV_SOUND_STD_BG_MONO) || (g_CurrentStd == ATV_SOUND_STD_DK_MONO) || (g_CurrentStd == ATV_SOUND_STD_FM_MONO_NO_I))) {
						CheckAndChangeDeviation();
					}


				} else {
					//					ATV_LOG( "mono no  singal \n");
				}
			}
		}

	}
}

void AtvGetA2HwSoundMode(ATV_SOUND_MODE *p_sound_info, bool check_pilot)
{
	audio_md_status_2_RBUS			md_status_2;
	//audio_md_ctrl_RBUS			MD_CTRL_REG;
	//static int count_print = 0;
	//static uint32_t other_sum = 0, stereo_sum = 0, dual_sum = 0, sum_cnt = 0;
	//static ATV_SOUND_MODE fw_sound_mode = ATV_SOUND_MODE_MONO;

	// get analog sound_mode
	md_status_2.regValue = AIO_ReadRegister(AUDIO_md_status_2_reg);

	if (p_sound_info) {
		*p_sound_info = (ATV_SOUND_MODE)md_status_2.mode_result;
		if (md_status_2.mode_result == 3 || g_A2_TH_sel == 100) {
			*p_sound_info = ATV_SOUND_MODE_MONO;
			//alog_info("[%s-1] md_status %d\n",__LINE__,md_status_1.mode_result);
		}

		// Owen 2016/0602, Vietnam patch needs fintune, temporarily remove in K3L
		/*
		if(check_pilot == TRUE)
		{
		    // Clayton 2014/2/13
		    // patch for sound mode change frequently of Vietnam
		    if((md_status_1.mode_result == ATV_SOUND_MODE_MONO) && (g_A2_soundmode != ATV_SOUND_MODE_MONO) && ((md_status_2.max_stereo>ATV_MODE_MAX_TH_2500) || (md_status_2.max_dual>ATV_MODE_MAX_TH_2500)))
		    {
		    if(((md_status_1.max_other >>1) > md_status_2.max_stereo) && ((md_status_1.max_other >>1) > md_status_2.max_dual))
		    {
			*p_sound_info = ATV_SOUND_MODE_MONO;
		    }
		    else
		    {
			*p_sound_info = (ATV_SOUND_MODE)g_A2_soundmode;
		    }
		    }
		}
		*/

	}

}

void AtvChageA2SoundMode(ATV_SOUND_MODE sound_mode)
{
	audio_mode_detect_RBUS mode_detect;
	audio_md_ctrl_RBUS			MD_CTRL_REG;
	audio_msd_crtl_word_RBUS	msd_crtl_word;
	//int  max_stereo_dual = 0;

	msd_crtl_word.regValue = AIO_ReadRegister(AUDIO_msd_crtl_word_reg);
	MD_CTRL_REG.regValue = AIO_ReadRegister(AUDIO_md_ctrl_reg);
	switch (sound_mode) {
	default :
	case ATV_SOUND_MODE_MONO  :

		break;
	case 	ATV_SOUND_MODE_STEREO   :
		if (g_UserTVA2ISStereo == 0) {                        //+-120K  ...old +-100K
			if (msd_crtl_word.sound_select != ATV_SOUND_SEL_FMAM) {
				msd_crtl_word.sound_select = ATV_SOUND_SEL_FMAM; // mono

			}
		} else { // user want stereo
			if (msd_crtl_word.sound_select == ATV_SOUND_SEL_FMAM) {
				msd_crtl_word.sound_select = ATV_SOUND_SEL_STEREO_A; // stereo

			}
		}

		break;
	case 	ATV_SOUND_MODE_DUAL   :
		if (g_UserTVA2Language == 0) {                //+-85K  ...old +/-70kHz
			if (msd_crtl_word.sound_select != ATV_SOUND_SEL_STEREO_A) {
				msd_crtl_word.sound_select = ATV_SOUND_SEL_STEREO_A; // mono

			}
		} else if (g_UserTVA2Language == 1) {             //+-120K  ...old +/-100kHz
			if (msd_crtl_word.sound_select != ATV_SOUND_SEL_STEREO_B) {
				msd_crtl_word.sound_select = ATV_SOUND_SEL_STEREO_B; // stereo

			}
		} else {
			if (msd_crtl_word.sound_select != ATV_SOUND_SEL_STEREO_AB) {
				msd_crtl_word.sound_select = ATV_SOUND_SEL_STEREO_AB; // stereo

			}
		}

		break;

	}

	mode_detect.regValue = AIO_ReadRegister(AUDIO_mode_detect_reg);


	//Set A2 threahold by table
	switch (sound_mode) {
	default:
	case 	ATV_SOUND_MODE_MONO  :
		mode_detect.mode_result = 0;
		// Clayton 2014/2/13, Add hysteresis for sound mode change
		MD_CTRL_REG.max_threshold = A2_Th_Table[g_A2_TH_sel].max_threshold;

		break;
	case ATV_SOUND_MODE_STEREO   :
		mode_detect.mode_result = 1;
		// Clayton 2014/2/13, Add hysteresis for sound mode change
		MD_CTRL_REG.max_threshold = A2_Th_Table[g_A2_TH_sel].max_threshold - A2_Th_Table[g_A2_TH_sel].schmitt_window; // Hysteresis for change back MONO

		break;
	case ATV_SOUND_MODE_DUAL  :
		mode_detect.mode_result = 2; // no this case
					     // Clayton 2014/2/13, Add hysteresis for sound mode change
		MD_CTRL_REG.max_threshold = A2_Th_Table[g_A2_TH_sel].max_threshold - A2_Th_Table[g_A2_TH_sel].schmitt_window; // Hysteresis for change back MONO

		break;
	}

	AIO_WriteRegister(AUDIO_mode_detect_reg, mode_detect.regValue);

	AIO_WriteRegister(AUDIO_msd_crtl_word_reg, msd_crtl_word.regValue);
	AIO_WriteRegister(AUDIO_md_ctrl_reg, MD_CTRL_REG.regValue);

}

void CheckAndChangeDeviation(void)
{
	{
		//RTD_Log(LOGGER_INFO, "[Pedro] %s\n", __FUNCTION__);
		//	drv_audio_set_mute(AUD_ENABLE, ADC_CH_L|ADC_CH_R, AUD_TV_MUTE);
		//	drvif_audio_set_audio_out_mute_ctrl(ADC_MUTE, AUD_OUT_00_DB, AUD_TV_MUTE);

		switch (g_CurrentStd) {
		case ATV_SOUND_STD_MN_MONO:
		case ATV_SOUND_STD_BTSC:
		case ATV_SOUND_STD_A2_M:
		case ATV_SOUND_STD_EIAJ:
			if ((atv_flag&ATV_INIT_DEV_M_MASK) == ATV_INIT_DEV_M_NORMAL) {
				if (g_CurrentDeviation != FM_BW_NORMAL)
					AtvChangeDeviation(g_CurrentStd, FM_BW_NORMAL);
			} else if ((atv_flag&ATV_INIT_DEV_M_MASK) == ATV_INIT_DEV_M_HIGH) {
				if (g_CurrentDeviation != FM_BW_HIGH)
					AtvChangeDeviation(g_CurrentStd, FM_BW_HIGH);
			} else if ((atv_flag&ATV_INIT_DEV_M_MASK) == ATV_INIT_DEV_M_SUPER) {
				if (g_CurrentDeviation != FM_BW_SUPER)
					AtvChangeDeviation(g_CurrentStd, FM_BW_SUPER);

			} else {
				if (g_CurrentDeviation != FM_BW_SUPER)
					AtvChangeDeviation(g_CurrentStd, FM_BW_SUPER);

			}

			break;
		case ATV_SOUND_STD_A2_BG:
		case ATV_SOUND_STD_A2_DK1:
		case ATV_SOUND_STD_A2_DK2:
		case ATV_SOUND_STD_A2_DK3:
		case ATV_SOUND_STD_FM_MONO_NO_I:
		case ATV_SOUND_STD_BG_MONO:
		case ATV_SOUND_STD_DK_MONO:
			if ((atv_flag&ATV_INIT_DEV_BGDKI_MASK) == ATV_INIT_DEV_BGDKI_NORMAL) {
				if (g_CurrentDeviation != FM_BW_NORMAL)
					AtvChangeDeviation(g_CurrentStd, FM_BW_NORMAL);
			} else if ((atv_flag&ATV_INIT_DEV_BGDKI_MASK) == ATV_INIT_DEV_BGDKI_HIGH) {
				if (g_CurrentDeviation != FM_BW_HIGH)
					AtvChangeDeviation(g_CurrentStd, FM_BW_HIGH);
			} else if ((atv_flag&ATV_INIT_DEV_BGDKI_MASK) == ATV_INIT_DEV_BGDKI_SUPER) {
				if (g_CurrentDeviation != FM_BW_SUPER)
					AtvChangeDeviation(g_CurrentStd, FM_BW_SUPER);
			} else {
				if (g_CurrentDeviation != FM_BW_SUPER)
					AtvChangeDeviation(g_CurrentStd, FM_BW_SUPER);
			}

			break;
		case ATV_SOUND_STD_NICAM_BG:
		case ATV_SOUND_STD_NICAM_DK:
		case ATV_SOUND_STD_NICAM_I:
			// theoretically process does not use this part
			if ((atv_flag&ATV_INIT_DEV_NICAM_BGDKI_MASK) == ATV_INIT_DEV_NICAM_BGDKI_NORMAL) {
				if (g_CurrentDeviation != FM_BW_NORMAL)
					AtvChangeDeviation(g_CurrentStd, FM_BW_NORMAL);
			} else if ((atv_flag&ATV_INIT_DEV_NICAM_BGDKI_MASK) == ATV_INIT_DEV_NICAM_BGDKI_HIGH) {
				if (g_CurrentDeviation != FM_BW_HIGH)
					AtvChangeDeviation(g_CurrentStd, FM_BW_HIGH);
			} else if ((atv_flag&ATV_INIT_DEV_NICAM_BGDKI_MASK) == ATV_INIT_DEV_NICAM_BGDKI_SUPER) {
				if (g_CurrentDeviation != FM_BW_SUPER)
					AtvChangeDeviation(g_CurrentStd, FM_BW_SUPER);
			} else {
				if (g_CurrentDeviation != FM_BW_SUPER)
					AtvChangeDeviation(g_CurrentStd, FM_BW_SUPER);
			}

			break;
		}


		//	drvif_audio_set_audio_out_mute_ctrl(ADC_UNMUTE, tvMonitorOutLevel, AUD_TV_MUTE);
		//	drv_audio_set_mute(AUD_DISABLE ,AUD_CHAN_ALL ,AUD_TV_MUTE);
		//RTD_Log(LOGGER_INFO, "[Pedro] %s\n", __FUNCTION__);
	}
}

static uint32_t g_A2_soundmode_debounce;

void AtvA2SignalProcess(ATV_SOUND_STD std)
{

	audio_msd_crtl_word_RBUS	msd_crtl_word;
	uint32_t changeFlag,   i, maxindex, firsttimedetect;  // Clayton ; Date: 2012/6/25
	static uint32_t g_changeSoundMode;    // Clayton ; Date: 2012/6/25
	ATV_SOUND_MODE sound_mode = ATV_SOUND_MODE_AUTO;
	static int g_ContinueA2Num = 0;
	//audio_md_ctrl_RBUS			MD_CTRL_REG;
	bool check_pilot = FALSE;
	static uint32_t g_A2_soundmode_prev;
	static uint32_t g_A2_soundmode_time_prev;

#define  FIRSTTIMEA2CHECKTIME (15)		//20 -> 15// Speed up A2 sound mode detection. From 30-->20
#define FIRSTTIMESOUNDMODEMAX (5)

	audio_mode_detect_RBUS mode_detect;
	int32_t A2FirsTimeCheckloop;

	mode_detect.regValue = AIO_ReadRegister(AUDIO_mode_detect_reg);


	//
	A2FirsTimeCheckloop = FIRSTTIMEA2CHECKTIME;

	if (g_FirstTimeForce2PlayMono)
		A2FirsTimeCheckloop = 5;        // Increase the cycle from 1 to 5 due to adding latency for HW sound mode detection

	if (CHANGESTDSTATUS_FIRST_TIME == g_ChangeStdStatus) {
		// clean flag
		mode_detect.regValue = AIO_ReadRegister(AUDIO_mode_detect_reg);    //Clayton 2013/1/28
		g_ChangeStdStatus = CHANGESTDSTATUS_DETECT;
		g_A2_soundmode_time_prev = mode_detect.md_update_count;
		g_ContinueA2Num = 0;
		g_A2_soundmode_debounce = A2SOUNDMODECHANGEMAX; // initial setting

		g_FirstTimeSoundMode[0] = 0;
		g_FirstTimeSoundMode[1] = 0;
		g_FirstTimeSoundMode[2] = 0;
		g_FirstTimeSoundMode[3] = 0;

		// Clayton 2014/4/24
		// Speed up sound mode detection when switch channel
		
		AtvSpeedupA2SoundModeDetect((ATV_SOUND_STD)g_CurrentStd);  //even for Force2playMONO case, it could speed up correct HW detect sound mode out,
									   							// But still keep MONO sound setting by latter setting "g_A2_soundmode = ATV_SOUND_MODE_MONO;" under Force2playMONO case

		return;
	} else {
		//CHANGESTDSTATUS_DETECT
		if (g_ContinueA2Num < (FIRSTTIMEA2CHECKTIME * 20))
			g_ContinueA2Num++;
	}

	if (g_ContinueA2Num <= A2FirsTimeCheckloop) {
		// Clayton ; Date: 2012/6/25
		// Fix the bug of Dual <--> Stereo switching, driver will not implement with "AtvChageA2SoundMode" API
		// due to "changeSoundMode" flag will be reset
		
		g_changeSoundMode = 0;
		

		//		MD_CTRL_REG.regValue = AIO_ReadRegister(AUDIO_md_ctrl_reg );
		mode_detect.regValue = AIO_ReadRegister(AUDIO_mode_detect_reg);

		// A2 sound mode 1 debounce need 10 ms
		//if( ( (g_ContinueA2Num -g_A2_soundmode_time_prev) * ATV_TICK_PACFIC_TIME) >  (ACCU_Value[MD_CTRL_REG.accu_num] ))	//Clayton 2013/1/28
		if (mode_detect.md_update_count != g_A2_soundmode_time_prev) {
			g_A2_soundmode_time_prev = mode_detect.md_update_count; //Clayton 2013/1/28
			check_pilot = FALSE;
			AtvGetA2HwSoundMode(&sound_mode, check_pilot);

			switch (sound_mode) {
			case ATV_SOUND_MODE_DUAL: // no this case
				g_FirstTimeSoundMode[2] = g_FirstTimeSoundMode[2] + 1;
				break;
			case ATV_SOUND_MODE_MONO  :
				g_FirstTimeSoundMode[0] = g_FirstTimeSoundMode[0] + 1;
				break;
			case 	ATV_SOUND_MODE_STEREO   :
				g_FirstTimeSoundMode[1] = g_FirstTimeSoundMode[1] + 1;
				break;
			default :
				break;

			}

			//ATV_LOG( "a c s %2d  %x V %d\n", g_ContinueA2Num, sound_mode, AIO_ReadRegister(0xb8028300)&0x02);
			alog_info("a c s %2d  %x\n", g_ContinueA2Num, sound_mode);
		}

		//Frank: speed up sound mode out. At this time, sound does not output.
		g_last_soundmode[2] = g_last_soundmode[1];
		g_last_soundmode[1] = g_last_soundmode[0];
		g_last_soundmode[0] = sound_mode;

#define A2_SOUNDMODE_OUT_CNT 8
		if ((g_ContinueA2Num >=  A2_SOUNDMODE_OUT_CNT) && (g_ContinueA2Num < A2FirsTimeCheckloop)) {
			if ((g_last_soundmode[2] == g_last_soundmode[1]) && (g_last_soundmode[2] == g_last_soundmode[0])) {
				g_A2_soundmode = g_last_soundmode[0];
			}
		} else if (g_ContinueA2Num == (A2FirsTimeCheckloop)) {
			maxindex = 0;
			for (i = 1; i < 3; i++) {
				if (g_FirstTimeSoundMode[i] > g_FirstTimeSoundMode[maxindex])
					maxindex = i;
			}

			alog_info("a r p s %x  %x\n", maxindex, g_FirstTimeSoundMode[maxindex]);

			if (maxindex == 0)
				g_A2_soundmode = ATV_SOUND_MODE_MONO;
			else if (maxindex == 1)
				g_A2_soundmode = ATV_SOUND_MODE_STEREO;
			else
				g_A2_soundmode = ATV_SOUND_MODE_DUAL;

			if (g_FirstTimeForce2PlayMono) {
				g_A2_soundmode = ATV_SOUND_MODE_MONO; // force 2 Mono
				g_UserTVA2ISStereo = 0;
				g_UserTVA2Language = 0;
			}

			//if(g_A2_soundmode == ATV_SOUND_MODE_STEREO)
			//{
			//    g_UserTVA2ISStereo = 1;
			//	g_UserTVA2Language = 0;
			//}

			if (g_EnableAutoChangeSoundMode == 0)
				g_Start2NormalProcess = 0;

			AtvChageA2SoundMode((ATV_SOUND_MODE)g_A2_soundmode);

			if (audioStatusChanageCallBack != NULL)
				audioStatusChanageCallBack(ATV_STATUS_FIRSTTIME_SOUNDMODE);

			//if(g_FirstTimeForce2PlayMono)
			//	g_A2_soundmode_debounce = FIRSTTIMESOUNDMODEMAX;// reset
			//else
			//	g_A2_soundmode_debounce = A2SOUNDMODECHANGEMAX;// reset
			g_A2_soundmode_debounce = A2_Th_Table[g_A2_TH_sel].fw_debounce;

			g_A2_soundmode_prev = g_A2_soundmode;

			//audio_hw_usleep(100000);
			//       	drv_audio_set_backendplay(AUD_ENABLE);
			AtvCleanTVMuteNum();
			HwpSetVolume_SIF(0);
			//alog_info("ATV task\n");
			AtvSetMute(ATV_DISABLE);
			//alog_info("ATV task222\n");

			g_TVAudioReady = 1;

			//	if(g_UserChagneA2SelectFlag == 1)
			g_UserChagneA2SelectFlag = 0;

			//AtvSetModeDebounceCoef(g_CurrentStd);	// For Normal Run "tough setting"

			// Owen 2016/06/02, remove in K3L.
			/*				
			#ifdef USE_A2_TABLE
				AtvSetA2Parameter();
			#endif
			*/

			//				get_system_time(&g_endStd);
			//				g_printfTime = 1;
		}

		return;
	}

	msd_crtl_word.regValue = AIO_ReadRegister(AUDIO_msd_crtl_word_reg);
	check_pilot = TRUE;
	AtvGetA2HwSoundMode(&sound_mode, check_pilot);

	// Clayton ; Date: 2012/6/25
	// Fix the bug of Dual <--> Stereo switching, driver will not implement with "AtvChageA2SoundMode" API
	// due to "changeSoundMode" flag will be reset
	

	firsttimedetect = 0;
	

	//	ATV_LOG( " A2 sound mode %x %x %x \n", g_A2_soundmode, sound_mode, g_A2_soundmode_prev);

	if ((sound_mode != (ATV_SOUND_MODE)g_A2_soundmode) && ((ATV_SOUND_MODE)g_A2_soundmode_prev == sound_mode)) {
		//debug
		//audio_md_status_1_RBUS			md_status_1;
		//audio_md_status_2_RBUS			md_status_2;
		//alog_info("A2 6310- %08X\nA2 6314- %08x\nA2 6318- %08x\n",AIO_ReadRegister(AUDIO_md_ctrl_reg),AIO_ReadRegister(AUDIO_MD_STATUS_1_VADDR), AIO_ReadRegister(AUDIO_md_status_2_reg));

		if (g_A2_soundmode_debounce > A2SOUNDCHANGEMIN) {
			g_A2_soundmode_debounce--;
		} else {
			//debug
			//audio_md_ctrl_RBUS			MD_CTRL_REG;

			alog_info(" A2 new sound mode %x\n", sound_mode);
			g_A2_soundmode = sound_mode;
			g_changeSoundMode = 1;
			firsttimedetect = 1;    // Clayton ; Date: 2012/6/25

			g_A2_soundmode_debounce = A2_Th_Table[g_A2_TH_sel].fw_debounce;
			//if(g_Start2NormalProcess)
			//	g_A2_soundmode_debounce = A2SOUNDCHANGEMAX;// reset
			//else
			//	g_A2_soundmode_debounce = FIRSTTIMESOUNDMODEMAX;// reset
		}

	} else {
		g_A2_soundmode_debounce = A2_Th_Table[g_A2_TH_sel].fw_debounce;
		//if(g_Start2NormalProcess)
		//	g_A2_soundmode_debounce = A2SOUNDCHANGEMAX;// reset
		//else
		//	g_A2_soundmode_debounce = FIRSTTIMESOUNDMODEMAX;// reset
	}

	g_A2_soundmode_prev = sound_mode;

	if ((firsttimedetect == 1)) {                                    //+-185K  ...old +/-150kHz

		if (g_EnableAutoChangeSoundMode == 0) {
			g_Start2NormalProcess = 0;
		}

		if (audioStatusChanageCallBack != NULL)
			audioStatusChanageCallBack(ATV_STATUS_SOUNDMODE_CHANGE);
	}

	changeFlag = 0;

	switch (g_A2_soundmode) {
	default :
	case ATV_SOUND_MODE_MONO  :

		break;
	case 	ATV_SOUND_MODE_STEREO   :
		if (g_UserTVA2ISStereo == 0) {                //+-120K  ...old +/-100kHz
			if (msd_crtl_word.sound_select != ATV_SOUND_SEL_FMAM) {
				//	msd_crtl_word.sound_select = ATV_SOUND_SEL_FMAM; // mono
				changeFlag = 1;
			}
		} else { // user want stereo
			if (msd_crtl_word.sound_select == ATV_SOUND_SEL_FMAM) {
				//	msd_crtl_word.sound_select = ATV_SOUND_SEL_STEREO_A; // stereo
				changeFlag = 1;
			}
		}

		break;
	case 	ATV_SOUND_MODE_DUAL   :
		if (g_UserTVA2Language == 0) {             //+-240K  ...old +/-200kHz
			if (msd_crtl_word.sound_select != ATV_SOUND_SEL_STEREO_A) {
				//	msd_crtl_word.sound_select = ATV_SOUND_SEL_STEREO_A; // mono
				changeFlag = 1;
			}
		} else if (g_UserTVA2Language == 1) {            //+-370K  ...old +/-300kHz
			if (msd_crtl_word.sound_select != ATV_SOUND_SEL_STEREO_B) {
				//	msd_crtl_word.sound_select = ATV_SOUND_SEL_STEREO_B; // stereo
				changeFlag = 1;
			}
		} else {
			if (msd_crtl_word.sound_select != ATV_SOUND_SEL_STEREO_AB) {
				//	msd_crtl_word.sound_select = ATV_SOUND_SEL_STEREO_AB; // stereo
				changeFlag = 1;
			}
		}

		break;

	}

	if ((changeFlag == 1) || ((g_changeSoundMode == 1) && (g_Start2NormalProcess == 1))) //When user change, changeFlag = 1; It is independent on g_Start2NormalProcess.
											     //if( ( (changeFlag) || (g_changeSoundMode == 1)) && (g_Start2NormalProcess == 1))
	{
		AtvSetMute(ATV_ENABLE);
		//		 ScalerTimer_DelayXms(200);
		//	 AIO_WriteRegister(AUDIO_msd_crtl_word_reg, msd_crtl_word.regValue);
		AtvChageA2SoundMode((ATV_SOUND_MODE)g_A2_soundmode);
		//	 ScalerTimer_DelayXms(200);
		//	CheckAndChangeDeviation();
		AtvSetMute(ATV_DISABLE);

		if (g_UserChagneA2SelectFlag == 1)
			g_UserChagneA2SelectFlag = 0;

		// Clayton ; Date: 2012/6/25
		// Fix the bug of Dual <--> Stereo switching, driver will not implement with "AtvChageA2SoundMode" API
		// due to "changeSoundMode" flag will be reset
		

		g_changeSoundMode = 0;
		

	} else if (g_Start2NormalProcess == 1) {
		//	CheckAndChangeDeviation();
	}

}

uint32_t AtvIsNicamOverflow(void)
{
	audio_interrupt_status_RBUS interrupt_status;

	interrupt_status.regValue = AIO_ReadRegister(AUDIO_interrupt_status_reg);
	return interrupt_status.int_nicam_level_status == 0x1;
}

void AtvCleanNicamOverFlowStatus(void)
{
	audio_interrupt_status_RBUS interrupt_status;

	interrupt_status.regValue = 0;
	interrupt_status.int_nicam_level_status = 1; // only nicam overflow status
	AIO_WriteRegister(AUDIO_interrupt_status_reg, interrupt_status.regValue);
}

void AtvNicamDeemphasisBypass(uint32_t isByapss)
{
	audio_nicam_decode_ctrl_RBUS nicam_decode_ctrl;

	//	return ;
	nicam_decode_ctrl.regValue = AIO_ReadRegister(AUDIO_nicam_decode_ctrl_reg);

	if (isByapss)
		nicam_decode_ctrl.de_em_by_pass = 1;
	else
		nicam_decode_ctrl.de_em_by_pass = 0;

	AIO_WriteRegister(AUDIO_nicam_decode_ctrl_reg, nicam_decode_ctrl.regValue);

}

//USER:Peter_Lin DATE:2011/09/20
// add nicam saturate

void AtvSetNicamDeemphasisSaturantion(uint32_t isSaturation);


void  AtvResetNicamOverflow(void)
{
	//	g_NicamOverFlowInt = 0;
	AtvCleanNicamOverFlowStatus();
	AtvNicamDeemphasisBypass(0);
	//USER:Peter_Lin DATE:2011/2/10
	// nicam overflow debounce
	
	g_NicamOverFlowCnt = 0;
	


	//USER:Peter_Lin DATE:2011/09/20
	// add nicam saturate
	
	if ((g_AudioTVControlFlag&ENABLE_NICAM_PRESCALE_OVERFLOW_MASK) == ENABLE_NICAM_PRESCALE_OVERFLOW) {
		AtvSetNicamDeemphasisSaturantion(0);
	} else
		AtvSetNicamDeemphasisSaturantion(1);
	
}

void AtvGetNicamHhwSoundMode(ATV_SOUND_MODE *p_sound_info)
{
	audio_nicam_decode_status_RBUS			nicam_decode_status;
	audio_msd_crtl_word_RBUS            msd_crtl_word;

	// get analog sound_mode
	nicam_decode_status.regValue = AIO_ReadRegister(AUDIO_nicam_decode_status_reg);

	if (p_sound_info) {
		msd_crtl_word.regValue = AIO_ReadRegister(AUDIO_msd_crtl_word_reg);
		if ((nicam_decode_status.true_detect != 1) && (msd_crtl_word.sound_select == 0)) {
			AtvEnhanceNicamTrueDetect(1);   // Enable
		}

		nicam_decode_status.regValue = AIO_ReadRegister(AUDIO_nicam_decode_status_reg); //Update getting true detect again
		if (nicam_decode_status.true_detect != 1) {
			*p_sound_info = ATV_SOUND_MODE_MONO;
			return;
		}

		switch (nicam_decode_status.c1c2c3) {
		case 0:
			*p_sound_info = 	ATV_SOUND_MODE_STEREO;
			break;
		case 2:
			*p_sound_info = 	ATV_SOUND_MODE_DUAL;
			break;
		default :
		case 4:
			*p_sound_info = 	ATV_SOUND_MODE_MONO;
			break;
		}
	}

	if (g_NicamEnhanceTrueDetect == 1)   // Only After Enhance, it needs to disable
		AtvEnhanceNicamTrueDetect(0);   // Disable
}

void AtvResetErrorRateConsNum(void)
{
	g_ErrorRateConstNum = 0;
}

uint32_t AtvGetNicamErrorRate(uint32_t CheckNum)
{
	uint32_t errorRate, max;
	volatile audio_nicam_decode_status_RBUS nicam_decode_status;
	audio_msd_crtl_word_RBUS            msd_crtl_word;
	//uint32_t check_cnt = 0;

	static uint32_t ToSignalCnt = 0;

#define ERRORRATECONSTNUM (50)
	//#define MODECONSTNUM (50)

	static uint32_t prevErrorRate = 0;
	//	static int32_t g_ErrorRateConstNum = 0;

	static uint32_t prevMode = 0;
	//	static uint32_t ModeConstNum = 0;
	static uint32_t isToSignal = 0;

	errorRate = 0xFFFF;
	max = 0;
	while (CheckNum--) {
		nicam_decode_status.regValue = AIO_ReadRegister(AUDIO_nicam_decode_status_reg);

		/*
		if(g_ContinueNicamNum <= 1 )
		{
		    nicam_decode_status.regValue = 0x48001500;
		}
		else if(g_ContinueNicamNum <= 2)
		    nicam_decode_status.regValue = 0x500;
		else if(g_ContinueNicamNum <= 3)
		    nicam_decode_status.regValue = 0xC8001500;
		else
		{
		    if(g_patern != 0)
		    nicam_decode_status.regValue = g_patern;
		}
		*/

		msd_crtl_word.regValue = AIO_ReadRegister(AUDIO_msd_crtl_word_reg);

		/* 2017.6.22 calling same function redundantly, remove it.
		// [Start]
		if ((nicam_decode_status.true_detect != 1) &&  (++check_cnt < 2) && (msd_crtl_word.sound_select == 0)) {                                    //+-370K  ...old +/-600kHz
			AtvEnhanceNicamTrueDetect(1);   // Enable
		}
		*/

		nicam_decode_status.regValue = AIO_ReadRegister(AUDIO_nicam_decode_status_reg);
		if (nicam_decode_status.true_detect != 1) {

			g_ErrorRateConstNum = 0;
			max = 0xFFFF;
			break;
		} else {
			if ((nicam_decode_status.bit_error_rate >= 0x300) && (nicam_decode_status.bit_error_rate == prevErrorRate) && (nicam_decode_status.c1c2c3 == prevMode)) {
				if (g_ErrorRateConstNum < (ERRORRATECONSTNUM)) {
					g_ErrorRateConstNum++;
					//	ATV_LOG( "To %x \n",  g_ErrorRateConstNum);
				}
			} else {
				if (isToSignal) {
					if (g_ErrorRateConstNum > 0)
						g_ErrorRateConstNum--;
				} else
					g_ErrorRateConstNum = 0;

			}

			prevErrorRate = nicam_decode_status.bit_error_rate;


			prevMode = nicam_decode_status.c1c2c3;


			if (nicam_decode_status.bit_error_rate >  max)
				max = nicam_decode_status.bit_error_rate;
		}
	}

	/*
	if (g_NicamEnhanceTrueDetect == 1)
		AtvEnhanceNicamTrueDetect(0);   // Disable
	// [End]
	*/

	//	if( (g_ErrorRateConstNum < ERRORRATECONSTNUM) || (ModeConstNum <  MODECONSTNUM) )

	if ((g_ErrorRateConstNum >=  ERRORRATECONSTNUM)) {
		isToSignal = 1;
		//ATV_LOG( "To s\n");
	} else if ((g_ErrorRateConstNum <=  0))
		isToSignal = 0;

	if (isToSignal == 0) {
		//drv_audio_set_tsb_singal(0);
		return max;
	} else {

		if (g_NicamHighErrorRate == 1) {
			// tosignal
			if (nicam_decode_status.c1c2c3 == 2) { // use video detected
							       //				drv_audio_set_tsb_singal(1);

			} else {
				//	drv_audio_set_tsb_singal(0);
			}

			ToSignalCnt++;
			if ((ToSignalCnt % 200) == 0) // 10 sec
				alog_info("To s\n");

			return 0; // To company issue

		} else
			return max;

	}

}

uint32_t AtvIsPlayDigitalState(void)
{

	audio_msd_crtl_word_RBUS msd_crtl_word;

	msd_crtl_word.regValue = AIO_ReadRegister(AUDIO_msd_crtl_word_reg);

	return msd_crtl_word.sound_select != 0;

}

uint32_t AtvIsCurrentNicamSoundSelectCorrect(uint32_t setting, uint32_t currentSoundMode)
{
	uint32_t isCorrect;
	audio_msd_crtl_word_RBUS	MSD_CTRL_REG;

	//	ATV_SOUND_MODE  NONBTSC_SOUND_MODE;
	//	drvif_audio_get_nonbtscsoundmode(&NONBTSC_SOUND_MODE);
	MSD_CTRL_REG.regValue = AIO_ReadRegister(AUDIO_msd_crtl_word_reg);

	switch (setting) {
	default:
	case 0: //ATV_SOUND_SEL_STEREO_A
		if (currentSoundMode == ATV_SOUND_MODE_DUAL) {
			if (MSD_CTRL_REG.sound_select == 2)
				isCorrect = 1;
			else
				isCorrect = 0;
		} else { // not dual mode, mono, stereo
			isCorrect = 1;
		}

		break;
	case 1:

		if (currentSoundMode == ATV_SOUND_MODE_DUAL) {
			if (MSD_CTRL_REG.sound_select == 3)
				isCorrect = 1;
			else
				isCorrect = 0;
		} else { // not dual
			isCorrect = 1;
		}

		break;
	case 2:

		if (currentSoundMode == ATV_SOUND_MODE_DUAL) {
			if (MSD_CTRL_REG.sound_select == 1)
				isCorrect = 1;
			else
				isCorrect = 0;
		} else { // not dual
			isCorrect = 1;
		}

		break;


	}

	return isCorrect;

	//	return (MSD_CTRL_REG.sound_select == setting);

}

void AtvEnhanceNicamTrueDetect(uint32_t Enable)
{
	audio_nicam_demod_RBUS nicam_demod;
	audio_msd_result_RBUS msd_result;
	audio_nicam_decode_ctrl_RBUS nicam_decode_ctrl;
	ATV_SOUND_STD org_sound_std;
	uint32_t	i = 0;

	//	return ;
	nicam_demod.regValue = AIO_ReadRegister(AUDIO_nicam_demod_reg);
	nicam_decode_ctrl.regValue = AIO_ReadRegister(AUDIO_nicam_decode_ctrl_reg);
	msd_result.regValue = AIO_ReadRegister(AUDIO_msd_result_reg);
	org_sound_std = (ATV_SOUND_STD)msd_result.reg_std;

	alog_debug("AtvEnhanceNicamTrueDetect %d\n", Enable);

	if (Enable == 1) {
		nicam_demod.psf_bg_sel = 1; // 1: new bg psf (transition band 109 - 250)
		nicam_demod.tr_lpf_kp = 0x0; // 0x0: 2^2, the max Kp
		g_NicamEnhanceTrueDetect = 1;
	} else {
		nicam_demod.psf_bg_sel = 0; // 1: new bg psf (transition band 109 - 250)
		nicam_demod.tr_lpf_kp = 0x2; // 0x0: 2^2, the max Kp
		g_NicamEnhanceTrueDetect = 0;
	}

	AIO_WriteRegister(AUDIO_nicam_demod_reg, nicam_demod.regValue);

	if (Enable == 1) {
		if (org_sound_std == ATV_SOUND_STD_NICAM_BG) {
			msd_result.reg_std = ATV_SOUND_STD_BG_MONO;
		} else if (org_sound_std == ATV_SOUND_STD_NICAM_DK) {
			msd_result.reg_std = ATV_SOUND_STD_DK_MONO;
		} else if (org_sound_std == ATV_SOUND_STD_NICAM_I) {
			msd_result.reg_std = ATV_SOUND_STD_FM_MONO_NO_I;
		} else if (org_sound_std == ATV_SOUND_STD_NICAM_L) {
			msd_result.reg_std = ATV_SOUND_STD_AM_MONO;
		} else {
			alog_debug("Current FW STD is not NICAM %d\n", org_sound_std);
		}

		AIO_WriteRegister(AUDIO_msd_result_reg, msd_result.regValue);
		//audio_hw_usleep(10000);//10ms	From DIC, no need to delay

		msd_result.regValue = AIO_ReadRegister(AUDIO_msd_result_reg);
		msd_result.reg_std = org_sound_std;
		AIO_WriteRegister(AUDIO_msd_result_reg, msd_result.regValue);

		//if hw_std is not nicam, do not delay.
		if (AtvIsNicamSystem((ATV_SOUND_STD)msd_result.hw_detected_std) == 0) {
			alog_debug("\x1b[33mNot Nicam now %x\x1b[m\n", msd_result.hw_detected_std);
			return;
		}

		i = nicam_decode_ctrl.status_debounce_cnt;  //Delay time depends on nicam_decode_ctrl
		audio_hw_usleep((32 + 16 * i)*1000); // Delay time = 31ms + n*16 ms
		alog_debug("AtvEnhanceNicamTrueDetect finish delay=%d ms\n", 32 + 16 * i);
	}
}

void NicamSignalProcess(void)
{
	ATV_SOUND_MODE  NONBTSC_SOUND_MODE;
	static int g_ContinueNicamNum = 0;

	static int32_t g_errorRateDebunce = 0;
	int32_t i, maxindex, changeSoundMode;
	uint32_t maxerrorrate = 0;

	/* MAXDEBOUNCE2 replace by global variable g_NicamMaxErrorDebounce
	Audio_AtvSetNicamErrorRateDebounce(MAXDebounce) can set g_NicamMaxErrorDebounce
	Wu Yi-Chiao 2013/08/02*/
	//#define MAXDEBOUNCE2  (30)

	// Clayton 2012/06/19
	// speed up week NICAM signal to switch MONO
	// Ref Pacific project
	
	//#define MINDEBOUNCE2  (0)
#define MINDEBOUNCE2  (10) //25//5
	

	//#define FIRSTIMEBOUNCESTART  (20)
#define FIRSTIMEBOUNCESTART  (g_NicamMaxErrorDebounce - 10)

#define  FIRSTTIMECHECKTIME (10)  //8->6
#define NICAMERRORRATETHRESHOLD (0x100)


	static uint32_t g_nicam_soundmode_prev;
	static uint32_t g_nicam_soundmode_debounce;


#define NICAMSOUNDCHANGEMAX  (10)

#define NICAMSOUNDCHANGEMIN (0)

#define FIRST_TIME_SPEEDUP_STABLE_THRESHOLD (0x20)

#define SPEEDUP_STABLE_THRESHOLD (0x10)

	int32_t NicamFirstTimeCheckloop;

	NicamFirstTimeCheckloop = FIRSTTIMECHECKTIME;


	if (g_FirstTimeForce2PlayMono)
		NicamFirstTimeCheckloop = 1;

	if (CHANGESTDSTATUS_FIRST_TIME == g_ChangeStdStatus) {
		// clean flag
		//	ROS_ENTER_CRITICAL();
		//	g_ChangeStdStatus= CHANGESTDSTATUS_DETECT;
		g_ChangeStdStatus = CHANGESTDSTATUS_INIT; // peter

		g_NicamSignalStable = 0;

		g_errorRateDebunce = FIRSTIMEBOUNCESTART;
		g_ContinueNicamNum = 0;
		//	drv_audio_reset_nicam_overflow();// rest prescale
		//		ROS_EXIT_CRITICAL();

		g_FirstTimeSoundMode[0] = 0;
		g_FirstTimeSoundMode[1] = 0;
		g_FirstTimeSoundMode[2] = 0;
		g_FirstTimeSoundMode[3] = 0;

		//	g_printNicamLoop = 0 ;
		// set timing step
		//	g_TimingStepIndex = 0;

	} else if (CHANGESTDSTATUS_INIT == g_ChangeStdStatus) {

		g_ContinueNicamNum++;

		if (g_ContinueNicamNum < 5) //wait stable
			return;

		g_ChangeStdStatus = CHANGESTDSTATUS_DETECT;
		g_ContinueNicamNum = 0; // reset nicam num

	} else { //CHANGESTDSTATUS_DETECT

		if (g_errorRateDebunce < g_NicamMaxErrorDebounce) {
			//	if(g_printfNicamStatus == 1)
			//	ATV_LOG( "ni status = %x  dbounce  %x\n", g_ChangeStdStatus, g_errorRateDebunce);
		}

		if (g_ContinueNicamNum <= 90000)
			g_ContinueNicamNum++;

		if (g_ContinueNicamNum <= NicamFirstTimeCheckloop) { // no signal now
								     // sound mode
			AtvGetNicamHhwSoundMode(&NONBTSC_SOUND_MODE);
			alog_info("ni  %x  su  %x\n", g_ContinueNicamNum, NONBTSC_SOUND_MODE);
			switch (NONBTSC_SOUND_MODE) {
			case ATV_SOUND_MODE_DUAL: // no this case
				g_FirstTimeSoundMode[2] = g_FirstTimeSoundMode[2] + 1;
				break;
			default:
			case ATV_SOUND_MODE_MONO  :
				g_FirstTimeSoundMode[0] = g_FirstTimeSoundMode[0] + 1;
				break;
			case 	ATV_SOUND_MODE_STEREO   :
				g_FirstTimeSoundMode[1] = g_FirstTimeSoundMode[1] + 1;
				break;
			case 	ATV_SOUND_MODE_SAP_MONO   :


				break;
			case ATV_SOUND_MODE_SAP_STEREO:

				break;
			}

			//Frank: speed up sound mode out. At this time, sound does not output.
			g_last_soundmode[2] = g_last_soundmode[1];
			g_last_soundmode[1] = g_last_soundmode[0];
			g_last_soundmode[0] = NONBTSC_SOUND_MODE;

#define NICAM_SOUNDMODE_OUT_CNT 3
			if ((g_ContinueNicamNum >=  NICAM_SOUNDMODE_OUT_CNT) && (g_ContinueNicamNum < NicamFirstTimeCheckloop)) {
				if ((g_last_soundmode[2] == g_last_soundmode[1]) && (g_last_soundmode[2] == g_last_soundmode[0])) {
					g_nicam_soundmode = g_last_soundmode[0];
				}
			}

			// error rate
			maxerrorrate = AtvGetNicamErrorRate(10);
			alog_debug("maxerrorrate / g_Std_energy_585 / g_Std_energy_6 / g_CurrentStd / g_nicam_soundmode_debounce = %x %x %x %x %x\n", maxerrorrate, g_Std_energy_585, g_Std_energy_6, g_CurrentStd, g_nicam_soundmode_debounce);

			if (maxerrorrate > g_NicamErrorRateThresholdLow) {
				if (g_errorRateDebunce > MINDEBOUNCE2)
					// Clayton 2012/06/19
					// speed up week NICAM signal to switch MONO
					// Ref Pacific project
					
					//g_errorRateDebunce--;
					g_errorRateDebunce -= 3;
				
			} else { // unstable , can detected
				if (g_errorRateDebunce < g_NicamMaxErrorDebounce)
					g_errorRateDebunce++;

				if (maxerrorrate < SPEEDUP_STABLE_THRESHOLD) {
					if (g_errorRateDebunce < g_NicamMaxErrorDebounce)
						g_errorRateDebunce++;

					if (maxerrorrate == 0) {
						if (g_errorRateDebunce < g_NicamMaxErrorDebounce)
							g_errorRateDebunce++;
					}

				}

			}

			alog_info("ni  er rt  %x de %x \n", maxerrorrate, g_errorRateDebunce);
		} else   if (g_ContinueNicamNum == (NicamFirstTimeCheckloop + 1)) {  //  first time to play & normal case


			// sound mode
			maxindex = 0;
			for (i = 1; i < 3; i++) {
				if (g_FirstTimeSoundMode[i] > g_FirstTimeSoundMode[maxindex])
					maxindex = i;
			}

			alog_info("n r p s %x  %x\n", maxindex, g_FirstTimeSoundMode[maxindex]);

			if (maxindex == 0)
				g_nicam_soundmode = ATV_SOUND_MODE_MONO;
			else if (maxindex == 1)
				g_nicam_soundmode = ATV_SOUND_MODE_STEREO;
			else
				g_nicam_soundmode = ATV_SOUND_MODE_DUAL;

			//setting default sound mode
			if (g_UserTVNICAMISStereo == 0 && g_InForceSoundSelectMode == 0) {
				g_UserTVNICAMISStereo = 1;
				g_UserTVNICAMLanguage = 0;
				alog_info("default ni su %d ", g_nicam_soundmode);
			}

			g_nicam_soundmode_prev = g_nicam_soundmode;
			g_nicam_soundmode_debounce = NICAMSOUNDCHANGEMAX; // reset

			// Clayton 2013/4/12
			// Add to push msg "ATV_STATUS_FIRSTTIME_SOUNDMODE" for 1st time soundmode detection out when set channel
			if (audioStatusChanageCallBack != NULL)
				audioStatusChanageCallBack(ATV_STATUS_FIRSTTIME_SOUNDMODE);

			// error rate
			maxerrorrate = AtvGetNicamErrorRate(10);

			if ((maxerrorrate <= FIRST_TIME_SPEEDUP_STABLE_THRESHOLD) && (g_errorRateDebunce >= FIRSTIMEBOUNCESTART)) // signal is good
				g_errorRateDebunce = g_NicamMaxErrorDebounce;

			alog_info("ni f  error rate  %x de %x \n", maxerrorrate, g_errorRateDebunce);

			if (g_errorRateDebunce >= g_NicamMaxErrorDebounce) {
				g_errorRateDebunce = g_NicamMaxErrorDebounce; // rest
				g_NicamSignalStable = 1;
			} else {
				g_errorRateDebunce = MINDEBOUNCE2;
				g_NicamSignalStable = 0;

				if ((audioStatusChanageCallBack != NULL)) { // different system
					audioStatusChanageCallBack(ATV_STATUS_NICAM_WEAK_SIGNAL);
				}
			}

			alog_info("ni f stable %x  \n", g_NicamSignalStable);

			if (g_FirstTimeForce2PlayMono || g_InForceSoundSelectMode) {
				g_UserTVNICAMISStereo = 0;
				g_UserTVNICAMLanguage = 0;
			}

			// first time play
			if (g_NicamSignalStable == 1) { // unstable , can detected

				{
					//	if(isNicamOverFlow())// check at normal mode
					{
						//	ATV_LOG( "nicam overflow \n");
						//	NicamDeemphasisControl(1);
						//	CleanNicamOverFlowStatus();
					}

				}

				if (1 == g_UserTVNICAMISStereo) { // unstable , can detected

					if (AtvIsPlayDigitalState()) {
						// change channel
						if (0 == AtvIsCurrentNicamSoundSelectCorrect(g_UserTVNICAMLanguage, g_nicam_soundmode)) {
							alog_info("ch  to  lang\n");
							if (g_UserTVNICAMLanguage == 0) // Language A
								Audio_AtvSetSoundSelect(ATV_SOUND_SEL_STEREO_A);
							else if (g_UserTVNICAMLanguage == 1) // Language B
								Audio_AtvSetSoundSelect(ATV_SOUND_SEL_STEREO_B);
							else
								Audio_AtvSetSoundSelect(ATV_SOUND_SEL_STEREO_AB);
						}
					} else {
						// switch analog to digital
						//	drv_audio_set_backendplay(AUD_DISABLE);
						// [Clayton] No need to set Mute & delay too long when Analog-->Dig NICAM under switch channel 1st time sound mode
						// [Start]
						/*
						AtvSetMute(ATV_ENABLE, ATV_CH_ID_L | ATV_CH_ID_R | ATV_CH_ID_LS | ATV_CH_ID_RS);
						audio_hw_usleep(170000);
						*/
						// [End]

						AtvSwitch2NicamDigial();
						alog_info("3 to dig un mute 111111\n");

						//audio_hw_usleep(270000); // 100 ms 130ms x 180ms 220ms 270ms+3
						AtvSetMute(ATV_DISABLE);

						//					ROS_ENTER_CRITICAL();
						//	drv_audio_enable_nicam_interrupt(AUD_ENABLE);
						//					ROS_EXIT_CRITICAL();
					}
					//	if((g_AudioTVControlFlag & ENABLE_NICAM_PRESCALE_OVERFLOW)  == ENABLE_NICAM_PRESCALE_OVERFLOW)
					//		drv_audio_enable_nicam_overflow_Int(1); // enable nicam precale detected
				} else {   // user want to play analog
					if (AtvIsPlayDigitalState()) {
						//	drv_audio_set_backendplay(AUD_DISABLE);
						alog_info("to ana\n");
						AtvSwitch2NicamAnalog(); // switch to analog
					}
				}
			} else { // speed up
				if (AtvIsPlayDigitalState()) {
					alog_info("4 to ana\n");
					AtvSwitch2NicamAnalog();
				}

				if (g_EnableNicamAutoRecovery == 0) {
					// to play mono
					g_UserTVNICAMISStereo = 0;
					g_UserTVNICAMLanguage = 0;
				}

			}

			AtvResetNicamOverflow(); //

			alog_info("n r p \n");
			//	drv_audio_set_backendplay(AUD_ENABLE);
			//	drv_audio_set_mute(AUD_DISABLE,AUD_CHAN_ALL,AUD_TV_MUTE);
			AtvSetModeDebounceCoef(g_CurrentStd);
			AtvCleanTVMuteNum();
			//audio_hw_usleep(280000);//Add for LG
			HwpSetVolume_SIF(0);
			AtvSetMute(ATV_DISABLE);
			//	ROS_ENTER_CRITICAL();
			g_TVAudioReady = 1;
			if (g_UserChangeNicamSelectFlag == 1)
				g_UserChangeNicamSelectFlag = 0;

			//Frank: add for detect nicam strength
			g_nicam_carrier_shift = 0;

			//	ROS_EXIT_CRITICAL();
			//	get_system_time(&g_endStd);
			//	g_printfTime = 1;
			//
		} else { // normal case // low rf

			// sound mode
			AtvGetNicamHhwSoundMode(&NONBTSC_SOUND_MODE);
			changeSoundMode = 0;
			if ((NONBTSC_SOUND_MODE != (ATV_SOUND_MODE)g_nicam_soundmode) && ((ATV_SOUND_MODE)g_nicam_soundmode_prev == NONBTSC_SOUND_MODE)) {

				if (g_nicam_soundmode_debounce > NICAMSOUNDCHANGEMIN)
					g_nicam_soundmode_debounce--;
				else {
					alog_info(" nicam new sound mode %x\n", NONBTSC_SOUND_MODE);
					g_nicam_soundmode = NONBTSC_SOUND_MODE;
					g_nicam_soundmode_debounce = NICAMSOUNDCHANGEMAX; // reset
					changeSoundMode = 1;
				}

			} else {
				//if(g_nicam_soundmode_debounce < SOUNDCHANGEMAX)
				//	g_nicam_soundmode_debounce++;
				g_nicam_soundmode_debounce = NICAMSOUNDCHANGEMAX; // reset
			}

			g_nicam_soundmode_prev = NONBTSC_SOUND_MODE;



			if ((changeSoundMode == 1) && (audioStatusChanageCallBack != NULL)) {
				audioStatusChanageCallBack(ATV_STATUS_SOUNDMODE_CHANGE);
			}

			// error rate
			maxerrorrate = AtvGetNicamErrorRate(10);

			//Frank check nicam carrier shift
			if (maxerrorrate == 0 && g_Std_energy_585 == 0 && (g_Std_energy_585 + 0x500/*0x1000*/) < g_Std_energy_6 && g_CurrentStd == ATV_SOUND_STD_NICAM_BG) {
				g_nicam_carrier_shift++;
				if (g_nicam_carrier_shift > NICAM_CARRIER_SHIFT_TH) {
					g_nicam_carrier_shift = NICAM_CARRIER_SHIFT_TH + 1;
				}
			} else {
				if (g_nicam_carrier_shift < NICAM_CARRIER_SHIFT_TH) {
					g_nicam_carrier_shift--;
					if (g_nicam_carrier_shift < 0) {
						g_nicam_carrier_shift = 0;
					}
				}
			}

			alog_debug("g_nicam_carrier_shift = %d\n", g_nicam_carrier_shift);

			//		g_printNicamLoop++;

			//				if(g_printNicamLoop >= 1000)
			{
				//				     g_printNicamLoop=0;
			}

			//			if(( (g_printNicamLoop % 60) == 0) && (maxerrorrate > 50))
			//			ATV_LOG( "ni er rate  %x de %x \n", maxerrorrate, g_errorRateDebunce);


			//if( (g_AudioTVPrintFlag & ATV_PRINT_FLAG_ENABLE_NORMAL_PRINT) == ATV_PRINT_FLAG_ENABLE_NORMAL_PRINT)
			alog_debug("ni er rate  %x de %x \n", maxerrorrate, g_errorRateDebunce);

			if (maxerrorrate >= g_NicamErrorRateThresholdNormal) {
				g_errorRateDebunce--;
				if (maxerrorrate >= g_NicamErrorRateThresholdHigh)
					g_errorRateDebunce--;

				if (maxerrorrate == 0xffff)
					g_errorRateDebunce--;

			} else if (maxerrorrate <= g_NicamErrorRateThresholdLow) { // low rf
				if (g_errorRateDebunce < g_NicamMaxErrorDebounce)
					g_errorRateDebunce++;

				if (maxerrorrate < SPEEDUP_STABLE_THRESHOLD) {
					if (g_errorRateDebunce < g_NicamMaxErrorDebounce)
						g_errorRateDebunce++;

					//  if(g_ContinueNicamNum <= FIRSTTIMECHECKTIME ) // need time to check if stable
					{
						if (maxerrorrate == 0)
							g_errorRateDebunce += 2; // speeup first time
					}
				}
			} else {

				if (g_NicamSignalStable == 0) {
					g_errorRateDebunce = MINDEBOUNCE2;

				} else {
					// stable case
					g_errorRateDebunce = g_NicamMaxErrorDebounce; // rest

				}
			}

			if (g_errorRateDebunce >= g_NicamMaxErrorDebounce) {
				g_NicamMaxErrorDebounce = 0x1e;
				g_errorRateDebunce = g_NicamMaxErrorDebounce;
				if (g_NicamSignalStable == 0) {
					g_NicamSignalStable = 1;
					// From unstable  2  stable
					if ((audioStatusChanageCallBack != NULL)) {
						audioStatusChanageCallBack(ATV_STATUS_NICAM_RECOVERY);
					}
				}

				g_NicamSignalStable = 1;

			} else if (g_errorRateDebunce <= MINDEBOUNCE2) {
				//Frank
				if (g_nicam_carrier_shift >= NICAM_CARRIER_SHIFT_TH) {
					g_NicamMaxErrorDebounce = 0x1A5; //0x185;
				}

				g_errorRateDebunce = MINDEBOUNCE2;
				if (g_NicamSignalStable == 1) {
					g_NicamSignalStable = 0;
					// From stable  2  unstable
					if ((audioStatusChanageCallBack != NULL)) {
						audioStatusChanageCallBack(ATV_STATUS_NICAM_WEAK_SIGNAL);
					}
				}

				g_NicamSignalStable = 0;
			}

			if (g_NicamSignalStable == 1) { // singal stable

				if ((g_AudioTVControlFlag&ENABLE_NICAM_PRESCALE_OVERFLOW_MASK) == ENABLE_NICAM_PRESCALE_OVERFLOW) {
					if (AtvIsNicamOverflow()) {

						//USER:Peter_Lin DATE:2011/2/10
						// nicam overflow debounce
						
						g_NicamOverFlowCnt++;
						alog_info("nicam overflow %x \n", g_NicamOverFlowCnt);
						if (g_NicamOverFlowCnt < 3) {
							AtvCleanNicamOverFlowStatus();
							; // clean status
						} else if (g_NicamOverFlowCnt == 3) {
							AtvNicamDeemphasisBypass(1);
							alog_info("nicam overflow \n");
						}
						

					}
				}

				if (1 == g_UserTVNICAMISStereo) { // system has signal
					if (AtvIsPlayDigitalState()) {
						// change channel
						if (0 == AtvIsCurrentNicamSoundSelectCorrect(g_UserTVNICAMLanguage, g_nicam_soundmode)) {
							AtvSetMute(ATV_ENABLE);
							//audio_hw_usleep(70000);
							AtvResetNicamOverflow(); // reset precale
							alog_info("ch  to  lang\n");
							if (g_UserTVNICAMLanguage == 0) // Language A
								Audio_AtvSetSoundSelect(ATV_SOUND_SEL_STEREO_A);
							else if (g_UserTVNICAMLanguage == 1) // Language B
								Audio_AtvSetSoundSelect(ATV_SOUND_SEL_STEREO_B);
							else
								Audio_AtvSetSoundSelect(ATV_SOUND_SEL_STEREO_AB);

							//	drv_audio_set_backendplay(AUD_ENABLE);
							//	ScalerTimer_DelayXms(200);
							//audio_hw_usleep(250000);
							AtvSetMute(ATV_DISABLE);

							//	if((g_AudioTVControlFlag & ENABLE_NICAM_PRESCALE_OVERFLOW)  == ENABLE_NICAM_PRESCALE_OVERFLOW)
							//		drv_audio_enable_nicam_overflow_Int(1); // enable nicam precale interrupt
						}
					} else {
						// switch analog to digital
						AtvSetMute(ATV_ENABLE);
						//audio_hw_usleep(70000);
						AtvResetNicamOverflow(); // reset nicam precale
									 //	drv_audio_set_backendplay(AUD_DISABLE);

						AtvSwitch2NicamDigial();
						alog_info("3 to dig un mute\n");

						//	drv_audio_set_backendplay(AUD_ENABLE);
						//	ScalerTimer_DelayXms(300);
						//audio_hw_usleep(250000); // 100 ms
						AtvSetMute(ATV_DISABLE);
						//					ROS_ENTER_CRITICAL();
						//	drv_audio_enable_nicam_interrupt(AUD_ENABLE);
						//					ROS_EXIT_CRITICAL();
						//	if((g_AudioTVControlFlag & ENABLE_NICAM_PRESCALE_OVERFLOW)  == ENABLE_NICAM_PRESCALE_OVERFLOW)
						//		drv_audio_enable_nicam_overflow_Int(1); // enalbe nicam prescale intterupt
					}


				} else {   // user want to play analog
					if (AtvIsPlayDigitalState()) {
						AtvSetMute(ATV_ENABLE);
						//audio_hw_usleep(110000);
						//	ScalerTimer_DelayXms(200);
						AtvResetNicamOverflow(); // rest nicam prescale
									 //	drv_audio_set_backendplay(AUD_DISABLE);
						alog_info("to ana\n");
						AtvSwitch2NicamAnalog(); // switch to analog
									 //	drv_audio_set_backendplay(AUD_ENABLE);
									 //	ScalerTimer_DelayXms(200);
						//audio_hw_usleep(310000);
						AtvSetMute(ATV_DISABLE);
					}

					// check deviation
					CheckAndChangeDeviation();  // if signal from bad to good , system still at mono 1, need to process mono2

				}
			} else {  // mono
				if (AtvIsPlayDigitalState()) {
					alog_info("4 to ana\n");
					AtvSetMute(ATV_ENABLE);
					//	drv_audio_set_backendplay(AUD_DISABLE);
					//	ScalerTimer_DelayXms(200);
					//audio_hw_usleep(70000); // 50 ms
					AtvSwitch2NicamAnalog();
					//	drv_audio_set_backendplay(AUD_ENABLE);
					//audio_hw_usleep(250000); // 50 ms
					AtvSetMute(ATV_DISABLE);
					AtvResetNicamOverflow(); // reset nicam precale
				}

				if (g_EnableNicamAutoRecovery == 0) {
					// to force play mono
					g_UserTVNICAMISStereo = 0;
					g_UserTVNICAMLanguage = 0;
				}

				// check deviation
				CheckAndChangeDeviation();

			}

			if (g_UserChangeNicamSelectFlag == 1)
				g_UserChangeNicamSelectFlag = 0;

		}

	}
}

void AtvGetHwBtscsSoundMode(ATV_SOUND_MODE *p_sound_info)
{
	audio_btsc_pilot_status_RBUS btsc_pilot_status;
	audio_btsc_sap_status_RBUS btsc_sap_status;
	audio_btsc_sap_noise_RBUS btsc_sap_noise;

	uint32_t result;

#define  SAP_NOISE_GAP (0)

	// get analog sound_mode
	btsc_pilot_status.regValue = AIO_ReadRegister(AUDIO_btsc_pilot_status_reg);
	if (btsc_pilot_status.w1pilotpresent == 1)
		result = 1;
	else
		result = 0;

	btsc_sap_status.regValue = AIO_ReadRegister(AUDIO_btsc_sap_status_reg);
	btsc_sap_noise.regValue = AIO_ReadRegister(AUDIO_btsc_sap_noise_reg);
	//for debug
	
	//alog_info("stereo energy %x \n", btsc_pilot_status.regValue);
	//alog_info("sap / noise energy %x %x \n", btsc_sap_status.regValue, btsc_sap_noise.regValue );
	
	if (btsc_sap_status.w1sapqualitygood == 1 && ATV_GetFmRadioMode() == AUDIO_ATV_FM_RADIO_STOP) {

		if (btsc_sap_status.w10sapmagnitude >= (btsc_sap_noise.w10sapnoise + SAP_NOISE_GAP))
			result = result|(1 << 1);
		else
			alog_info("noise to sap %x %x \n", btsc_sap_status.regValue, btsc_sap_noise.regValue);

	}

	switch (result) {
	case 0 :
		*p_sound_info = ATV_SOUND_MODE_MONO;
		break;
	case 1 :
		*p_sound_info = ATV_SOUND_MODE_STEREO;
		break;
	case 2 :
		*p_sound_info = ATV_SOUND_MODE_SAP_MONO;
		break;
	case 3 :
		*p_sound_info = ATV_SOUND_MODE_SAP_STEREO;
		break;
	}
}

void AtvChageBTSCSoundMode(ATV_SOUND_MODE sound_mode)
{
	audio_mode_detect_RBUS mode_detect;
	audio_msd_crtl_word_RBUS	msd_crtl_word;

	// Clayton 2013/1/3
	//audio_msd_result_RBUS msd_result;
	//audio_down_sample_control_for_playback_RBUS down_sample_control_for_playback;
	//down_sample_control_for_playback.regValue = AIO_ReadRegister(AUDIO_down_sample_control_for_playback_reg);
	msd_crtl_word.regValue = AIO_ReadRegister(AUDIO_msd_crtl_word_reg);

	//down_sample_control_for_playback.fifo_ch0_source = AUD_FIFO_CHANNEL_L;
	//down_sample_control_for_playback.fifo_ch1_source = AUD_FIFO_CHANNEL_R;
	//msd_result.regValue=  AIO_ReadRegister(AUDIO_msd_result_reg);

	//msd_result.reg_std = ATV_SOUND_STD_BTSC;// default

	//USER:Peter_Lin DATE:2010/10/12
	// fix btsc sap disapper noise
	
	g_CurrentIsPlaySAP = 0;
	//  [end]

	switch (sound_mode) {
	case ATV_SOUND_MODE_DUAL: // no this case

		break;
	default:
	case ATV_SOUND_MODE_MONO  :
		AtvEnableBTSCSAPFreqCompensate(0);  //Disable SAP compensation
#ifdef TV001_BOARD
if(g_user_config == AUDIO_USER_CONFIG_TV001)
		rtk_snd_enhance_btsc_separation(0);   //0: release BTSC stereo separation enhancement
#endif
		// Clayton 2014/3/7, HW fixed BTSC issue, so no need to constrain BTSC deviation setting
		//AtvChangeDeviation(ATV_SOUND_STD_BTSC, FM_BW_NORMAL);

		// Clayton 2013/1/3
		// Remove when BTSC MONO will change STD to MN MONO
		// due to HW had integrated FM LPF BW into BTSC STD,
		// But FM LPF BW can only set normal setting without ["Ultra hdv mode" or "under 98MHz"]
		//msd_result.reg_std = ATV_SOUND_STD_MN_MONO;// mono to decode btsc mono case


		break;
	case ATV_SOUND_MODE_STEREO   :
		AtvEnableBTSCSAPFreqCompensate(0);  //Disable SAP compensation
						    // Clayton 2014/3/7, HW fixed BTSC issue, so no need to constrain BTSC deviation setting
						    //AtvChangeDeviation(ATV_SOUND_STD_BTSC, FM_BW_NORMAL);
		Audio_AtvSetSoundSelect(ATV_SOUND_SEL_STEREO_A);

		if (g_UserTVBTSCISStereo == 0) {  // A
#ifdef TV001_BOARD
if(g_user_config == AUDIO_USER_CONFIG_TV001)
			rtk_snd_enhance_btsc_separation(0);   //0: release BTSC stereo separation enhancement
#endif
			if (msd_crtl_word.sound_select != ATV_SOUND_SEL_FMAM) {  // Lang B
				msd_crtl_word.sound_select = ATV_SOUND_SEL_FMAM; // mono

			}
		} else {
			// stereo
#ifdef TV001_BOARD
if(g_user_config == AUDIO_USER_CONFIG_TV001)
			rtk_snd_enhance_btsc_separation(1);   // 1: enhance BTSC stereo separation
#endif
			if (msd_crtl_word.sound_select != ATV_SOUND_SEL_STEREO_A) {
				msd_crtl_word.sound_select = ATV_SOUND_SEL_STEREO_A; // stereo
			}
		}

		break;
	case 	ATV_SOUND_MODE_SAP_MONO   :
		// Clayton 2014/3/7, HW fixed BTSC issue, so no need to constrain BTSC deviation setting
		//AtvChangeDeviation(ATV_SOUND_STD_BTSC, FM_BW_NORMAL);
#ifdef TV001_BOARD
if(g_user_config == AUDIO_USER_CONFIG_TV001)
		rtk_snd_enhance_btsc_separation(0);   //0: release BTSC stereo separation enhancement
#endif
		if (g_UserTVBTSCSAP == 0) {    // Clayton ; Date: 2012/6/25
			AtvEnableBTSCSAPFreqCompensate(0);  //Disable SAP compensation
			if (msd_crtl_word.sound_select != ATV_SOUND_SEL_STEREO_A) {
				msd_crtl_word.sound_select = ATV_SOUND_SEL_STEREO_A; // mono
			}
		} else {  // mono
			AtvEnableBTSCSAPFreqCompensate(1);  //Enable SAP compensation
			if (msd_crtl_word.sound_select != ATV_SOUND_SEL_STEREO_B) {
				msd_crtl_word.sound_select = ATV_SOUND_SEL_STEREO_B;
			}

			//USER:Peter_Lin DATE:2010/10/12
			// fix btsc sap disapper noise
			
			g_CurrentIsPlaySAP = 1;
			
		}

		break;
	case ATV_SOUND_MODE_SAP_STEREO:
		// Clayton 2014/3/7, HW fixed BTSC issue, so no need to constrain BTSC deviation setting
		//AtvChangeDeviation(ATV_SOUND_STD_BTSC, FM_BW_NORMAL);
		Audio_AtvSetSoundSelect(ATV_SOUND_SEL_STEREO_A);

		if (g_UserTVBTSCSAP == 0) {
			AtvEnableBTSCSAPFreqCompensate(0);  //Disable SAP compensation
			if (g_UserTVBTSCISStereo == 0) {  // A
#ifdef TV001_BOARD
if(g_user_config == AUDIO_USER_CONFIG_TV001)
				rtk_snd_enhance_btsc_separation(0);   //0: release BTSC stereo separation enhancement
#endif
				if (msd_crtl_word.sound_select != ATV_SOUND_SEL_FMAM) {  // Lang B
					msd_crtl_word.sound_select = ATV_SOUND_SEL_FMAM;    // Clayton 2013/1/3

				}
			} else {
				// stereo
#ifdef TV001_BOARD
if(g_user_config == AUDIO_USER_CONFIG_TV001)
				rtk_snd_enhance_btsc_separation(1);   // 1: enhance BTSC stereo separation
#endif
				if (msd_crtl_word.sound_select != ATV_SOUND_SEL_STEREO_A) {
					msd_crtl_word.sound_select = ATV_SOUND_SEL_STEREO_A; // stereo
				}
			}
		} else { //one times
			AtvEnableBTSCSAPFreqCompensate(1);  //Enable SAP compensation
#ifdef TV001_BOARD
if(g_user_config == AUDIO_USER_CONFIG_TV001)
			rtk_snd_enhance_btsc_separation(0);   //0: release BTSC stereo separation enhancement
#endif
			if (msd_crtl_word.sound_select != ATV_SOUND_SEL_STEREO_B) {
				msd_crtl_word.sound_select = ATV_SOUND_SEL_STEREO_B; // SAP
			}

			//USER:Peter_Lin DATE:2010/10/12
			// fix btsc sap disapper noise
			
			g_CurrentIsPlaySAP = 1;
			
		}

		break;
	}

	mode_detect.regValue = AIO_ReadRegister(AUDIO_mode_detect_reg);

	switch (sound_mode) {
	default :
	case 	ATV_SOUND_MODE_MONO  :
		mode_detect.mode_result = 0;
		break;
	case ATV_SOUND_MODE_STEREO   :
		mode_detect.mode_result = 1;
		break;
	case ATV_SOUND_MODE_DUAL  :
		mode_detect.mode_result = 0; // no this case
		break;
	case ATV_SOUND_MODE_SAP_MONO :
		mode_detect.mode_result = 2;
		break;
	case ATV_SOUND_MODE_SAP_STEREO:
		mode_detect.mode_result = 3;
		break;

	}

	AIO_WriteRegister(AUDIO_mode_detect_reg, mode_detect.regValue);
	//	AIO_WriteRegister(AUDIO_mode_detect_reg, mode_detect.regValue);

	AIO_WriteRegister(AUDIO_msd_crtl_word_reg, msd_crtl_word.regValue);

}
#if 0//ndef TV001_BOARD
void AtvRestartIFDAGCGain(void)
{
	audio_sif_agc3_ctrl_RBUS sif_agc3_ctrl;

	sif_agc3_ctrl.regValue =	AIO_ReadRegister(AUDIO_sif_agc3_ctrl_reg);
	sif_agc3_ctrl.aagc_en = 1;
	AIO_WriteRegister(AUDIO_sif_agc3_ctrl_reg, sif_agc3_ctrl.regValue);
}
#endif
void AtvResetMSD(void)
{
	audio_msd_crtl_word_RBUS msd_crtl_word;

	msd_crtl_word.regValue = AIO_ReadRegister(AUDIO_msd_crtl_word_reg);
	msd_crtl_word.msd_reset_n = 0; // eset
	msd_crtl_word.msd_reset_n = 1;
	AIO_WriteRegister(AUDIO_msd_crtl_word_reg, msd_crtl_word.regValue);

}

void Audio_AtvCleanTVSourceData(void)
{
	alog_info("clean TV source \n");
	AtvUpdateState(ATV_TASK_STOP);
	//AtvUpdateState(); // linmc@20121206...Resolve ap will be muted when quickly switches tv to other source
	AtvEnableTvInterrupt(ATV_DISABLE);
	AadConnect_CleanStatusData();
	AtvCleanTVMuteNum(); // clean audio use mute
			     //AtvSetHwDetecteMode(ATV_HW_DISABLE);
	AtvSetMute(ATV_DISABLE);

	g_AudioClkStatus = AUDIO_IPT_SRC_UNKNOWN;
	g_AudioSubClkStatus = AUDIO_IPT_SRC_UNKNOWN;

	g_SetMode_Mute = 0;
	g_InternalDecoder_0_FAIL = 0;
	g_InternalDecoder_1_FAIL = 0;
}

// Clayton 2012/7/3
// Add BTSC Sound mode change debounce threshold setting API
// Max: debounce count start from Max threshold to down count(Default=20 (0x14))
// Min: low threshold for down count finish target (Default=0)
void Audio_AtvSetBTSCSoundChangeDebounce(int SOUNDCHANGEMAX, int SOUNDCHANGEMIN)
{

	if (SOUNDCHANGEMIN > SOUNDCHANGEMAX)
		return;

	g_BTSCSOUNDCHANGEMAX = SOUNDCHANGEMAX;
	g_BTSCSOUNDCHANGEMIN = SOUNDCHANGEMIN;

	alog_info("[ATV][Clayton] BTSC sound mode change debounce %x %x \n", g_BTSCSOUNDCHANGEMAX, g_BTSCSOUNDCHANGEMIN);


}

void AtvEnableBTSCSAPFreqCompensate(uint32_t Enable)
{
	if(g_user_config == AUDIO_USER_CONFIG_TV001)
	{
#ifdef RTD289X	//RTD289X SIF-EQ has distortion issue, keep using HW-EQ to compensate BTSC & AM freq response
		audio_eq_control_register_RBUS	eq_control_register;

		AtvBTSCSAPFreqCompensate();
		eq_control_register.regValue = AIO_ReadRegister(AUDIO_EQ_Control_Register_reg);

		if (g_Atvpath_PB == 1) {
			eq_control_register.eq_band1_enable = Enable;
			eq_control_register.eq_band2_enable = Enable;
		} else if (g_Atvpath_PB == 0) {
			eq_control_register.eq_band1_enable = 0;
			eq_control_register.eq_band2_enable = 0;
		}

		AIO_WriteRegister(AUDIO_EQ_Control_Register_reg, eq_control_register.regValue);
#else	//After RTD287X & RTD284X, SIF-EQ distortion issue is fixed, back to use SIF-EQ
		audio_eq_tvd_bp_control_RBUS	eq_tvd_bp_control;

		if(audio_drv_set_sif_eq_coef_48K(&atv_sif_eq_48k_tab[ATV_SOUND_STD_BTSC]) != 0)
			alog_err("Set BTSC SAP Freq Compensate Fail!!\n");

		eq_tvd_bp_control.regValue = AIO_ReadRegister(AUDIO_EQ_tvd_bp_Control_reg);
		eq_tvd_bp_control.eq_tvd_band1_enable = Enable;
		eq_tvd_bp_control.eq_tvd_band2_enable = Enable;

		AIO_WriteRegister(AUDIO_EQ_tvd_bp_Control_reg, eq_tvd_bp_control.regValue);
#endif
	}
}
#ifdef RTD289X
void AtvBTSCSAPFreqCompensate(void)
{
	audio_eq_bp1_1_RBUS eq_bp1_1;
	audio_eq_bp1_2_RBUS eq_bp1_2;
	audio_eq_bp2_1_RBUS eq_bp2_1;
	audio_eq_bp2_2_RBUS eq_bp2_2;

	eq_bp1_1.regValue = AIO_ReadRegister(AUDIO_EQ_bp1_1_reg);
	eq_bp1_2.regValue = AIO_ReadRegister(AUDIO_EQ_bp1_2_reg);
	eq_bp2_1.regValue = AIO_ReadRegister(AUDIO_EQ_bp2_1_reg);
	eq_bp2_2.regValue = AIO_ReadRegister(AUDIO_EQ_bp2_2_reg);

	eq_bp1_1.eq_bp1_a1 = 0x8e40;
	eq_bp1_1.eq_bp1_a2 = 0x3820;
	eq_bp1_2.eq_bp1_h0 = 0x34c;

	eq_bp2_1.eq_bp2_a1 = 0xa38f;
	eq_bp2_1.eq_bp2_a2 = 0x3486;
	eq_bp2_2.eq_bp2_h0 = 0x34c;

	AIO_WriteRegister(AUDIO_EQ_bp1_1_reg, eq_bp1_1.regValue);
	AIO_WriteRegister(AUDIO_EQ_bp1_2_reg, eq_bp1_2.regValue);
	AIO_WriteRegister(AUDIO_EQ_bp2_1_reg, eq_bp2_1.regValue);
	AIO_WriteRegister(AUDIO_EQ_bp2_2_reg, eq_bp2_2.regValue);
}
#endif
void AtvEnableAMFreqCompensate(uint32_t Enable)
{
	if(g_user_config == AUDIO_USER_CONFIG_TV001)
	{
#ifdef RTD289X	//RTD289X SIF-EQ has distortion issue, keep using HW-EQ to compensate BTSC & AM freq response
		audio_eq_control_register_RBUS	eq_control_register;

		AtvAMFreqCompensate();
		eq_control_register.regValue = AIO_ReadRegister(AUDIO_EQ_Control_Register_reg);

		if (g_Atvpath_PB == 1) {
			eq_control_register.eq_lp_enable = Enable;
			if (Enable == TRUE) {
				Audio_HwpSetVolume(ATV_CH_ID_L|ATV_CH_ID_R, -40); //When EQ LPF on, HW DVC decrease -5dB for compensatation
			} else {
				Audio_HwpSetVolume(ATV_CH_ID_L|ATV_CH_ID_R, 0); //When EQ LPF OFF, HW DVC bypass (0dB)
			}
		} else if (g_Atvpath_PB == 0) {
			eq_control_register.eq_lp_enable = 0;
			Audio_HwpSetVolume(ATV_CH_ID_L|ATV_CH_ID_R, 0); //When EQ LPF OFF, HW DVC bypass (0dB)
		}

		AIO_WriteRegister(AUDIO_EQ_Control_Register_reg, eq_control_register.regValue);
#else	//After RTD287X & RTD284X, SIF-EQ distortion issue is fixed, back to use SIF-EQ
		audio_eq_tvd_bp_control_RBUS	eq_tvd_bp_control;

		if(audio_drv_set_sif_eq_coef_48K(&atv_sif_eq_48k_tab[ATV_SOUND_STD_AM_MONO]) != 0)
			alog_err("Set AM Freq Compensate Fail!!\n");

		eq_tvd_bp_control.regValue = AIO_ReadRegister(AUDIO_EQ_tvd_bp_Control_reg);
		eq_tvd_bp_control.eq_tvd_lp_enable = Enable;

		AIO_WriteRegister(AUDIO_EQ_tvd_bp_Control_reg, eq_tvd_bp_control.regValue);	

		if (Enable == TRUE)
		{
		    HwpSetVolume_SIF(g_sif_offset-40); //When EQ LPF on, HW DVC decrease -5dB for compensatation
		}
		else
		{
		    HwpSetVolume_SIF(g_sif_offset); //When EQ LPF OFF, HW DVC bypass (0dB)
		}
#endif
	}
}
#ifdef RTD289X
void AtvAMFreqCompensate(void)
{
	audio_eq_lp_RBUS	eq_lp;

	eq_lp.regValue = AIO_ReadRegister(AUDIO_EQ_lp_reg);

	//LPF Fc: 13kHz / Gain: 5dB==> a1=0x0431
	//LPF Fc: 12kHz / Gain: 5dB==> a1=0x0
	// For LGE test AM MONO, frequency is 15kHz
	eq_lp.eq_lp_a1 = 0xe071;
	eq_lp.eq_lp_h0 = 0x0639;


	AIO_WriteRegister(AUDIO_EQ_lp_reg, eq_lp.regValue);
}
#endif
void AtvBTSCSignalProcess(void)
{

#define  FIRSTTIMEBTSCCHECKTIME (8)

	//	audio_mode_detect_RBUS mode_detect;
	audio_msd_crtl_word_RBUS msd_crtl_word;
	uint32_t changeSelectFlag, firsttimedetect, i, maxindex;
	static uint32_t g_changeSoundMode;    // Clayton ; Date: 2013/1/3
	ATV_SOUND_MODE sound_mode;  // Clayton ; Date: 2013/1/3
				    //audio_down_sample_control_for_playback_RBUS down_sample_control_for_playback;

	//audio_msd_result_RBUS msd_result;

	static int g_ContinueBTSCNum = 0;
	static int phase_error_count = 0;

	static uint32_t g_btsc_soundmode_prev;
	static uint32_t g_btsc_soundmode_debounce;
	audio_btsc_sap_status_RBUS btsc_sap_status;
	audio_btsc_sap_thresh_RBUS btsc_sap_thresh;

	//USER:Peter_Lin DATE:2010/10/12
	// fix btsc sap disapper noise
	
	audio_btsc_sap_noise_RBUS btsc_sap_noise;
	uint32_t sap_noise_dis = 0;
#define SAP_NOISE_DIST (0x10)
#define SAP_SPEED_UP_DEBOUNCE (g_BTSCSOUNDCHANGEMAX)
	

	audio_phase_error_RBUS phase_error;
	audio_btsc_pilot_phase_delta_RBUS btsc_pilot_phase_delta;
	//audio_btsc_pilot_status_RBUS BTSC_pilot_status;

	int32_t BtscFirstTimeCheckloop;

	BtscFirstTimeCheckloop = FIRSTTIMEBTSCCHECKTIME;
	if (g_FirstTimeForce2PlayMono) {
		BtscFirstTimeCheckloop = 1;
	}

	if (CHANGESTDSTATUS_FIRST_TIME == g_ChangeStdStatus) {
		// clean flag
		//		ROS_ENTER_CRITICAL();
		g_ChangeStdStatus = CHANGESTDSTATUS_DETECT;
		//	g_NicamIntOccur = 0;
		//	g_NicamSignalStable = 0;

		//	g_errorRateDebunce = FIRSTIMEBOUNCESTART;
		g_ContinueBTSCNum = 0;
		phase_error_count = 0;
		g_btsc_soundmode_debounce = g_BTSCSOUNDCHANGEMAX - BtscFirstTimeCheckloop + 3;
		//		ROS_EXIT_CRITICAL();

		g_FirstTimeSoundMode[0] = 0;
		g_FirstTimeSoundMode[1] = 0;
		g_FirstTimeSoundMode[2] = 0;
		g_FirstTimeSoundMode[3] = 0;
		return;
	} else { //CHANGESTDSTATUS_DETECT
		if (g_ContinueBTSCNum < (BtscFirstTimeCheckloop * 10))
			g_ContinueBTSCNum++;

		if (g_ContinueBTSCNum <= BtscFirstTimeCheckloop) {
			g_changeSoundMode = 0;      // Clayton 2013/1/3, clear g_changeSoundMode

			// Owen 2016/7/3, lower SAP detect threshold & add SNR protection for NTSC channel-02(weak signal) in LG PT.
			AtvLowBTSCSAPModeDetectThreshold();

			AtvGetHwBtscsSoundMode(&sound_mode);

			phase_error.regValue = AIO_ReadRegister(AUDIO_phase_error_reg);
			if (phase_error.average_movement > PHASE_ERROR_MAX_TH) {
				phase_error_count++;
			}

			//for debug
			//alog_info("phase_error = %x\n", phase_error.average_movement);
			//alog_info("phase_error_count = %d\n", phase_error_count);
			alog_info("b r s m %x  %x\n", sound_mode, AIO_ReadRegister(AUDIO_btsc_sap_status_reg));
			switch (sound_mode) {
			case ATV_SOUND_MODE_DUAL: // no this case

				break;
			default :
			case ATV_SOUND_MODE_MONO  :
				g_FirstTimeSoundMode[0] = g_FirstTimeSoundMode[0] + 1;
				break;
			case 	ATV_SOUND_MODE_STEREO   :
				g_FirstTimeSoundMode[1] = g_FirstTimeSoundMode[1] + 1;
				break;
			case 	ATV_SOUND_MODE_SAP_MONO   :
				g_FirstTimeSoundMode[2] = g_FirstTimeSoundMode[2] + 1;

				break;
			case ATV_SOUND_MODE_SAP_STEREO:
				g_FirstTimeSoundMode[3] = g_FirstTimeSoundMode[3] + 1;

				break;

			}

			//Frank: speed up sound mode out. At this time, sound does not output.
			g_last_soundmode[2] = g_last_soundmode[1];
			g_last_soundmode[1] = g_last_soundmode[0];
			g_last_soundmode[0] = sound_mode;

#define BTSC_SOUNDMODE_OUT_CNT 4
			if ((g_ContinueBTSCNum >=  BTSC_SOUNDMODE_OUT_CNT) && (g_ContinueBTSCNum < BtscFirstTimeCheckloop)) {
				if ((g_last_soundmode[2] == g_last_soundmode[1]) && (g_last_soundmode[2] == g_last_soundmode[0])) {
					g_btsc_soundmode = g_last_soundmode[0];
					alog_info("Speed Update sound mode\n");
				}
			}

			if (g_ContinueBTSCNum == (BtscFirstTimeCheckloop)) {
				maxindex = 0;
				for (i = 1; i < 4; i++) {
					if (g_FirstTimeSoundMode[i] > g_FirstTimeSoundMode[maxindex])
						maxindex = i;
				}

				alog_info("b r p s %x  %x\n", maxindex, g_FirstTimeSoundMode[maxindex]);

				if (maxindex == 0)
					g_btsc_soundmode = ATV_SOUND_MODE_MONO;
				else if (maxindex == 1)
					g_btsc_soundmode = ATV_SOUND_MODE_STEREO;
				else if (maxindex == 2)
					g_btsc_soundmode = ATV_SOUND_MODE_SAP_MONO;
				else
					g_btsc_soundmode = ATV_SOUND_MODE_SAP_STEREO;

				if (g_FirstTimeForce2PlayMono) {
					g_UserTVBTSCISStereo = 0;
					g_UserTVBTSCSAP = 0;
				}

				if (g_EnableAutoChangeSoundMode == 0)
					g_Start2NormalProcess = 0;

				//	if(g_FirstTimeForce2PlayMono)
				// 		AtvChageBTSCSoundMode((ATV_SOUND_MODE)ATV_SOUND_MODE_MONO); // firce to play mono
				//	else

				//Owen: For PAL N BTSC Stereo pilot shift to 15.625K from 15.734, add auto detect by watch phase_error
				if (ATV_GetFmRadioMode() == AUDIO_ATV_FM_RADIO_STOP)
				{
					btsc_pilot_phase_delta.regValue = AIO_ReadRegister(AUDIO_btsc_pilot_phase_delta_reg);
					alog_info("Final phase_error_count = %d\n", phase_error_count);

					if (phase_error_count > (FIRSTTIMEBTSCCHECKTIME / 2 - 1)) {
						if (btsc_pilot_phase_delta.pilot_phase_delta == ATV_PILOT_PHASE_DELTA_Others) {
							Audio_AtvChangebtscpilotphasedelta(ATV_PILOT_PHASE_DELTA_PAL_MN);
							alog_info("It's PAL N BTSC, shift stereo pilot\n");
						} else {
							Audio_AtvChangebtscpilotphasedelta(ATV_PILOT_PHASE_DELTA_Others);
							alog_info("It's PAL M or NTSC BTSC, shift stereo pilot\n");
						}
					}
				}

				//audio_hw_usleep(100000); //wait for sound select
				AtvChageBTSCSoundMode((ATV_SOUND_MODE)g_btsc_soundmode);

				if (audioStatusChanageCallBack != NULL)
					audioStatusChanageCallBack(ATV_STATUS_FIRSTTIME_SOUNDMODE);

				//audio_hw_usleep(100000);
				g_btsc_soundmode_debounce = g_BTSCSOUNDCHANGEMAX; // reset
				g_btsc_soundmode_prev = g_btsc_soundmode;

				//        	drv_audio_set_backendplay(AUD_ENABLE);

				// Owen 2016/7/3, normal SAP detection keep general threshold.
				AtvNormalBTSCSAPModeDetectThreshold();

				AtvSetModeDebounceCoef(g_CurrentStd);
				AtvCleanTVMuteNum();
				HwpSetVolume_SIF(48);
				AtvSetMute(ATV_DISABLE);
				//	ROS_ENTER_CRITICAL();
				g_TVAudioReady = 1;
				if (g_UserChangeBTSCSelectFlag == 1)
					g_UserChangeBTSCSelectFlag = 0;

				//	ROS_EXIT_CRITICAL();
				//	get_system_time(&g_endStd);
				//	g_printfTime = 1;
			}

			return;
		}

	}

	//down_sample_control_for_playback.regValue = AIO_ReadRegister( AUDIO_down_sample_control_for_playback_reg);

	msd_crtl_word.regValue = AIO_ReadRegister(AUDIO_msd_crtl_word_reg);
	AtvGetHwBtscsSoundMode(&sound_mode);

	phase_error.regValue = AIO_ReadRegister(AUDIO_phase_error_reg);
	//ATV_LOG( "btsc sound mode %x %x %x \n",sound_mode,  g_btsc_soundmode,  g_btsc_soundmode_prev );
	//alog_info("phase_error = %x\n", phase_error.average_movement);

	firsttimedetect = 0;    //Clayton 2013/1/3

	// sap debounce
	if (((g_btsc_soundmode == ATV_SOUND_MODE_SAP_MONO) && (sound_mode == ATV_SOUND_MODE_MONO)) || ((g_btsc_soundmode == ATV_SOUND_MODE_SAP_STEREO) && (sound_mode == ATV_SOUND_MODE_STEREO))) {
		btsc_sap_status.regValue = AIO_ReadRegister(AUDIO_btsc_sap_status_reg);
		btsc_sap_thresh.regValue = AIO_ReadRegister(AUDIO_btsc_sap_thresh_reg);
		if (btsc_sap_status.w10sapmagnitude >= btsc_sap_thresh.sap_lothresh) {
			alog_info("sap status %x, noise %x \n", btsc_sap_status.regValue, AIO_ReadRegister(AUDIO_btsc_sap_noise_reg));
			alog_info(" fix btsc sap new 0x%x ori 0x%x  \n", sound_mode, g_btsc_soundmode);
			sound_mode = (ATV_SOUND_MODE)g_btsc_soundmode;
		} else {
			alog_info(" no sap m 0x%x th 0x%x  \n", btsc_sap_status.w10sapmagnitude,  btsc_sap_thresh.sap_lothresh);
		}
	}

	//USER:Peter_Lin DATE:2010/10/12
	// fix btsc sap disapper noise

	if (g_CurrentIsPlaySAP == 1) {
		btsc_sap_status.regValue = AIO_ReadRegister(AUDIO_btsc_sap_status_reg);
		btsc_sap_noise.regValue = AIO_ReadRegister(AUDIO_btsc_sap_noise_reg);

		if (btsc_sap_status.w10sapmagnitude >= btsc_sap_noise.w10sapnoise)
			sap_noise_dis = btsc_sap_status.w10sapmagnitude - btsc_sap_noise.w10sapnoise;
		else
			sap_noise_dis = 0;

		// 2015/9/20
		/*
			if(sap_noise_dis <=  SAP_NOISE_DIST)
			{
		    //			g_btsc_soundmode_debounce = 0;
			g_btsc_soundmode = sound_mode;
			g_changeSoundMode = 1;	// Clayton ; Date: 2013/1/3
			firsttimedetect = 1;	// Clayton ; Date: 2013/1/3
			g_btsc_soundmode_debounce = g_BTSCSOUNDCHANGEMAX;// reset
		
			}
		*/
	}

	



	if ((sound_mode != (ATV_SOUND_MODE)g_btsc_soundmode) && ((ATV_SOUND_MODE)g_btsc_soundmode_prev == sound_mode)) {

		//		btsc_sap_status.regValue = AIO_ReadRegister( AUDIO_btsc_sap_status_reg);
		//	 ATV_LOG( " b 0x%x \n",btsc_sap_status.w10sapmagnitude);

		if (g_btsc_soundmode_debounce > g_BTSCSOUNDCHANGEMIN) {

			alog_info(" btsc sound mode 0x%x deb 0x%x \n", sound_mode, g_btsc_soundmode_debounce);
			g_btsc_soundmode_debounce--;
		} else {
			alog_info(" btsc new sound mode %x\n", sound_mode);
			g_btsc_soundmode = sound_mode;
			g_changeSoundMode = 1;  // Clayton ; Date: 2013/1/3
			firsttimedetect = 1;    // Clayton ; Date: 2013/1/3
			g_btsc_soundmode_debounce = g_BTSCSOUNDCHANGEMAX; // reset
		}

	} else {
		g_btsc_soundmode_debounce = g_BTSCSOUNDCHANGEMAX; // reset
	}

	g_btsc_soundmode_prev = sound_mode;


	if ((firsttimedetect == 1) && (audioStatusChanageCallBack != NULL)) {
		audioStatusChanageCallBack(ATV_STATUS_SOUNDMODE_CHANGE);
	}

	changeSelectFlag = 0;

	//changechannelflag = 0;	// Clayton, no need to change FIFO source select after Mac. prj
	/*
	    if((down_sample_control_for_playback.fifo_ch0_source != AUD_FIFO_CHANNEL_L) || (down_sample_control_for_playback.fifo_ch1_source != AUD_FIFO_CHANNEL_R) )
	    {
	    //	adown_sample_fifo_source_sel.fifo_ch0_source = AUD_FIFO_CHANNEL_L;
	    //	adown_sample_fifo_source_sel.fifo_ch1_source = AUD_FIFO_CHANNEL_R;
	    changechannelflag = 1;
	    }
	*/
	switch (g_btsc_soundmode) {
	case ATV_SOUND_MODE_DUAL: // no this case

		break;
	case ATV_SOUND_MODE_MONO  :

		break;
	case 	ATV_SOUND_MODE_STEREO   :


		if (g_UserTVBTSCISStereo == 0) { // only dual
			if (msd_crtl_word.sound_select != ATV_SOUND_SEL_FMAM) { // need time to check if stable
				changeSelectFlag = 1;

			}

			// Clayton ; Date: 2013/1/3
			/*					down_sample_control_for_playback.regValue = AIO_ReadRegister( AUDIO_down_sample_control_for_playback_reg);
				    if((down_sample_control_for_playback.fifo_ch0_source != AUD_FIFO_CHANNEL_LMIXR) || (down_sample_control_for_playback.fifo_ch1_source != AUD_FIFO_CHANNEL_LMIXR) )
					changechannelflag = 1;
				    else
					changechannelflag = 0;
			*/
		} else {
			// stereo
			if (msd_crtl_word.sound_select != ATV_SOUND_SEL_STEREO_A) {
				changeSelectFlag = 1;

			}
		}

		break;
	case 	ATV_SOUND_MODE_SAP_MONO   :
		if (g_UserTVBTSCSAP == 0) { // error rate < NICAMERRORRATETHRESHOLD
			if (msd_crtl_word.sound_select != ATV_SOUND_SEL_STEREO_A) {
				changeSelectFlag = 1;

			}

			//USER:Peter_Lin DATE:2010/09/08
			// fix btsc mono need to /2
			
			// Clayton ; Date: 2013/1/3
			/*	 			if( ((g_AudioTVControlFlag & ENABLE_BTSC_USE_FM_MONO_MASK) == ENABLE_BTSC_USE_FM_MONO ) && (g_UserStd == ATV_SOUND_STD_BTSC) )
				  {
				      msd_result.regValue = AIO_ReadRegister(AUDIO_msd_result_reg);
			
				     if(msd_result.reg_std != ATV_SOUND_STD_MN_MONO)
				    changeSelectFlag = 1;
				  }
				
			*/
		} else {   // Clayton 2012/11/13, fix the issue for weak nicam stage when set channel, send Weak NICAM message
			if (msd_crtl_word.sound_select != ATV_SOUND_SEL_STEREO_B) {
				changeSelectFlag = 1;

			}
			//USER:Peter_Lin DATE:2010/09/08
			// fix btsc mono need to /2
			
			// Clayton ; Date: 2013/1/3
			/*	 			if( ((g_AudioTVControlFlag & ENABLE_BTSC_USE_FM_MONO_MASK) == ENABLE_BTSC_USE_FM_MONO ) && (g_UserStd == ATV_SOUND_STD_BTSC) )
				  {
				      msd_result.regValue = AIO_ReadRegister(AUDIO_msd_result_reg);
			
				     if(msd_result.reg_std != ATV_SOUND_STD_BTSC)
				    changeSelectFlag = 1;
				  }
				
			*/
		}

		break;
	case ATV_SOUND_MODE_SAP_STEREO:

		if (g_UserTVBTSCSAP == 0) {
			if (g_UserTVBTSCISStereo == 0) { // singal stable
				if (msd_crtl_word.sound_select != ATV_SOUND_SEL_FMAM) { // user want to play digial
					changeSelectFlag = 1;

				}
				// Clayton ; Date: 2013/1/3
				/*							down_sample_control_for_playback.regValue = AIO_ReadRegister( AUDIO_down_sample_control_for_playback_reg);
						if((down_sample_control_for_playback.fifo_ch0_source != AUD_FIFO_CHANNEL_LMIXR) || (down_sample_control_for_playback.fifo_ch1_source != AUD_FIFO_CHANNEL_LMIXR) )
						changechannelflag = 1;
						else
						changechannelflag = 0;
				*/
			} else {
				// stereo
				if (msd_crtl_word.sound_select != ATV_SOUND_SEL_STEREO_A) {
					changeSelectFlag = 1;

				}
			}
		} else {  // unstable signal
			if (msd_crtl_word.sound_select != ATV_SOUND_SEL_STEREO_B) {
				changeSelectFlag = 1;

			}
		}

		break;

	}

	if (changeSelectFlag || ((g_changeSoundMode) && (g_Start2NormalProcess == 1)))    //changeSelectFlag is indenpendent on g_Start2NormalProcess.
											  //if( (changeSelectFlag || g_changeSoundMode) && (g_Start2NormalProcess == 1) )	//Clayton, no need to change FIFO source select
	{
		if (g_changeSoundMode == 0)  // Clayton ; Date: 2013/1/3
			AtvSetMute(ATV_ENABLE);

		//	 	ScalerTimer_DelayXms(200);

		//AtvSleep(270);


		AtvChageBTSCSoundMode((ATV_SOUND_MODE)g_btsc_soundmode);


		//AtvSleep(330);      //Clayton 2012/7/10, Fix pop noise

		//	if(isneed2mute)
		//	{
		//	 ScalerTimer_DelayXms(200);

		if (g_changeSoundMode == 0)  // Clayton ; Date: 2013/1/3
			AtvSetMute(ATV_DISABLE);

		//	}

		if (g_UserChangeBTSCSelectFlag == 1)
			g_UserChangeBTSCSelectFlag = 0;

		if (g_EnableAutoChangeSoundMode == 0) {
			g_Start2NormalProcess = 0;
		}

		g_changeSoundMode = 0;      // Clayton 2013/1/3, clear g_changeSoundMode after executing sound mode change
	}



}

void AtvCheckTask(void)
{
	//	audio_msd_result_RBUS			msd_result;
	//	static uint32_t g_checkifdloop = 0;

	//audio_msd_result_RBUS		MSD_RESULT_REG;
	uint32_t i;
	//ATV_SOUND_INFO aATV_SOUND_INFO;
	i = 0;


	//USER:Peter_Lin DATE:2010/12/15
	// enable
#if 0
	//USER:Peter_Lin DATE:2010/12/13
	// wait ifd to finish init
	
	if(g_WaitIFDInitFinish != WAIT_IFD_FINISH){
		if(g_WaitIFDInitFinish == WAIT_IFD_FIRSTTIME){
			g_WaitIFDInitFinish= WAIT_IFD_FINISH;
			alog_info("set prev std %x\n", g_UserStd);

			MSD_RESULT_REG.regValue = AIO_ReadRegister(AUDIO_msd_result_reg);
			MSD_RESULT_REG.reg_std = g_UserStd; // speed up sound mode
			AIO_WriteRegister(AUDIO_msd_result_reg, MSD_RESULT_REG.regValue);

		} else {
			if(g_AudioTVPrintFlag)
			alog_info(" IFD not yet fisih init\n");
		}
		return;
	}
#endif

	//Check AP mute ID
	if (Audio_GetMuteID_PB() == AP_MUTE_ID) {
		g_ap_mute_pb_cnt++;

		if (g_ap_mute_pb_cnt == 3) { //  if(g_ContinueNicamNum >  (FIRSTTIMECHECKTIME + 1) )
			Audio_HwpSetMute(FALSE, ATV_CH_ID_L|ATV_CH_ID_R|ATV_CH_ID_LS|ATV_CH_ID_RS, AP_MUTE_ID);
		}
	} else {
		g_ap_mute_pb_cnt = 0;
	}

	if (Audio_GetMuteID_TS() == AP_MUTE_ID) {
		g_ap_mute_ts_cnt++;
		if (g_ap_mute_ts_cnt == 3) { // error rate < NICAMERRORRATETHRESHOLD
			Audio_HwpSetMuteTS(FALSE, ATV_CH_ID_L|ATV_CH_ID_R, AP_MUTE_ID);
		}
	} else {
		g_ap_mute_ts_cnt = 0;
	}

	#ifdef USE_ATV_SW_MUTE
	//Frank: If decoder handle get late, mute will not success.
	//       Mute again after get mute handle.
	if (pFwDecoder0MuteCallBack != NULL &&
	    g_SetMode_Mute == 1 &&
	    g_InternalDecoder_0_FAIL == 1) {
		AtvSetMute(ATV_ENABLE);
		g_InternalDecoder_0_FAIL = 0;
	}

	if (pFwDecoder1MuteCallBack != NULL &&
	    g_SetMode_Mute == 1 &&
	    g_InternalDecoder_1_FAIL == 1) {
		AtvSetMute(ATV_ENABLE);
		g_InternalDecoder_1_FAIL = 0;
	}
	#endif

	//alog_info("[Audio][Clayton]Start entering AtvCheckTask\n");			//Clayton 2012/7/3
	AtvStdChangeProcess();

	//	msd_result.regValue = AIO_ReadRegister(AUDIO_msd_result_reg);
	//	RTD_Log( "std %x \n", msd_result.hw_detected_std);
	if (ATV_GetFmRadioMode() == AUDIO_ATV_FM_RADIO_STOP)
	{
		if (AtvIsNicamSystem((ATV_SOUND_STD)g_CurrentStd)) // 0x6, 0xb, 0xd, 0xf
			NicamSignalProcess();
		else if (AtvIsBTSCSystem((ATV_SOUND_STD)g_CurrentStd)) // 0x1
			AtvBTSCSignalProcess();
		else if (AtvIsA2System((ATV_SOUND_STD)g_CurrentStd)) // 0x2, 0x5, 0x8, 0x9, 0xa
			AtvA2SignalProcess((ATV_SOUND_STD)g_CurrentStd);
		else	 if (AtvIsMonoSystem((ATV_SOUND_STD)g_CurrentStd))
			AtvMonoSignalProcess(); // 0x0, 0x3, 0x4, 0x7, 0xc, 0xe, 0x1F
	}
	else
	{
		AtvBTSCSignalProcess();
	}

	//	Audio_AtvGetSoundStd(&aATV_SOUND_INFO);
	//	if(  (g_printfTime==1) )
	{
		//g_endStd = g_endStd - g_setStd;

		//		RTD_Log( "start time: %d:%d\n",  g_setStd.sec, g_setStd.sec_div_100);
		//		RTD_Log( "fr time: %d:%d\n",  g_firstStd.sec, 	g_firstStd.sec_div_100);

		//		RTD_Log( "end time: %d:%d\n",  g_endStd.sec, g_endStd.sec_div_100);
		/*
		    for(i = 0; i < 10; i++)
		    {
			RTD_Log( "b time: %d:%d\n",  g_BTSCTime[i].sec, g_BTSCTime[i].sec_div_100);
		
		    }
		    */
		//		g_printfTime = 0;
	}


}



//AtvSetMute(ATV_DISABLE, ATV_CH_ID_L | ATV_CH_ID_R);
//ioctl(audio_fd, ATV_CMD_SET_CLOCK, AIO_PATH_SRC_ATV);

/*
 auto scan flow ::

 1.  Audio_AtvEnterAutoScan to stop detect threadhold

Audio_AtvScanSoundStd

 Audio_AtvExitAutoScan

 set std api , thrad


detected flow 2 case


set std flow (ready)

sound mode issue coef

sound mode selece releation

sif pin select

why :: ioctl(audio_fd, ATV_CMD_SCAN_STD, ATV_ENABLE);
why no backendplay stop

need to do
factory printf nicam
factory scan freq
nicam overflow
*/

#endif //#ifdef USE_PACFIC_STYLE

/**
 * prepare to enter auto scan status
 *
 * @ingroup lib_audio
 */
void  Audio_AtvEnterAutoScan(void)
{
#ifdef RTD289X
	{
		Audio_sb2_arch_reg_RBUS     sb2_arch_reg;

		sb2_arch_reg.regValue = AIO_ReadRegister(AUDIO_sb2_arch_reg_reg);
		sb2_arch_reg.sb2_arch = (sb2_arch_reg.sb2_arch|AUDIO_SET_START_SCAN_CHANNEL_FLAG);
		AIO_WriteRegister(AUDIO_sb2_arch_reg_reg, sb2_arch_reg.regValue);
		alog_info("[%s]nina AUDIO_enter_START_SCAN_CHANNEL_FLAG 0x%x\n", __FUNCTION__, sb2_arch_reg.regValue);
	}
#endif
#ifdef USE_PACFIC_STYLE
	audio_msd_crtl_word_RBUS msd_ctrl_word;

	alog_info("[audio ] enter auto scan \n");
	AtvUpdateState(ATV_TASK_STOP);
	AtvCleanStatusData();
	msd_ctrl_word.regValue = AIO_ReadRegister(AUDIO_msd_crtl_word_reg);
	//	msd_ctrl_word.msd_debounce_cnt = 0;
	msd_ctrl_word.msd_debounce_cnt = 1;
#ifdef TV001_BOARD
	if (g_CurSifType == ATV_AUDIO_SIF_DVB_AJJA_SELECT) {
		msd_ctrl_word.calc_time_sel = 1; // Owen 2016.10.27, speed up for LG manual turning BG NICAM wrong detect to I MONO issue.
		alog_info("[audio ] speed up update energy rate for AJJA\n");
	}

#endif
	AIO_WriteRegister(AUDIO_msd_crtl_word_reg, msd_ctrl_word.regValue);
	if (ATV_Get_Scan_Std_Flag())
	{
		AtvSetHwDetecteMode(ATV_HW_CARRIER_NO_SHIFT_NO_BANDWIDTH);
	}
	else AtvSetHwDetecteMode(ATV_HW_CARRIER_SHIFT_BANDWIDTH_MONO_ONLY);

#else
	alog_info("[audio ] enter auto scan \n");
#endif
}

/**
 * finish auto scan status
 *
 * @ingroup lib_audio
 */
void  Audio_AtvExitAutoScan(void)
{
#ifdef USE_PACFIC_STYLE
	audio_msd_crtl_word_RBUS	msd_ctrl_word;

	alog_info("[audio ] exit auto scan\n");
	AtvCleanStatusData();

	msd_ctrl_word.regValue = AIO_ReadRegister(AUDIO_msd_crtl_word_reg);
	//	msd_crtl_word.msd_debounce_cnt = 4; // default
	msd_ctrl_word.msd_debounce_cnt = 0;
	//only set calc_time_sel to 1 for speed up in LGE AJJA model when auto scan
	msd_ctrl_word.calc_time_sel = 0; // Owen 2016.10.27, recover to 0 for LG manual turning BG NICAM wrong detect to I MONO issue.
	AIO_WriteRegister(AUDIO_msd_crtl_word_reg, msd_ctrl_word.regValue);

	AtvAdjuseMainCarrierThreshold(g_AudioTVNormalMainToneThredhold_High, g_AudioTVNormalMainToneThredhold_Low);

	AtvUpdateState(ATV_TASK_RUN);
#else
	alog_info("[audio ] exit auto scan\n");
#endif

}

void  Audio_AtvEnterSetChannel(void)
{

	//	printk( "[audio ] enter set channel \n");
	AtvUpdateState(ATV_TASK_PAUSE); // only pause resume  audio task, do not clean audio data
}

/**
 * finish auto scan status
 *
 * @ingroup lib_audio
 */
void  Audio_AtvFinishSetChannel(void)
{
	//	printk( "[audio ] exit set channel \n");
	AtvUpdateState(ATV_TASK_RUN);
}

uint32_t Audio_AtvIsTvReady(void)
{
	return g_TVAudioReady == 1;
}

/**
 * prepare to enter atv source
 *
 * @ingroup lib_audio
 */
void  Audio_AtvEnterAtvSource(void)
{
#ifdef USE_PACFIC_STYLE
	alog_info("[audio ] enter atv  \n");

	if(sifsource == SIF_FROM_SIF_ADC)
		audio_sif_adc_initial_flow();

	AadConnect_CleanStatusData();
	AtvUpdateState(ATV_TASK_RUN);

	g_AudioClkStatus = AUDIO_IPT_SRC_UNKNOWN;
	g_AudioSubClkStatus = AUDIO_IPT_SRC_UNKNOWN;
#else
	alog_info("[audio ] enter auto scan \n");
#endif
}

void Audio_AtvStartDecoding(void)
{
	//Frank : Remember last Audio clock status for ATV-AV-ATV.
	//        Recover ATV clock.
	alog_info("g_UserStd %x\n", g_UserStd);
	if (1 == AtvIsNicamSystem((ATV_SOUND_STD)g_UserStd) &&
	    AtvIsPlayDigitalState()) {
		g_AudioClkStatus = AUDIO_IPT_SRC_UNKNOWN;
		g_AudioSubClkStatus = AUDIO_IPT_SRC_UNKNOWN;
		AtvSetAtvClock(AUDIO_IPT_SRC_ATV_NICAM, __LINE__);
		AtvSetAtvSubClock(AUDIO_IPT_SRC_ATV_NICAM, __LINE__);
	} else {
		g_AudioClkStatus = AUDIO_IPT_SRC_UNKNOWN;
		g_AudioSubClkStatus = AUDIO_IPT_SRC_UNKNOWN;
		AtvSetAtvClock(AUDIO_IPT_SRC_ATV, __LINE__);
		AtvSetAtvSubClock(AUDIO_IPT_SRC_ATV, __LINE__);
	}
}

void Audio_AtvStopDecoding(void)
{
	alog_info("Stop Decoding.....%d %d\n",g_AudioClkStatus,g_AudioSubClkStatus);
}

void Audio_AtvSetBTSCSoundSelect(uint32_t isPreferPlayStereo, uint32_t  isPreferPlaySap)
{
	g_UserChangeBTSCSelectFlag = 1;


	alog_info("sound sel BTSC %x %x \n", isPreferPlayStereo, isPreferPlaySap);
	g_UserTVBTSCISStereo = isPreferPlayStereo;
	g_UserTVBTSCSAP = isPreferPlaySap;


	//	g_UserTVBTSCISStereo = 1;
	//	g_UserTVBTSCSAP = 1;
}

/*
int32_t Audio_AtvSetBtscMtsSelect( ATV_BTSC_MTS_SEL mts_sel )
{
    switch(mts_sel)
    {
    case ATV_BTSC_MTS_SEL_MONO :
	Audio_AtvSetBTSCSoundSelect(0, 0) ;
    break;

    case ATV_BTSC_MTS_SEL_STEREO :
	Audio_AtvSetBTSCSoundSelect(1, 0) ;
    break;

    case ATV_BTSC_MTS_SEL_SAP :
	Audio_AtvSetBTSCSoundSelect(1, 1) ;
    break;


    case ATV_BTSC_MTS_SEL_L_MONO_R_SAP :
	alog_info(" not yet implement  sound selec");
	while(1); // error
    break;
    }

    return ATV_OK;
}
*/
void Audio_AtvSetNICAMSoundSelect(uint32_t isPreferNicamDigital, uint32_t  preferDualLangIndex)
{

	g_UserChangeNicamSelectFlag = 1;

	alog_info("sound sel NICAM %x %x \n", isPreferNicamDigital, preferDualLangIndex);
	g_UserTVNICAMISStereo = isPreferNicamDigital;
	g_UserTVNICAMLanguage = preferDualLangIndex;

}

/*
int32_t Audio_AtvSetNicamSoundSelect(ATV_NICAM_SEL sel)
{



    switch(sel)
    {
    case ATV_NICAM_SEL_ANA_MONO   :
	Audio_AtvSetNICAMSoundSelect2(0, 0);
	break;
    case ATV_NICAM_SEL_DIG_MONO:
    case ATV_NICAM_SEL_DIG_STEREO:
    case ATV_NICAM_SEL_DIG_LANGA:
	Audio_AtvSetNICAMSoundSelect2(1, 0);
	break;


    case ATV_NICAM_SEL_DIG_LANGB:
	Audio_AtvSetNICAMSoundSelect2(1, 1);
	break;

    case ATV_NICAM_SEL_DIG_LANGAB:
	Audio_AtvSetNICAMSoundSelect2(1, 2);
	break;
    }

    return ATV_OK;
}
*/
void Audio_AtvSetA2SoundSelect(uint32_t isPreferPlayStereo, uint32_t  preferDualLangIndex)
{

	//	audio_msd_result_RBUS			msd_result;
	g_UserChagneA2SelectFlag = 1;
	alog_info("sound sel A2l %x %x \n", isPreferPlayStereo, preferDualLangIndex);

	g_UserTVA2ISStereo = isPreferPlayStereo;
	g_UserTVA2Language = preferDualLangIndex;
}

/*
int32_t Audio_AtvSetA2SoundSelect(ATV_A2_SEL sel)
{
    switch(sel)
    {
    case ATV_A2_SEL_MONO      :
	Audio_AtvSetA2SoundSelect2(0, 0);
	break;
    case ATV_A2_SEL_STEREO:
    case ATV_A2_SEL_LANGA:
	Audio_AtvSetA2SoundSelect2(1, 0);
	break;


    case ATV_A2_SEL_LANGB:
	Audio_AtvSetA2SoundSelect2(1, 1);
	break;

    case ATV_A2_SEL_LANGAB:
	Audio_AtvSetA2SoundSelect2(1, 2);
	break;
    }

    return ATV_OK;
}
*/

/**
 * Get ATV BTSC Sound/Language Select(last S/W backup)
 *
 * @param <p_mts_sel>	{ ATV_BTSC_MTS_SEL_XXX , refer to audio_atv.h }
 * @return				{ ATV_OK or AIO_ERROR_CODE }
 * @ingroup lib_audio
 */
int32_t Audio_AtvIsBtscMtsSelectFinish(void)
{

	return g_UserChangeBTSCSelectFlag == 0;
}

/**
 * Get ATV BTSC Sound/Language Select(last S/W backup)
 *
 * @param <p_mts_sel>	{ ATV_BTSC_MTS_SEL_XXX , refer to audio_atv.h }
 * @return				{ ATV_OK or AIO_ERROR_CODE }
 * @ingroup lib_audio
 */
int32_t Audio_AtvGetBtscMtsSelect(uint32_t *p_mts_sel)
{
	ATV_SOUND_INFO aInfo;

	Audio_AtvGetSoundStd(&aInfo);

	if (aInfo.current_select == ATV_SOUND_SELECT_STEREO)
		*p_mts_sel = ATV_BTSC_MTS_SEL_STEREO;
	else if (aInfo.current_select == ATV_SOUND_SELECT_SAP)
		*p_mts_sel = ATV_BTSC_MTS_SEL_SAP;
	else
		*p_mts_sel = ATV_BTSC_MTS_SEL_MONO;

	return ATV_OK;
}

/**
 * Get ATV A2 Sound/Language Select(last S/W backup)
 *
 * @param <p_mts_sel>	{ ATV_A2_SEL_XXX , refer to audio_atv.h }
 * @return				{ ATV_OK or AIO_ERROR_CODE }
 * @ingroup lib_audio
 */
int32_t Audio_AtvGetA2SoundSelect(ATV_A2_SEL *p_sel)
{
	ATV_SOUND_INFO aInfo;

	Audio_AtvGetSoundStd(&aInfo);

	if (aInfo.current_select == ATV_SOUND_SELECT_STEREO)
		*p_sel = ATV_A2_SEL_STEREO;
	else if (aInfo.current_select == ATV_SOUND_SELECT_LANGA)
		*p_sel = ATV_A2_SEL_LANGA;
	else if (aInfo.current_select == ATV_SOUND_SELECT_LANGB)
		*p_sel = ATV_A2_SEL_LANGB;
	else if (aInfo.current_select == ATV_SOUND_SELECT_LANGAB)
		*p_sel = ATV_A2_SEL_LANGAB;
	else
		*p_sel = ATV_A2_SEL_MONO;

	return ATV_OK;
}

int32_t Audio_AtvIsA2SoundSelectFinish(void)
{
	return g_UserChagneA2SelectFlag == 0;
}

/**
 * enable / disable print sw freq scan
 *
 * @return
 * @ingroup lib_audio
 */
void Audio_AtvEnablePrintSWScan(uint32_t isEnable)
{

	if (isEnable == 1)
		g_AudioTVPrintFlag |= ATV_PRINT_FLAG_ENABLE_SW_SCAN;
	else
		g_AudioTVPrintFlag  &= (~ATV_PRINT_FLAG_ENABLE_SW_SCAN);

	alog_info("audio tv sw scan %x \n", isEnable);

}

void Audio_AtvEnableTVPrint(uint32_t isEnable)
{

	if (isEnable == 1)
		g_AudioTVPrintFlag |= ATV_PRINT_FLAG_ENABLE_NORMAL_PRINT;
	else
		g_AudioTVPrintFlag  &= (~ATV_PRINT_FLAG_ENABLE_NORMAL_PRINT);

	alog_info("audio tv printf %x \n", isEnable);

}

/**
 * Get ATV Nicam Sound/Language Select(last S/W backup)
 *
 * @param <p_mts_sel>	{ ATV_A2_XXX , refer to audio_atv.h }
 * @return				{ ATV_OK or AIO_ERROR_CODE }
 * @ingroup lib_audio
 */
int32_t Audio_AtvGetNicamSoundSelect(ATV_NICAM_SEL *p_sel)
{
	ATV_SOUND_INFO aInfo;

	Audio_AtvGetSoundStd(&aInfo);

	if (aInfo.current_select == ATV_SOUND_SELECT_STEREO)
		*p_sel = ATV_NICAM_SEL_DIG_STEREO;
	else if (aInfo.current_select == ATV_SOUND_SELECT_LANGA)
		*p_sel = ATV_NICAM_SEL_DIG_LANGA;
	else if (aInfo.current_select == ATV_SOUND_SELECT_LANGB)
		*p_sel = ATV_NICAM_SEL_DIG_LANGB;
	else if (aInfo.current_select == ATV_SOUND_SELECT_LANGAB)
		*p_sel = ATV_NICAM_SEL_DIG_LANGAB;
	else if (aInfo.isPlayDigital == 1)
		*p_sel = ATV_NICAM_SEL_DIG_MONO;
	else
		*p_sel = ATV_NICAM_SEL_ANA_MONO;

	return ATV_OK;
}

int32_t Audio_AtvIsNicamSoundSelectFinish(void)
{
	return g_UserChangeNicamSelectFlag == 0;
}

// check MN-> BG change
ATV_SOUND_STD_MAIN_SYSTEM Audio_AtvGetDetectMainSystem(void)
{

	ATV_SOUND_STD_MAIN_SYSTEM mainSystem;
	uint32_t std;

	std =    AtvGetHWStd();
	switch (std) {
	case ATV_SOUND_STD_MN_MONO:
	case ATV_SOUND_STD_BTSC:
	case ATV_SOUND_STD_A2_M:
	case ATV_SOUND_STD_EIAJ:
		mainSystem = ATV_SOUND_MN_SYSTEM;
		break;
	case ATV_SOUND_STD_BG_MONO:
	case ATV_SOUND_STD_A2_BG:
	case ATV_SOUND_STD_NICAM_BG:
		mainSystem = ATV_SOUND_BG_SYSTEM;
		break;
	case ATV_SOUND_STD_DK_MONO:
	case ATV_SOUND_STD_A2_DK1:
	case ATV_SOUND_STD_A2_DK2:
	case ATV_SOUND_STD_A2_DK3:
	case ATV_SOUND_STD_NICAM_DK:
		mainSystem = ATV_SOUND_DK_SYSTEM;
		break;
	case ATV_SOUND_STD_AM_MONO:
	case ATV_SOUND_STD_NICAM_L:
		mainSystem = ATV_SOUND_L_SYSTEM;
		break;
	case ATV_SOUND_STD_FM_MONO_NO_I:
	case ATV_SOUND_STD_NICAM_I:
		mainSystem = ATV_SOUND_I_SYSTEM;
		break;
	case ATV_SOUND_STD_UNKNOWN:
	default:
		mainSystem = ATV_SOUND_UNKNOWN_SYSTEM;
	}

	return mainSystem;

}

//USER:Peter_Lin DATE:2010/12/10
// change to mono system for china style

ATV_SOUND_STD Audio_AtvConvert2MonoStd(ATV_SOUND_STD std)
{

	ATV_SOUND_STD monostyem;

	switch (std) {

	case ATV_SOUND_STD_BTSC:
		monostyem = ATV_SOUND_STD_BTSC;
		break;
	case ATV_SOUND_STD_MN_MONO:
	case ATV_SOUND_STD_A2_M:
	case ATV_SOUND_STD_EIAJ:
		monostyem = ATV_SOUND_STD_MN_MONO;
		break;
	case ATV_SOUND_STD_BG_MONO:
	case ATV_SOUND_STD_A2_BG:
	case ATV_SOUND_STD_NICAM_BG:
		monostyem = ATV_SOUND_STD_BG_MONO;
		break;
	case ATV_SOUND_STD_DK_MONO:
	case ATV_SOUND_STD_A2_DK1:
	case ATV_SOUND_STD_A2_DK2:
	case ATV_SOUND_STD_A2_DK3:
	case ATV_SOUND_STD_NICAM_DK:
		monostyem = ATV_SOUND_STD_DK_MONO;
		break;
	case ATV_SOUND_STD_AM_MONO:
	case ATV_SOUND_STD_NICAM_L:
		monostyem = ATV_SOUND_STD_AM_MONO;
		break;
	case ATV_SOUND_STD_FM_MONO_NO_I:
	case ATV_SOUND_STD_NICAM_I:
		monostyem = ATV_SOUND_STD_FM_MONO_NO_I;
		break;
	case ATV_SOUND_STD_UNKNOWN:
	default:
		monostyem = ATV_SOUND_STD_UNKNOWN;
	}

	return monostyem;

}



//USER:Peter_Lin DATE:2010/12/10
// wait ifd to finish init


/**
 * Wait IFD to finish init
 *
 * @return
 * @ingroup lib_audio
 */
void Audio_AtvIFDInitFinish(void)
{
	if (down_interruptible(&audio_sem_atv)) {
		alog_warning("interrupted, no semaphore held\n");
		return;
	}

	if (g_WaitIFDInitFinish == WAIT_IFD_INIT) {
		alog_info("chang  IFD init to first time\n");
		g_WaitIFDInitFinish = WAIT_IFD_FIRSTTIME;
	} else {
		alog_info("error change wait ifd state\n");
	}

	up(&audio_sem_atv);
}

//USER:Peter_Lin DATE:2010/12/14
// change wait ifd initial state

void Audio_AtvResetIFDInitFlag(void)
{
	if (down_interruptible(&audio_sem_atv)) {
		alog_warning("interrupted, no semaphore held\n");
		return;
	}

	g_WaitIFDInitFinish = WAIT_IFD_INIT;

	up(&audio_sem_atv);
}

void Audio_AtvSetLowTresholdFlag(int isEnable)
{
	if (isEnable)
		g_AudioTVControlFlag = g_AudioTVControlFlag|ENABLE_MAINTONE_THRESHOLD_ADJUST;
	else
		g_AudioTVControlFlag = g_AudioTVControlFlag&(~(ENABLE_MAINTONE_THRESHOLD_ADJUST));

	alog_info("flag %x  \n", g_AudioTVControlFlag);
}

void Audio_AtvPauseTVStdDetection(bool is_pause)
{
	if (is_pause)
		AtvUpdateState(ATV_TASK_PAUSE);
	else
		AtvRestoreState();
}

void AtvSetAtvClock(ENUM_AUDIO_IPT_SRC audio_ipt_src, int debug)
{
	AUDIO_RPC_SET_ATV_CLOCK atv_clk_info;
	
	if (g_instanceID != 0 && g_AudioClkStatus != audio_ipt_src) {
		alog_debug("Aclk %d\n", debug);

		atv_clk_info.instanceID = g_instanceID;
		atv_clk_info.atv_type = audio_ipt_src;
		alog_debug("AtvSetAtvClock %ld %d\n", g_instanceID, audio_ipt_src);
		
		rtk_snd_set_atv_clock(&atv_clk_info);
		g_AudioClkStatus = audio_ipt_src;
	}
}

void AtvSetAtvSubClock(ENUM_AUDIO_IPT_SRC audio_ipt_src, int debug)
{
	AUDIO_RPC_SET_ATV_CLOCK atv_sub_clk_info;
	
	if (g_sub_instanceID != 0 && 
	    g_AudioSubClkStatus != audio_ipt_src) {
		alog_debug("Aclk sub %d\n", debug);

		atv_sub_clk_info.instanceID = g_sub_instanceID;
		atv_sub_clk_info.atv_type = audio_ipt_src;
		alog_debug("AtvSetAtvSubClock %ld %d\n", g_sub_instanceID, audio_ipt_src);
		rtk_snd_set_atv_clock(&atv_sub_clk_info);
		g_AudioSubClkStatus = audio_ipt_src;
	}
}

int Audio_AtvGetModeMute(void)
{
	return g_SetMode_Mute;
}

int Audio_AtvSetInternalDecoder0Fail(int is_mute)
{
 	g_InternalDecoder_0_FAIL = is_mute;
	return ATV_OK;
}

int Audio_AtvSetInternalDecoder1Fail(int is_mute)
{
	g_InternalDecoder_1_FAIL = is_mute;
	return ATV_OK;
}

void Audio_AtvSetAudioInHandle(long instanceID)
{	
	g_instanceID = instanceID;
	alog_debug("\x1b[32mAinclk Main %d\x1b[m\n", __LINE__);
	alog_debug("Audio_AtvSetAudioInHandle %ld\n", g_instanceID);

	if(instanceID == 0) //if stop decoding, unmure sw decoder.
	{
		ENUM_AI_PATH path_sel = ENUM_AI_PB_PATH;
		if(g_Atvpath_PB == 1)
			path_sel = ENUM_AI_PB_PATH;
		else if(g_Atvpath_TS == 1)
			path_sel = ENUM_AI_TS_PATH;
		else
			alog_err("pFwDecoder0MuteCallBack is not ready %d!!!\n", __LINE__);

		rtk_snd_set_decoder_mute(false, path_sel);
	}
}

void Audio_AtvSetSubAudioInHandle(long instanceID)
{
#if 1
	AUDIO_RPC_SET_ATV_CLOCK atv_clk_info;
	g_sub_instanceID = instanceID;

	alog_debug("\x1b[32mAinclk sub %d\x1b[m\n", __LINE__);
	alog_debug("Audio_AtvSetSubAudioInHandle %ld\n", g_sub_instanceID);

	if (g_sub_instanceID != 0) {
		alog_debug("Aclk xsub %d\n", __LINE__);

		/* Check Clock is set, if no set, set it.
		 * APVR case: In normal watch, it is PB path, but transfer to
		 * TS path, ATV clock will not set.
		 */
		if (g_AudioSubClkStatus == AUDIO_IPT_SRC_UNKNOWN &&
		    g_AudioClkStatus != AUDIO_IPT_SRC_UNKNOWN) {
			alog_debug("Aclk Init sub %d\n", __LINE__);

			atv_clk_info.instanceID = g_sub_instanceID;
			atv_clk_info.atv_type = g_AudioClkStatus;
			rtk_snd_set_atv_clock(&atv_clk_info);
		}
	}

	if(instanceID == 0) //if stop decoding, unmure sw decoder.
	{
		ENUM_AI_PATH path_sel = ENUM_AI_PB_PATH;
		if(g_Atvpath_PB == 1)
			path_sel = ENUM_AI_PB_PATH;
		else if(g_Atvpath_TS == 1)
			path_sel = ENUM_AI_TS_PATH;
		else
			alog_err("pFwDecoder0MuteCallBack is not ready %d!!!\n", __LINE__);

		rtk_snd_set_decoder_mute(false, path_sel);
	}
#endif
}

/* add ultra deviation */
void Audio_AtvSetTVFlag(uint32_t mask, uint32_t newSetting)
{

	alog_info("change flag %x  %x \n", mask, newSetting);

	atv_flag = atv_flag&(~(mask));
	atv_flag |= newSetting;
	alog_info("new flag %d  \n", atv_flag);
}


//USER:Peter_Lin DATE:2011/09/20
// add nicam saturate

void AtvSetNicamDeemphasisSaturantion(uint32_t isSaturation)
{
	audio_nicam_decode_ctrl_RBUS nicam_decode_ctrl;

	//	return ;
	nicam_decode_ctrl.regValue = AIO_ReadRegister(AUDIO_nicam_decode_ctrl_reg);

	if (isSaturation)
		nicam_decode_ctrl.sat_en = 1;
	else
		nicam_decode_ctrl.sat_en = 0;

	AIO_WriteRegister(AUDIO_nicam_decode_ctrl_reg, nicam_decode_ctrl.regValue);

}


void Audio_AtvStart2NormalProcess(void)
{
	alog_info("[ATV] audio start normal Run");
	g_Start2NormalProcess = 1;

	g_A2_soundmode_debounce = A2SOUNDCHANGEMAX; // let debounce use normal case

}

void Audio_AtvForceFirstTimeMonoSoundFlag(int isEnable)
{
	g_FirstTimeForce2PlayMono = isEnable;
}

//Add for force sound select
// flag =1 , force sound select
void Audio_AtvForceSoundSel(bool flag)
{
	g_InForceSoundSelectMode = flag;
	g_ForceSoundSelect = flag;
	alog_info("Force Sound Sel %d\n", flag);
}

void Audio_AtvNicamAutoRecoveryFlag(int isEnable)
{
	g_EnableNicamAutoRecovery = isEnable;
}

void Audio_AtvEnableAutoChangeSoundModeFlag(int isEnable)
{
	g_EnableAutoChangeSoundMode = isEnable;
}

void Audio_AtvSetNicamErrorRateThreshold(int Upperbound, int Lowbound)
{

	if (Lowbound > Upperbound)
		return;

	g_NicamErrorRateThresholdHigh	= Upperbound;
	g_NicamErrorRateThresholdLow = Lowbound;

	alog_info("[ATV] Nicam Threshold %x %x \n", g_NicamErrorRateThresholdHigh, g_NicamErrorRateThresholdLow);


}

void Audio_AtvSetNicamErrorRateDebounce(int MaxDebounce)
{
	g_NicamMaxErrorDebounce	= MaxDebounce;
}

static void ChengeFlag(uint32_t mask, uint32_t newSetting)
{
	atv_flag  = atv_flag&(~mask);
	atv_flag  = atv_flag|newSetting;
}

void Audio_AtvChangeTvDeviationConfig(uint32_t setting)
{
	if ((setting&ATV_INIT_DEV_NICAM_BGDKI_MASK_CONFIG) != 0) {
		if ((setting&ATV_INIT_DEV_NICAM_BGDKI_MASK_CONFIG) == ATV_INIT_DEV_NICAM_BGDKI_HIGH_CONFIG) {
			ChengeFlag(ATV_INIT_DEV_NICAM_BGDKI_MASK, ATV_INIT_DEV_NICAM_BGDKI_HIGH);
			//			TV_MSG(LOGGER_INFO, "change to high %x \n", g_TVSeFlag);

		} else if ((setting&ATV_INIT_DEV_NICAM_BGDKI_MASK_CONFIG) == ATV_INIT_DEV_NICAM_BGDKI_SUPER_CONFIG) {
			ChengeFlag(ATV_INIT_DEV_NICAM_BGDKI_MASK, ATV_INIT_DEV_NICAM_BGDKI_SUPER);
			//		TV_MSG(LOGGER_INFO, "change to supper  %x  \n", g_TVSeFlag);
		} else if ((setting&ATV_INIT_DEV_NICAM_BGDKI_MASK_CONFIG) == ATV_INIT_DEV_NICAM_BGDKI_NORMAL_CONFIG) {
			ChengeFlag(ATV_INIT_DEV_NICAM_BGDKI_MASK, ATV_INIT_DEV_NICAM_BGDKI_NORMAL);
			//		TV_MSG(LOGGER_INFO, "change to normal %x  \n", g_TVSeFlag);
		}
	}

	if ((setting&ATV_INIT_DEV_BGDKI_MASK_CONFIG) != 0) {
		if ((setting&ATV_INIT_DEV_BGDKI_MASK_CONFIG) == ATV_INIT_DEV_BGDKI_HIGH_CONFIG) {
			ChengeFlag(ATV_INIT_DEV_BGDKI_MASK, ATV_INIT_DEV_BGDKI_HIGH);
			//			TV_MSG(LOGGER_INFO, "change to h 2 %x  \n", g_TVSeFlag);
		} else if ((setting&ATV_INIT_DEV_BGDKI_MASK_CONFIG) == ATV_INIT_DEV_BGDKI_SUPER_CONFIG) {
			ChengeFlag(ATV_INIT_DEV_BGDKI_MASK, ATV_INIT_DEV_BGDKI_SUPER);
			//		TV_MSG(LOGGER_INFO, "change to s 2 %x  \n", g_TVSeFlag);
		} else if ((setting&ATV_INIT_DEV_BGDKI_MASK_CONFIG) == ATV_INIT_DEV_BGDKI_NORMAL_CONFIG) {
			ChengeFlag(ATV_INIT_DEV_BGDKI_MASK, ATV_INIT_DEV_BGDKI_NORMAL);
			//		TV_MSG(LOGGER_INFO, "change to n 2 %x  \n", g_TVSeFlag);
		}
	}

	if ((setting&ATV_INIT_DEV_M_MASK_CONFIG) != 0) {
		if ((setting&ATV_INIT_DEV_M_MASK_CONFIG) == ATV_INIT_DEV_M_HIGH_CONFIG) {
			ChengeFlag(ATV_INIT_DEV_M_MASK, ATV_INIT_DEV_M_HIGH);
			//		TV_MSG(LOGGER_INFO, "change to h 3 %x  \n", g_TVSeFlag);
		}
		//USER:Peter_Lin DATE:2011/4/15
		// add BTSC supper deviation
		
		else if ((setting&ATV_INIT_DEV_M_MASK_CONFIG) == ATV_INIT_DEV_M_SUPER_CONFIG) {
			ChengeFlag(ATV_INIT_DEV_M_MASK, ATV_INIT_DEV_M_SUPER);
			//	TV_MSG(LOGGER_INFO, "change to s 3 %x  \n", g_TVSeFlag);
		}
		

		else if ((setting&ATV_INIT_DEV_M_MASK_CONFIG) == ATV_INIT_DEV_M_NORMAL_CONFIG) {
			ChengeFlag(ATV_INIT_DEV_M_MASK, ATV_INIT_DEV_M_NORMAL); // MN MONO & BTSC Normal deviation is different BW by AtvSetDeviation
										// And it can support Normal devaiton for BTSC (100kHz)
										//ChengeFlag(ATV_INIT_DEV_M_MASK ,ATV_INIT_DEV_M_HIGH);
										//	TV_MSG(LOGGER_INFO, "change to s 3 %x  \n", g_TVSeFlag);
		}

	}

}

void Audio_AtvSetDeviationMethod(ATV_DEV_METHOD dev_method)
{
	switch (dev_method) {
	case  ATV_DEV_CHANGE_BY_SOUND_STD:
		g_DevBySoundStd = (uint32_t)ATV_DEV_CHANGE_BY_SOUND_STD;
		break;
	case  ATV_DEV_CHANGE_BY_USER:
		g_DevBySoundStd = (uint32_t)ATV_DEV_CHANGE_BY_USER;
		break;
	default:
		alog_info("[%s] Error dev_mod %d %d\n", __FUNCTION__, dev_method, g_DevBySoundStd);
		break;
	}

}

void Audio_AtvSetDevBandWidth(A2_BW_SEL_T bw_sel, A2_BW_SEL_T sub_bw_sel)
{
	//A2_BW_SEL_T  deviation_bw;
	audio_a2_eiaj_demod_RBUS a2_eiaj_demod;
	audio_global_ctrl_1_RBUS  global_ctrl_1;

	g_FM1_bw = bw_sel;
	g_FM2_bw = sub_bw_sel;
	a2_eiaj_demod.regValue = AIO_ReadRegister(AUDIO_a2_eiaj_demod_reg);
	global_ctrl_1.regValue = AIO_ReadRegister(AUDIO_global_ctrl_1_reg);

	a2_eiaj_demod.a2_bw_sel = ((uint16_t)bw_sel)&0x0003;
	a2_eiaj_demod.a2_sub_bw_sel = ((uint16_t)sub_bw_sel)&0x0003;
	global_ctrl_1.hdv_mode_sel = (((uint16_t)bw_sel) >> 2)&0x01;
	AIO_WriteRegister(AUDIO_a2_eiaj_demod_reg, a2_eiaj_demod.regValue);
	AIO_WriteRegister(AUDIO_global_ctrl_1_reg, global_ctrl_1.regValue);

	//Verification....
	a2_eiaj_demod.regValue = AIO_ReadRegister(AUDIO_a2_eiaj_demod_reg);
	global_ctrl_1.regValue = AIO_ReadRegister(AUDIO_global_ctrl_1_reg);
	alog_debug("[Verification Hdv] hdv_mode_sel %d  a2_eiaj_demod %d\n", (uint16_t)global_ctrl_1.hdv_mode_sel, (uint16_t)a2_eiaj_demod.a2_bw_sel);
}

void AtvSetDevBandWidth(A2_BW_SEL_T bw_sel, A2_BW_SEL_T sub_bw_sel)
{
	//A2_BW_SEL_T  deviation_bw;
	audio_a2_eiaj_demod_RBUS a2_eiaj_demod;
	audio_global_ctrl_1_RBUS  global_ctrl_1;

	a2_eiaj_demod.regValue = AIO_ReadRegister(AUDIO_a2_eiaj_demod_reg);
	global_ctrl_1.regValue = AIO_ReadRegister(AUDIO_global_ctrl_1_reg);

	a2_eiaj_demod.a2_bw_sel = ((uint16_t)bw_sel)&0x0003;
	a2_eiaj_demod.a2_sub_bw_sel = ((uint16_t)sub_bw_sel)&0x0003;
	global_ctrl_1.hdv_mode_sel = (((uint16_t)bw_sel) >> 2)&0x01;
	AIO_WriteRegister(AUDIO_a2_eiaj_demod_reg, a2_eiaj_demod.regValue);
	AIO_WriteRegister(AUDIO_global_ctrl_1_reg, global_ctrl_1.regValue);

	//Verification....
	a2_eiaj_demod.regValue = AIO_ReadRegister(AUDIO_a2_eiaj_demod_reg);
	global_ctrl_1.regValue = AIO_ReadRegister(AUDIO_global_ctrl_1_reg);
	alog_debug("[Int_Verification Hdv] hdv_mode_sel %d  a2_eiaj_demod %d\n", (uint16_t)global_ctrl_1.hdv_mode_sel, (uint16_t)a2_eiaj_demod.a2_bw_sel);
}

//1: down 6dB
//0: no down
void Audio_AtvSetFMoutDownGain(int para)
{
	audio_a2_eiaj_demod_RBUS a2_eiaj_demod;

	a2_eiaj_demod.regValue = AIO_ReadRegister(AUDIO_a2_eiaj_demod_reg);
	a2_eiaj_demod.down_6db = para;
	AIO_WriteRegister(AUDIO_a2_eiaj_demod_reg, a2_eiaj_demod.regValue);
}

void Audio_AtvSetAMoutDownGain(int para)
{
	audio_am_RBUS am;

	am.regValue = AIO_ReadRegister(AUDIO_am_reg);
	if (para == 1) {
		am.hw_am_prescale = 0; //0dB
	} else {
		am.hw_am_prescale = 1; //6dB
	}

	AIO_WriteRegister(AUDIO_am_reg, am.regValue);
}

void Audio_AtvSetAMWideBW(int para)
{
	audio_am_RBUS am;

	am.regValue = AIO_ReadRegister(AUDIO_am_reg);
	if (para == 1) {
		am.am_bpf_bw = 1; //180kHz
	} else {
		am.am_bpf_bw = 0; //30kHz
	}

	AIO_WriteRegister(AUDIO_am_reg, am.regValue);

}

void Audio_AtvStatusChageCallBackfnConfig(FP_AUDIOSTATUSCHANGE f_ptr)
{
	//[owen] need to fix it.
	//audioStatusChanageCallBack = f_ptr;
}

int Audio_AtvGetNicamSignalStable(void)
{
	return g_NicamSignalStable;
}

void  Audio_AtvConfigNoSignalNeed2Mute(uint32_t isNeed2Mute)
{
	g_NoSignalNeedToMuteFlag = isNeed2Mute;
}

//USER:Peter_Lin DATE:2012/09/10
// add to change sub tone ratio

void Audio_AtvChangeTvSubRatio(ATV_SUB_TONE_RATIO ratio)
{
	audio_main_sub_ratio_RBUS main_sub_ratio;

	main_sub_ratio.regValue = AIO_ReadRegister(AUDIO_main_sub_ratio_reg);
	main_sub_ratio.main_sub_ratio = ratio;
	AIO_WriteRegister(AUDIO_main_sub_ratio_reg, main_sub_ratio.regValue);
}

// Clayton 2013/5/2
// For PAL M or PAL N + BTSC shift Stereo pilot to 0xA6AAAAA
void Audio_AtvChangebtscpilotphasedelta(ATV_PILOT_PHASE_DELTA data)
{
	audio_btsc_pilot_phase_delta_RBUS btsc_pilot_phase_delta;

	btsc_pilot_phase_delta.regValue = AIO_ReadRegister(AUDIO_btsc_pilot_phase_delta_reg);
	btsc_pilot_phase_delta.pilot_phase_delta = data;
	AIO_WriteRegister(AUDIO_btsc_pilot_phase_delta_reg, btsc_pilot_phase_delta.regValue);
}


// Clayton 2013/11/28
// For Sxxx company or Special high deviation distortion case
void Audio_AtvSetFMnormalization(uint32_t isEnable)
{
	audio_a2_eiaj_demod_RBUS a2_eiaj_demod;

	a2_eiaj_demod.regValue = AIO_ReadRegister(AUDIO_a2_eiaj_demod_reg);
	a2_eiaj_demod.hdv_compen_en = isEnable;
	AIO_WriteRegister(AUDIO_a2_eiaj_demod_reg, a2_eiaj_demod.regValue);
	alog_info("[ATV][Audio]FMnormalization = %d \n", isEnable);

}


//USER:LewisLee DATE:2012/06/11
//to fix change TV channel during audio std change
//will dead lock
void Audio_AtvSetDuring_ChageStatusFlag(uint8_t ucFlag)
{
	if (NULL == audioStatusChanageCallBack)
		return;

	g_AudioDuringChangeStatus = ucFlag;
}

uint8_t Audio_AtvGetDuring_ChageStatusFlag(void)
{
	if (NULL == audioStatusChanageCallBack)
		return FALSE;

	return g_AudioDuringChangeStatus;
}

void Audio_AtvSetSoundSystem(DRV_ATV_SOUND_SYSTEM AtvAudioSoundSystem)
{
	alog_info("[Audio_AtvSetAudioMainSystem]SoundSystem = %d\n", AtvAudioSoundSystem);

	switch (AtvAudioSoundSystem) {
	case DRV_ATV_SOUND_SYSTEM_DK:
		AtvSoundSystem = ATV_SOUND_DK_SYSTEM;
		break;
	case DRV_ATV_SOUND_SYSTEM_I:
		AtvSoundSystem = ATV_SOUND_I_SYSTEM;
		break;
	case DRV_ATV_SOUND_SYSTEM_BG:
		AtvSoundSystem = ATV_SOUND_BG_SYSTEM;
		break;
	case DRV_ATV_SOUND_SYSTEM_MN:
		AtvSoundSystem = ATV_SOUND_MN_SYSTEM;
		break;
	case DRV_ATV_SOUND_SYSTEM_L:
	case DRV_ATV_SOUND_SYSTEM_LA:
		AtvSoundSystem = ATV_SOUND_L_SYSTEM;
		break;
	case DRV_ATV_SOUND_SYSTEM_AUTO:
	case DRV_ATV_SOUND_SYSTEM_UNKNOWN:
	default:
		AtvSoundSystem = ATV_SOUND_UNKNOWN_SYSTEM;
		break;
	}
}

ATV_SOUND_STD_MAIN_SYSTEM Audio_AtvGetSoundSystem(void)
{
	return AtvSoundSystem;
}

// Clayton 2014/4/24
// Select ATV path is PB or TS or Both

void Audio_AtvPathIs(ATV_PATH_PB_TS atvpath)
{

	alog_info("ATV path is %x\n", atvpath);
	switch (atvpath) {
	case ATV_PATH_IS_PB:
		g_Atvpath_PB = 1;
		g_Atvpath_TS = 0;
		break;
	case ATV_PATH_IS_TS:
		g_Atvpath_PB = 0;
		g_Atvpath_TS = 1;
		break;
	case ATV_PATH_IS_PB_TS:
		g_Atvpath_PB = 1;
		g_Atvpath_TS = 1;
		break;
	default:
		g_Atvpath_PB = 1;
		g_Atvpath_TS = 1;
		break;
	}
}


// Clayton 2014/5/6
// Force PB or TS never mute control by driver during ATV related action

void Audio_AtvForceNotmute(ATVFORCENOTMUTE_PB_TS atvforcenotmute)
{

	alog_info("ATV Force not mute is %x\n", atvforcenotmute);
	switch (atvforcenotmute) {
	case ATVFORCENOTMUTE_IS_PB:
		g_AtvForceNotMute_PB = 1;
		g_AtvForceNotMute_TS = 0;
		break;
	case ATVFORCENOTMUTE_IS_TS:
		g_AtvForceNotMute_PB = 0;
		g_AtvForceNotMute_TS = 1;
		break;
	case ATVFORCENOTMUTE_IS_PB_TS:
		g_AtvForceNotMute_PB = 1;
		g_AtvForceNotMute_TS = 1;
		break;
	case ATVFORCENOTMUTE_IS_NONE:
		g_AtvForceNotMute_PB = 0;
		g_AtvForceNotMute_TS = 0;
		break;
	default:
		g_AtvForceNotMute_PB = 0;
		g_AtvForceNotMute_TS = 0;
		break;
	}
}


// TODO::
//chanage atvflag

//Frank [20150616]
//Add the function for Set sound standard and control force nicam function
void AtvSetSoundStd(ATV_SOUND_STD sound_std)
{
	audio_msd_result_RBUS			MSD_RESULT_REG;
	audio_carrier_freq_deviation_ctrl_RBUS  CARRIER_FREQ_DEVIATION_CTRL_REG;
	audio_carrier_phase_delta_RBUS  CARRIER_PHASE_DELTA_REG;

	CARRIER_FREQ_DEVIATION_CTRL_REG.regValue =  AIO_ReadRegister(AUDIO_carrier_freq_deviation_ctrl_reg);
	CARRIER_PHASE_DELTA_REG.regValue =  AIO_ReadRegister(AUDIO_carrier_phase_delta_reg);

	AtvEnableBTSCSAPFreqCompensate(0);
	AtvEnableAMFreqCompensate(0);   //Default setting is disable
#ifdef TV001_BOARD
if(g_user_config == AUDIO_USER_CONFIG_TV001)
	rtk_snd_enhance_btsc_separation(0); //0: release BTSC stereo separation enhancement
#endif
	switch (sound_std) {
	case ATV_SOUND_STD_BG_MONO:
		/*
		CARRIER_FREQ_DEVIATION_CTRL_REG.force_nicam_en = 1;
		CARRIER_FREQ_DEVIATION_CTRL_REG.carrier_freq_correct_en = 1;
		CARRIER_PHASE_DELTA_REG.main_phase_delta = 0xE53;
		CARRIER_PHASE_DELTA_REG.sub_phase_delta = 0xF3C;
		*/
		CARRIER_FREQ_DEVIATION_CTRL_REG.tone_det_en = 1;
		CARRIER_FREQ_DEVIATION_CTRL_REG.freq_manual_en = 1;
		CARRIER_PHASE_DELTA_REG.main_phase_delta = 0xE53;
		CARRIER_FREQ_DEVIATION_CTRL_REG.phase_3rd_delta = 0xF3C;
		break;
	case ATV_SOUND_STD_DK_MONO:
		/*
		CARRIER_FREQ_DEVIATION_CTRL_REG.force_nicam_en = 1;
		CARRIER_FREQ_DEVIATION_CTRL_REG.carrier_freq_correct_en = 1;
		CARRIER_PHASE_DELTA_REG.main_phase_delta = 0x10ED;
		CARRIER_PHASE_DELTA_REG.sub_phase_delta = 0xF3C;
		*/
		CARRIER_FREQ_DEVIATION_CTRL_REG.tone_det_en = 1;
		CARRIER_FREQ_DEVIATION_CTRL_REG.freq_manual_en = 1;
		CARRIER_PHASE_DELTA_REG.main_phase_delta = 0x10ED;
		CARRIER_FREQ_DEVIATION_CTRL_REG.phase_3rd_delta = 0xF3C;
		break;
	case ATV_SOUND_STD_AM_MONO:
		AtvEnableAMFreqCompensate(1);   // AM MONO, Enable freq response compensatation
		/*
		CARRIER_FREQ_DEVIATION_CTRL_REG.force_nicam_en = 1;
		CARRIER_FREQ_DEVIATION_CTRL_REG.carrier_freq_correct_en = 1;
		CARRIER_PHASE_DELTA_REG.main_phase_delta = 0x10ED;
		CARRIER_PHASE_DELTA_REG.sub_phase_delta = 0xF3C;
		*/
		CARRIER_FREQ_DEVIATION_CTRL_REG.tone_det_en = 1;
		CARRIER_FREQ_DEVIATION_CTRL_REG.freq_manual_en = 1;
		CARRIER_PHASE_DELTA_REG.main_phase_delta = 0x10ED;
		CARRIER_FREQ_DEVIATION_CTRL_REG.phase_3rd_delta = 0xF3C;
		break;
	case ATV_SOUND_STD_FM_MONO_NO_I:
		/*
		CARRIER_FREQ_DEVIATION_CTRL_REG.force_nicam_en = 1;
		CARRIER_FREQ_DEVIATION_CTRL_REG.carrier_freq_correct_en = 1;
		CARRIER_PHASE_DELTA_REG.main_phase_delta = 0xFA0;
		CARRIER_PHASE_DELTA_REG.sub_phase_delta = 0x1110;
		*/
		CARRIER_FREQ_DEVIATION_CTRL_REG.tone_det_en = 1;
		CARRIER_FREQ_DEVIATION_CTRL_REG.freq_manual_en = 1;
		CARRIER_PHASE_DELTA_REG.main_phase_delta = 0xFA0;
		CARRIER_FREQ_DEVIATION_CTRL_REG.phase_3rd_delta = 0x1110;
		break;
	default:
		if (sound_std >= ATV_SOUND_STD_UNKNOWN) {
			alog_info("AtvSetSoundStd out of range %d\n", (int)sound_std);
			return;
		}

		/*
		CARRIER_FREQ_DEVIATION_CTRL_REG.force_nicam_en = 0;
		CARRIER_FREQ_DEVIATION_CTRL_REG.carrier_freq_correct_en = 0;
		CARRIER_PHASE_DELTA_REG.main_phase_delta = 0;
		CARRIER_PHASE_DELTA_REG.sub_phase_delta = 0;
		*/
		CARRIER_FREQ_DEVIATION_CTRL_REG.tone_det_en = 0;
		CARRIER_FREQ_DEVIATION_CTRL_REG.freq_manual_en = 0;
		CARRIER_PHASE_DELTA_REG.main_phase_delta = 0;
		CARRIER_FREQ_DEVIATION_CTRL_REG.phase_3rd_delta = 0;
		break;
	}

	alog_debug("AtvSetSoundStd std %d %x %x\n", (int)sound_std, CARRIER_PHASE_DELTA_REG.main_phase_delta, CARRIER_PHASE_DELTA_REG.sub_phase_delta);
	MSD_RESULT_REG.regValue = AIO_ReadRegister(AUDIO_msd_result_reg);
	MSD_RESULT_REG.reg_std = sound_std;
	//AIO_WriteRegister(AUDIO_carrier_phase_delta_reg, CARRIER_PHASE_DELTA_REG.regValue);
	//AIO_WriteRegister(AUDIO_carrier_freq_deviation_ctrl_reg, CARRIER_FREQ_DEVIATION_CTRL_REG.regValue);
	AIO_WriteRegister(AUDIO_msd_result_reg, MSD_RESULT_REG.regValue);
	//alog_info("AIO read [6204] %x\n", AIO_ReadRegister(AUDIO_msd_result_reg));


}

void  Audio_HwpSetSIFDataSource(SIF_INPUT_SOURCE sif_input_source)
{
	audio_carrier_freq_deviation_ctrl_RBUS CARRIER_FREQ_DEVIATION_CTRL;
	audio_global_ctrl_1_RBUS global_ctrl_1;
	//tv_sb1_ana_ifadc_ctrl5_RBUS ifadc_ctrl5;
	//tv_sb1_ana_ifadc_agc_pga_ctrl_RBUS ifadc_agc_pga_ctrl;

	CARRIER_FREQ_DEVIATION_CTRL.regValue = AIO_ReadRegister(AUDIO_carrier_freq_deviation_ctrl_reg);

	CARRIER_FREQ_DEVIATION_CTRL.sif_data_source = sif_input_source;

	alog_info("[Audio][App] sif source %d\n", sif_input_source);

	AIO_WriteRegister(AUDIO_carrier_freq_deviation_ctrl_reg, CARRIER_FREQ_DEVIATION_CTRL.regValue);
	if (sif_input_source == SIF_FROM_SIF_ADC) {
		// IFD_SIF_ADC_Initial_Flow(); //move to Scaler to do it
		sifsource = SIF_FROM_SIF_ADC;
		//SIF audio clk
		global_ctrl_1.regValue = AIO_ReadRegister(AUDIO_global_ctrl_1_reg);
		global_ctrl_1.sif_adc_clk_en = 1;
		AIO_WriteRegister(AUDIO_global_ctrl_1_reg, global_ctrl_1.regValue);

		// start
		/*
		    //Select SIF_in pad
		    ifadc_ctrl5.regValue = AIO_ReadRegister(TV_SB1_ANA_IFADC_CTRL5_VADDR);
		    ifadc_ctrl5.reg_adc2x_sif_in_sel = 1;
		    AIO_WriteRegister(TV_SB1_ANA_IFADC_CTRL5_VADDR, ifadc_ctrl5.regValue);
		    //PGA source form audio
		    ifadc_agc_pga_ctrl.regValue = AIO_ReadRegister(TV_SB1_ANA_IFADC_AGC_PGA_CTRL_VADDR);
		    ifadc_agc_pga_ctrl.reg_agc_pga_src_sel = 1;
		    AIO_WriteRegister(TV_SB1_ANA_IFADC_AGC_PGA_CTRL_VADDR, ifadc_agc_pga_ctrl.regValue);
		    */
		// end
		
	#ifdef RTD289X
		// SIF AGC manual mode, gain = +6.5dB
		AtvSetHwAGC(ATV_DISABLE, 0x8, 0x4);
	#else  //SIF PGA cost down after RTD289X
		// SIF AGC manual mode, gain = +6dB
		AtvSetHwAGC(ATV_DISABLE, 0x0, 0x6);
	#endif
	} else {
		sifsource = SIF_FROM_IFDEMOD;
		// start
		/*
		    //Select IF+ and IF- pad
		    ifadc_ctrl5.regValue = AIO_ReadRegister(TV_SB1_ANA_IFADC_CTRL5_VADDR);
		    ifadc_ctrl5.reg_adc2x_sif_in_sel = 0;
		    AIO_WriteRegister(TV_SB1_ANA_IFADC_CTRL5_VADDR, ifadc_ctrl5.regValue);
		    //PGA source form IFD
		    ifadc_agc_pga_ctrl.regValue = AIO_ReadRegister(TV_SB1_ANA_IFADC_AGC_PGA_CTRL_VADDR);
		    ifadc_agc_pga_ctrl.reg_agc_pga_src_sel = 0;
		    AIO_WriteRegister(TV_SB1_ANA_IFADC_AGC_PGA_CTRL_VADDR, ifadc_agc_pga_ctrl.regValue);
		*/
		// end
		// SIF AGC auto mode
		AtvSetHwAGC(ATV_ENABLE, 0, 0);
	}

	//alog_info("[Audio] sifsource= %d\n", sifsource);
}

void  Audio_HwpSIFSetA2StereoDualTH(uint32_t a2_th)
{
	g_A2_TH_sel = a2_th;

	if (A2_Th_Table == NULL) {
		alog_info("A2_Th_Table pointer to NULL fail\n");
		return;
	}

	AtvSetA2Parameter();
	alog_info("Set A2 TH %d\n", g_A2_TH_sel);

}

void  Audio_HwpSIFGetA2StereoDualTH(uint32_t *a2_th)
{
	*a2_th = g_A2_TH_sel;
}

void  Audio_HwpSIFSetNicamTH(uint8_t  hi_th,  uint8_t lo_th)
{
	g_NicamErrorRateThresholdLow  = (lo_th << 2); //0~64
	g_NicamErrorRateThresholdHigh = (hi_th << 3); //0~128

	if (g_NicamErrorRateThresholdLow > g_NicamErrorRateThresholdHigh) {
		if (g_NicamErrorRateThresholdLow < 10) {
			g_NicamErrorRateThresholdHigh = g_NicamErrorRateThresholdLow + 10;
			alog_info("Nicam TH adjust a %d %d\n", g_NicamErrorRateThresholdHigh, g_NicamErrorRateThresholdLow);
		} else if (g_NicamErrorRateThresholdLow < 30) {
			g_NicamErrorRateThresholdHigh = g_NicamErrorRateThresholdLow + 15;
			alog_info("Nicam TH adjust b %d %d\n", g_NicamErrorRateThresholdHigh, g_NicamErrorRateThresholdLow);
		} else if (g_NicamErrorRateThresholdLow <= 64) {
			g_NicamErrorRateThresholdHigh = g_NicamErrorRateThresholdLow + 25;
			alog_info("Nicam TH adjust c %d %d\n", g_NicamErrorRateThresholdHigh, g_NicamErrorRateThresholdLow);
		} else {
			alog_info("[%s]Error th %d %d\n", __FUNCTION__, hi_th, lo_th);
		}

	}

	Audio_AtvSetNicamErrorRateThreshold((int32_t)g_NicamErrorRateThresholdHigh, (int32_t)g_NicamErrorRateThresholdLow);
}

void  Audio_HwpSIFGetNicamTH(uint8_t  *hi_th,  uint8_t *lo_th)
{
	*lo_th = (g_NicamErrorRateThresholdLow >> 2); //0~64
	*hi_th = (g_NicamErrorRateThresholdHigh >> 3); //0~128
}

void  Audio_HwpSIFGetMainToneMag(ATV_SOUND_STD_MAIN_SYSTEM main_sys, int32_t *pToneMag)
{
	//IFD_AUDIO_BP_SEL ifd_bp_sel;

	//ifd_bp_sel = (ATV_AUDIO_BP_SEL)audio_ifd_get_audio_bp_info();
	//audio_ifd_set_audio_bp(ATV_AUDIO_BP_SEL_BYPASS);
	//Rt_Sleep(50);

	if (main_sys == ATV_SOUND_MN_SYSTEM) {
		*pToneMag = AIO_ReadRegister(AUDIO_msd_mag_4_5_reg);
	} else if (main_sys == ATV_SOUND_BG_SYSTEM) {
		*pToneMag = AIO_ReadRegister(AUDIO_msd_mag_5_5_reg);
	} else if (main_sys == ATV_SOUND_DK_SYSTEM || main_sys == ATV_SOUND_L_SYSTEM) {
		*pToneMag = AIO_ReadRegister(AUDIO_msd_carrier_6_5_reg);
	} else if (main_sys == ATV_SOUND_I_SYSTEM) {
		*pToneMag = AIO_ReadRegister(AUDIO_msd_mag_6_reg);
	} else {
		alog_info("[%s] error main_sys %d\n", __FUNCTION__, main_sys);
	}

	alog_info("Get tone mag %8x %d\n", *pToneMag, *pToneMag);

	//audio_ifd_set_audio_bp(ifd_bp_sel);

}

void Audio_Hw_GetSifTone(ATV_SIF_TONE_T *SIF_Tone)
{
	SIF_Tone->SIF_4p5 = AIO_ReadRegister(AUDIO_msd_mag_4_5_reg);
	SIF_Tone->SIF_4p28 = AIO_ReadRegister(AUDIO_msd_mag_4_28_reg);
	SIF_Tone->SIF_4p72 = AIO_ReadRegister(AUDIO_msd_mag_4_72_reg);
	alog_info("SIF_4p5 SIF_4p28 SIF_4p72 %x %x %x\n", 
		SIF_Tone->SIF_4p5, SIF_Tone->SIF_4p28, SIF_Tone->SIF_4p72);

	SIF_Tone->SIF_5p5 = AIO_ReadRegister(AUDIO_msd_mag_5_5_reg);
	SIF_Tone->SIF_5p25 = AIO_ReadRegister(AUDIO_msd_mag_5_25_reg);
	SIF_Tone->SIF_5p74 = AIO_ReadRegister(AUDIO_msd_mag_5_74_reg);
	SIF_Tone->SIF_5p85 = AIO_ReadRegister(AUDIO_msd_carrier_5_85_reg);
	alog_info("SIF_5p5 SIF_5p25 SIF_5p74 SIF_5p85 %x %x %x %x\n", 
		SIF_Tone->SIF_5p5, SIF_Tone->SIF_5p25, SIF_Tone->SIF_5p74, SIF_Tone->SIF_5p85);

	SIF_Tone->SIF_6p0 = AIO_ReadRegister(AUDIO_msd_mag_6_reg);
	SIF_Tone->SIF_6p25 = AIO_ReadRegister(AUDIO_msd_mag_6_25_reg);
	alog_info("SIF_6p0 SIF_6p25 %x %x\n", 
		SIF_Tone->SIF_6p0, SIF_Tone->SIF_6p25);

	SIF_Tone->SIF_6p5 = AIO_ReadRegister(AUDIO_msd_carrier_6_5_reg);
	SIF_Tone->SIF_6p552 = AIO_ReadRegister(AUDIO_msd_mag_6_552_reg);
	SIF_Tone->SIF_6p74 = AIO_ReadRegister(AUDIO_msd_carrier_6_74_reg);
	alog_info("SIF_6p5 SIF_6p552 SIF_6p72 %x %x %x\n", 
		SIF_Tone->SIF_6p5, SIF_Tone->SIF_6p552, SIF_Tone->SIF_6p74);
}

int32_t Audio_HwpSIFGetMainToneSNR(ATV_SOUND_STD_MAIN_SYSTEM main_sys,
								   ATV_SOUND_STD_MAIN_SYSTEM *p_hw_detected_main_sys,
								   ATV_SOUND_STD *p_hw_detected_sound_std,
								   uint32_t *pToneSNR)
{
	int32_t ToneMag = 0;
	//IFD_AUDIO_BP_SEL ifd_bp_sel;
	int32_t noise_tone[2] = {0, 0};//, SIF_4p5, SIF_4p28, SIF_4p72, SIF_5p5, SIF_5p25, SIF_5p74;
	int32_t noise_avg = 1;//, SIF_5p85, SIF_6p0, SIF_6p25, SIF_6p5, SIF_6p552, SIF_6p74;
	ATV_SOUND_STD	real_sound_std = ATV_SOUND_STD_UNKNOWN;
	ATV_SOUND_STD_MAIN_SYSTEM	real_main_sys = ATV_SOUND_UNKNOWN_SYSTEM;
	ATV_SOUND_STD p_sound_std = ATV_SOUND_STD_UNKNOWN;
	audio_msd_result_RBUS	msd_result;
	ATV_SIF_TONE_T SIF_Tone;

	memset(&SIF_Tone, 0, sizeof(ATV_SIF_TONE_T));
	Audio_AtvEnterAutoScan();
	// Around the 4.5MHz, sometimes has Chroma disturbance, so, shrink the HW detection range
	if (main_sys == ATV_SOUND_MN_SYSTEM && g_user_config == AUDIO_USER_CONFIG_TV001) {
		AtvSetHwDetecteMode(ATV_HW_CARRIER_NO_SHIFT_NO_BANDWIDTH_MONO_ONLY);
		alog_info("change the HW Mode of detection for M-system %x\n", ATV_HW_CARRIER_NO_SHIFT_NO_BANDWIDTH_MONO_ONLY);
	}

if(g_user_config == AUDIO_USER_CONFIG_TV003 || g_user_config == AUDIO_USER_CONFIG_TV002)
{
#ifdef RTD289X
	// SIF AGC fixed gain +9.5dB
	AtvSetHwAGC(ATV_DISABLE, 0x8, 0x17);
#else //SIF PGA cost down after RTD289X
	// SIF AGC fixed gain +9dB
	AtvSetHwAGC(ATV_DISABLE, 0x0, 0x9);
#endif
}
else
{
#ifdef RTD289X
	// SIF AGC fixed gain +6.5dB
	AtvSetHwAGC(ATV_DISABLE, 0x8, 0x4);
#else //SIF PGA cost down after RTD289X
	// SIF AGC fixed gain +6dB
	AtvSetHwAGC(ATV_DISABLE, 0x0, 0x6);
#endif
}


	audio_hw_usleep(300000);  //delay 300ms
	AtvScanSoundStd_LG(&p_sound_std, 1); //Get current HW detect STD
	real_sound_std = p_sound_std;
	real_main_sys = (ATV_SOUND_STD_MAIN_SYSTEM)AtvGetMainSystem(p_sound_std);
	Audio_Hw_GetSifTone(&SIF_Tone);
	msd_result.regValue = AIO_ReadRegister(AUDIO_msd_result_reg);
	alog_info("HW detect STD= %x, real_main_sys = %x, real_sound_std = %x, main_sys = %d\n", 
		msd_result.hw_detected_std, real_main_sys, real_sound_std, main_sys);
	if (main_sys == ATV_SOUND_AUTO_SYSTEM) {  // unstable signal
		if (real_main_sys == ATV_SOUND_MN_SYSTEM) {
			Audio_HwpSIFGetMainToneMag(real_main_sys, &ToneMag);
			noise_tone[0] = SIF_Tone.SIF_5p5;
			noise_tone[1] = SIF_Tone.SIF_6p552;
		} else if (real_main_sys == ATV_SOUND_BG_SYSTEM) {
			Audio_HwpSIFGetMainToneMag(real_main_sys, &ToneMag);
			noise_tone[0] = SIF_Tone.SIF_4p5;
			noise_tone[1] = SIF_Tone.SIF_6p552;
		} else if (real_main_sys == ATV_SOUND_DK_SYSTEM || real_main_sys == ATV_SOUND_L_SYSTEM) {
			Audio_HwpSIFGetMainToneMag(real_main_sys, &ToneMag);
			noise_tone[0] = SIF_Tone.SIF_4p5;
			noise_tone[1] = SIF_Tone.SIF_4p72;
		} else if (real_main_sys == ATV_SOUND_I_SYSTEM) {
			Audio_HwpSIFGetMainToneMag(real_main_sys, &ToneMag);
			noise_tone[0] = SIF_Tone.SIF_4p5;
			noise_tone[1] = SIF_Tone.SIF_5p5;
			//The freq interval between PAL & NTSC signal is only 6MHz in some case when CN model, but IFD bandwidth is 8MHz.
			//It will cover the chroma of next NTSC channel in band, and make MN system detect to I system.
			//if(abs(SIF_Tone.SIF_4p5 - SIF_Tone.SIF_5p25) > 0x4A0) //check MN system existed or not
			{
				ATV_SOUND_STD	recheck_sound_std = ATV_SOUND_STD_UNKNOWN;
				ATV_SOUND_STD_MAIN_SYSTEM	recheck_main_sys = ATV_SOUND_UNKNOWN_SYSTEM;

				audio_ifd_set_audio_bp(ATV_AUDIO_BP_SEL_4P000M_5P000M);
				audio_hw_usleep(300000);  //delay 100ms, wait SIF energy stable
				AtvScanSoundStd_LG(&p_sound_std, 1); //Get current HW detect STD
				recheck_sound_std = p_sound_std;
				recheck_main_sys = (ATV_SOUND_STD_MAIN_SYSTEM)AtvGetMainSystem(p_sound_std);
				alog_info("recheck_main_sys %d\n", recheck_main_sys);
				if(recheck_main_sys == ATV_SOUND_MN_SYSTEM && AtvCheckVideoTiming(recheck_main_sys) == 1)
				{
					alog_info("%s, %d", __FUNCTION__, __LINE__);
					real_sound_std = recheck_sound_std;
					real_main_sys = recheck_main_sys;
					ToneMag = AIO_ReadRegister(AUDIO_msd_mag_4_5_reg);
					noise_tone[0] = AIO_ReadRegister(AUDIO_msd_mag_5_5_reg);      //dummy for the latest algorithm
					noise_tone[1] = AIO_ReadRegister(AUDIO_msd_mag_6_552_reg);
				}
				else
				{
					audio_ifd_set_audio_bp(ATV_AUDIO_BP_SEL_HPF_4P300M);
				}
			}
		} else {
			alog_info("[%s] error real_main_sys %d real_sound_std %d\n", __FUNCTION__, real_main_sys, real_sound_std);
		}
	} else {  // mono
		if (main_sys == ATV_SOUND_MN_SYSTEM) {
			Audio_HwpSIFGetMainToneMag(main_sys, &ToneMag);
			noise_tone[0] = SIF_Tone.SIF_5p5;
			noise_tone[1] = SIF_Tone.SIF_6p552;
		} else if (main_sys == ATV_SOUND_BG_SYSTEM) {
			Audio_HwpSIFGetMainToneMag(main_sys, &ToneMag);
			noise_tone[0] = SIF_Tone.SIF_4p5;
			noise_tone[1] = SIF_Tone.SIF_6p552;
		} else if (main_sys == ATV_SOUND_DK_SYSTEM || main_sys == ATV_SOUND_L_SYSTEM) {
			Audio_HwpSIFGetMainToneMag(main_sys, &ToneMag);
			noise_tone[0] = SIF_Tone.SIF_4p5;
			noise_tone[1] = SIF_Tone.SIF_4p72;
		} else if (main_sys == ATV_SOUND_I_SYSTEM) {
			Audio_HwpSIFGetMainToneMag(main_sys, &ToneMag);
			noise_tone[0] = SIF_Tone.SIF_4p5;
			noise_tone[1] = SIF_Tone.SIF_5p5;
		} else {
			alog_info("[%s] error main_sys %d\n", __FUNCTION__, main_sys);
		}
	}

	//MN 4.5M
	//BG 5.5M
	//I  6.0M
	//DK/L 6.5M
	if (main_sys == real_main_sys || main_sys == ATV_SOUND_AUTO_SYSTEM) {
		noise_avg = (noise_tone[0] + noise_tone[1]) >> 1; // /2
		if (noise_avg == 0)
			noise_avg = 1;

		alog_info("SNR Tone %d noise %d\n", ToneMag, noise_avg);

		//SNR = 20.0f*log10((double)ToneMag/(double)ATV_STD_THRESHOLD_HIGH);	// Use MSD threshold to calculate SNR
		*pToneSNR = ToneMag;    // Return SIF magnitude

		//Owen 2016/07/13, checking video timing for avoiding return wrong SNR
		if (AtvCheckVideoTiming(real_main_sys) != 1) {
			*pToneSNR = 0;
			alog_info("fake main tone, return SNR 0\n");
		}

#ifdef SIF_DetectSoundSystem_Manual_Mode
		if (main_sys >= ATV_SOUND_UNKNOWN_SYSTEM) {
			*pToneSNR = 0;
		}

#endif
	} else
		*pToneSNR = 0;

	alog_info("main_sys real_main_sys real_sound_std %x %x %x\n", main_sys, real_main_sys, real_sound_std);

	alog_info("[%s]main_sys %d ToneSNR %x ToneMag 0x%x noise_tone0 0x%x noise_tone1 0x%x\n", __FUNCTION__, main_sys, *pToneSNR, ToneMag, noise_tone[0], noise_tone[1]);

	if (sifsource == SIF_FROM_IFDEMOD) {
		AtvSetHwAGC(ATV_ENABLE, 0, 0);
	}

	Audio_AtvExitAutoScan();
	//drv_ifd_set_audio_bp(ifd_bp_sel);

	*p_hw_detected_main_sys = real_main_sys;
	*p_hw_detected_sound_std = real_sound_std;

	return ATV_OK;
}

void  Audio_HwpSIFGetA2DKSubToneMag(ATV_SOUND_STD soundstd, int32_t *pToneMag)
{
	switch (soundstd) {
	case  ATV_SOUND_STD_A2_DK1:
		*pToneMag = AIO_ReadRegister(AUDIO_msd_mag_6_25_reg);
		break;
	case  ATV_SOUND_STD_A2_DK2:
		*pToneMag = AIO_ReadRegister(AUDIO_msd_carrier_6_74_reg);
		break;
	case  ATV_SOUND_STD_A2_DK3:
		*pToneMag = AIO_ReadRegister(AUDIO_msd_mag_5_74_reg);
		break;
	default:
		alog_info("[%s] error case %d\n", __FUNCTION__, soundstd);
		break;
	}

}

//0 : error
//1 : exist
//2 : no exist
void  Audio_HwpSIFCheckNicamDigital(int *exist_flag)
{
	ATV_SOUND_STD sound_std = ATV_SOUND_STD_UNKNOWN;

#if 0
	alog_info("g_CurrentHWDetectStd = %x\n", g_CurrentHWDetectStd);
	if(g_CurrentHWDetectStd == ATV_SOUND_STD_UNKNOWN){
		sound_std = (ATV_SOUND_STD)AtvGetHWStd();
	} else {
		//sound_std = (ATV_SOUND_STD)AtvGetHWStd();
		sound_std = (ATV_SOUND_STD)g_CurrentHWDetectStd;
	}
	alog_info("sound_std = %x\n", sound_std);
#else //Owen: change staregy of reture sound STD for India stream

	sound_std = Audio_HwSIFRetrunSoundStandard(g_CurrentHWDetectStd);
#endif

	//For India, it is only mono.
	if (g_CurSifType == ATV_AUDIO_SIF_DVB_IN_SELECT) {
		if (sound_std == ATV_SOUND_STD_NICAM_BG) {    // Clayton 2013/1/3
			sound_std = ATV_SOUND_STD_BG_MONO;
		} else if (sound_std == ATV_SOUND_STD_NICAM_DK) {
			sound_std = ATV_SOUND_STD_DK_MONO;
		} else if (sound_std == ATV_SOUND_STD_NICAM_I) {
			sound_std = ATV_SOUND_STD_FM_MONO_NO_I;
		} else if (sound_std == ATV_SOUND_STD_NICAM_L) {
			sound_std = ATV_SOUND_STD_AM_MONO;
		}
	}

	//Add for India stream. Record return BG Nicam
	if (sound_std == ATV_SOUND_STD_NICAM_BG) {
		g_DetectedBGNicam = 1;
	}

	if (((sound_std == ATV_SOUND_STD_NICAM_BG) ||
	     (sound_std == ATV_SOUND_STD_NICAM_DK) ||
	     (sound_std == ATV_SOUND_STD_NICAM_I) ||
	     (sound_std == ATV_SOUND_STD_NICAM_L))
	    //&&
	    //g_TVAudioReady==1
	   ) {
		*exist_flag = 1;
	} else {
		*exist_flag = 2;
	}

	return;
}

void  Audio_HwpSIFDetectedSoundSystem(ATV_SOUND_STD_MAIN_SYSTEM *detected_main_sys)
{
	ATV_SOUND_STD  sound_std = ATV_SOUND_STD_UNKNOWN;
	//audio_interrupt_status_RBUS interrupt_status;

	//interrupt_status.regValue = AIO_ReadRegister(AUDIO_interrupt_status_reg );
	//while(interrupt_status.int_msd_decision_done==0) interrupt_status.regValue = AIO_ReadRegister(AUDIO_interrupt_status_reg );//wait
	//interrupt_status.regValue = 0;
	//interrupt_status.int_msd_decision_done = 1; // only clean msd
	//AIO_WriteRegister(AUDIO_interrupt_status_reg, interrupt_status.regValue);// clean int
	audio_hw_usleep(500000);
	sound_std = (ATV_SOUND_STD)g_CurrentHWDetectStd;
	switch (sound_std) {
	case ATV_SOUND_STD_MN_MONO:
	case ATV_SOUND_STD_BTSC:
	case ATV_SOUND_STD_A2_M:
	case ATV_SOUND_STD_EIAJ:
		*detected_main_sys = ATV_SOUND_MN_SYSTEM;
		break;
	case ATV_SOUND_STD_BG_MONO:
	case ATV_SOUND_STD_A2_BG:
	case ATV_SOUND_STD_NICAM_BG:
		*detected_main_sys = ATV_SOUND_BG_SYSTEM;
		break;
	case ATV_SOUND_STD_A2_DK1:
	case ATV_SOUND_STD_A2_DK2:
	case ATV_SOUND_STD_NICAM_DK:
	case ATV_SOUND_STD_DK_MONO:
	case ATV_SOUND_STD_A2_DK3:
		*detected_main_sys = ATV_SOUND_DK_SYSTEM;
		break;
	case ATV_SOUND_STD_AM_MONO:
	case ATV_SOUND_STD_NICAM_L:
		*detected_main_sys = ATV_SOUND_L_SYSTEM;
		break;
	case ATV_SOUND_STD_FM_MONO_NO_I:
	case ATV_SOUND_STD_NICAM_I:
		*detected_main_sys = ATV_SOUND_I_SYSTEM;
		break;
	case ATV_SOUND_STD_UNKNOWN:
		alog_info("[%s] No std detectd\n", __FUNCTION__);
		break;
	default:
		alog_info("[%s] Error %d\n", __FUNCTION__, sound_std);
		break;
	}


}

void  Audio_HwpSIFDetectedSoundStandard(ATV_SOUND_STD *detected_sound_std)
{
#if 0
	alog_info("g_CurrentHWDetectStd = %x\n", g_CurrentHWDetectStd);
	if(g_CurrentHWDetectStd == ATV_SOUND_STD_UNKNOWN){
		*detected_sound_std = (ATV_SOUND_STD)AtvGetHWStd();
	} else {
		//*detected_sound_std = (ATV_SOUND_STD)AtvGetHWStd();
		*detected_sound_std = (ATV_SOUND_STD)g_CurrentHWDetectStd;
	}
	alog_info("*detected_sound_std = %x\n", *detected_sound_std);
#else //Owen: change staregy of reture sound STD for India stream
	*detected_sound_std = Audio_HwSIFRetrunSoundStandard(g_CurrentHWDetectStd);
#endif

	//For India, it is only mono.
	if (g_CurSifType == ATV_AUDIO_SIF_DVB_IN_SELECT) {
		if (*detected_sound_std == ATV_SOUND_STD_NICAM_BG) {  // mono
			*detected_sound_std = ATV_SOUND_STD_BG_MONO;
		} else if (*detected_sound_std == ATV_SOUND_STD_NICAM_DK) {
			*detected_sound_std = ATV_SOUND_STD_DK_MONO;
		} else if (*detected_sound_std == ATV_SOUND_STD_NICAM_I) {
			*detected_sound_std = ATV_SOUND_STD_FM_MONO_NO_I;
		} else if (*detected_sound_std == ATV_SOUND_STD_NICAM_L) {
			*detected_sound_std = ATV_SOUND_STD_AM_MONO;
		}
	}

	//Add for India stream. Record return BG Nicam
	if (*detected_sound_std == ATV_SOUND_STD_NICAM_BG) {
		g_DetectedBGNicam = 1;
	}
}

void  Audio_HwpSIFEnableMutePB(bool Mute_en)
{
	if (Mute_en == TRUE)
		g_Atvpath_PB = 1;
	else {
		g_Atvpath_PB = 0;
		Audio_HwpSetMute(ATV_DISABLE, ATV_CH_ID_L|ATV_CH_ID_R|ATV_CH_ID_LS|ATV_CH_ID_RS, ATV_MUTE_ID);
		alog_info("[%s] Force to unmute\n", __FUNCTION__);
	}
}

void Audio_HwpSIFEnableMuteTS(bool Mute_en)
{
	if (Mute_en == TRUE)
		g_Atvpath_TS = 1;
	else {
		g_Atvpath_TS = 0;
		Audio_HwpSetMuteTS(ATV_DISABLE, ATV_CH_ID_L|ATV_CH_ID_R, ATV_MUTE_ID);
		alog_info("[%s] Force to unmute\n", __FUNCTION__);
	}
}

int32_t Audio_HwpSetAtvAudioBand(SIF_INPUT_SOURCE sif_source, ATV_SOUND_STD_MAIN_SYSTEM atv_main_system)
{
	int32_t ret;

	ret = -1;

	if (sif_source == SIF_FROM_IFDEMOD) { // sap
#ifndef USE_EXTERNAL_DEMOD
		ATV_AUDIO_BP_SEL bp_sel;

		switch (atv_main_system) {
		case ATV_SOUND_MN_SYSTEM:
			bp_sel = ATV_AUDIO_BP_SEL_4P000M_5P000M;
			break;
		case ATV_SOUND_BG_SYSTEM:
		case ATV_SOUND_DK_SYSTEM:
		case ATV_SOUND_I_SYSTEM:
		case ATV_SOUND_L_SYSTEM:
			bp_sel = ATV_AUDIO_BP_SEL_5P182M_7P020M;
			break;
		case ATV_SOUND_AUTO_SYSTEM:
			bp_sel = ATV_AUDIO_BP_SEL_HPF_4P300M;
			break;
		default:
			alog_info("[%s]error system %d\n", __FUNCTION__, (int)atv_main_system);
			return ret;
		}

		#ifdef RTD289X
		if (Audio_GetIcVersion() == VERSION_A) {
			// hack for audio bpf bug, for bpf to bypass
			bp_sel = ATV_AUDIO_BP_SEL_BYPASS;
		}
		#endif

		alog_info("[%s]set audio bpf %x\n", __FUNCTION__, bp_sel);
		audio_ifd_set_audio_bp(bp_sel);
#endif
	} else if (sif_source == SIF_FROM_SIF_ADC) {  // mono

#ifdef ADEMOD_USE_RHAL
		RHAL_ADEMOD_AUDIO_SIF_SOUNDSYSTEM_T soundSystem;

		switch (atv_main_system) {
		case  ATV_SOUND_DK_SYSTEM:
			soundSystem = AUDIO_SIF_SYSTEM_DK;
			break;
		case  ATV_SOUND_I_SYSTEM:
			soundSystem = AUDIO_SIF_SYSTEM_I;
			break;
		case  ATV_SOUND_BG_SYSTEM:
			soundSystem = AUDIO_SIF_SYSTEM_BG;
			break;
		case  ATV_SOUND_MN_SYSTEM:
			soundSystem = AUDIO_SIF_SYSTEM_MN;
			break;
		case  ATV_SOUND_L_SYSTEM:
			soundSystem = AUDIO_SIF_SYSTEM_L;
			break;
		case  ATV_SOUND_UNKNOWN_SYSTEM:
			soundSystem = AUDIO_SIF_SYSTEM_UNKNOWN;
			break;
		default:
			alog_info("[%s] not in case1... %d\n", __FUNCTION__, atv_main_system);
			return ret;

		}

		if (RHAL_ADEMOD_SetSoundSystem(soundSystem) == FALSE) {
			alog_info("[%s] Set EXT demod band error %d\n", __FUNCTION__, (int32_t)soundSystem);
			return ret;
		}

#endif
	} else {
		alog_info("[%s] Set int/ext error %d\n", __FUNCTION__, (int32_t)sif_source);
		return ret;
	}

	return 0;

}

//Add for Debug Menu, Get Hw setting
void Audio_HwpSIFGetSource(SIF_INPUT_SOURCE *sif_source)
{
	audio_carrier_freq_deviation_ctrl_RBUS  CARRIER_FREQ_DEVIATION_CTRL;

	CARRIER_FREQ_DEVIATION_CTRL.regValue = AIO_ReadRegister(AUDIO_carrier_freq_deviation_ctrl_reg);
	*sif_source = (SIF_INPUT_SOURCE)CARRIER_FREQ_DEVIATION_CTRL.sif_data_source;
}

void Audio_HwpSIFGetDevBandwidth(A2_BW_SEL_T  *deviation_bw)
{
	audio_a2_eiaj_demod_RBUS  a2_eiaj_demod;
	audio_global_ctrl_1_RBUS  global_ctrl_1;
	uint32_t  bw_sel, high_dev_sel;

	a2_eiaj_demod.regValue = AIO_ReadRegister(AUDIO_a2_eiaj_demod_reg);
	global_ctrl_1.regValue = AIO_ReadRegister(AUDIO_global_ctrl_1_reg);
	//
	bw_sel = (uint32_t)a2_eiaj_demod.a2_bw_sel;
	high_dev_sel = (uint32_t)global_ctrl_1.hdv_mode_sel;

	*deviation_bw = (A2_BW_SEL_T)(((high_dev_sel&0x01) << 2)|(bw_sel&0x03));
}

void Audio_HwpSIFGetBandSetup(uint32_t *bp_sel)
{
	//IFD_AUDIO_BP_SEL
	if (sifsource == SIF_FROM_IFDEMOD) {
#ifndef USE_EXTERNAL_DEMOD
		*bp_sel = audio_ifd_get_audio_bp_info();
#endif
	} else {
		*bp_sel = 0xFF; //external demod
	}
}

void Audio_HwpSIFGetModeSetup(ATV_SOUND_STD *sound_std)
{
	audio_msd_result_RBUS  MSD_RESULT_REG;

	MSD_RESULT_REG.regValue = AIO_ReadRegister(AUDIO_msd_result_reg);
	*sound_std = (ATV_SOUND_STD)MSD_RESULT_REG.reg_std;
}

void Audio_HwpSetChannelChange(void) //for external demod channel change
{
#ifdef RTD289X
	// [Clayton] For AVD check,SET_SWITCH_CHANNEL_FLAG.
	Audio_sb2_arch_reg_RBUS     sb2_arch_reg;
	int ch_change_flag = 0;

	sb2_arch_reg.regValue = AIO_ReadRegister(AUDIO_sb2_arch_reg_reg);
	ch_change_flag =  sb2_arch_reg.regValue&AUDIO_SET_START_APVR_FLAG;
	//alog_info("[%s] ASET_SWITCH_CH_FLAG 0x%x\n",__FUNCTION__,sb2_arch_reg.regValue);
	if (sifsource == SIF_FROM_SIF_ADC && ((ch_change_flag >> 3) != 1)) {
		sb2_arch_reg.sb2_arch = (sb2_arch_reg.sb2_arch|AUDIO_SET_SWITCH_CHANNEL_FLAG);
		AIO_WriteRegister(AUDIO_sb2_arch_reg_reg, sb2_arch_reg.regValue);
		alog_info("[%s]AVD BSET_SWITCH_CH_FLAG 0x%x\n", __FUNCTION__, sb2_arch_reg.regValue);
	}
#endif
}

void Audio_HwpSetBandDelay(void)
{
	audio_msd_result_RBUS		MSD_RESULT_REG;
	audio_md_ctrl_RBUS		MD_CTRL_REG;
	audio_md_status_2_RBUS	md_status_2_reg;
	audio_md_status_3_RBUS	md_status_3_reg;

	//reset sif volume to 0dB
	//[start]
	#if 0
	HwpSetVolume_SIF(0);
	#endif
	g_sif_offset = 0;
	//[end]

#ifdef RTD289X
	Audio_sb2_arch_reg_RBUS	sb2_arch_reg;

	sb2_arch_reg.regValue = AIO_ReadRegister(AUDIO_sb2_arch_reg_reg);
	sb2_arch_reg.sb2_arch = (sb2_arch_reg.sb2_arch&~AUDIO_SET_START_SCAN_CHANNEL_FLAG);
	AIO_WriteRegister(AUDIO_sb2_arch_reg_reg, sb2_arch_reg.regValue);
	alog_info("[%s]AVD EXIST_SCAN_CHANNEL_FLAG 0x%x\n", __FUNCTION__, sb2_arch_reg.regValue);
#endif

	g_wait_tunner_delay = 1;
	MSD_RESULT_REG.regValue = AIO_ReadRegister(AUDIO_msd_result_reg);
	MSD_RESULT_REG.reg_std = ATV_SOUND_STD_UNKNOWN;
	AIO_WriteRegister(AUDIO_msd_result_reg, MSD_RESULT_REG.regValue);


	MD_CTRL_REG.regValue = AIO_ReadRegister(AUDIO_md_ctrl_reg);
	MD_CTRL_REG.enable = 0;
	AIO_WriteRegister(AUDIO_md_ctrl_reg, MD_CTRL_REG.regValue);

	md_status_2_reg.regValue = AIO_ReadRegister(AUDIO_md_status_2_reg);
	md_status_3_reg.regValue = AIO_ReadRegister(AUDIO_md_status_3_reg);

	MD_CTRL_REG.regValue = AIO_ReadRegister(AUDIO_md_ctrl_reg);
	md_status_3_reg.debounce_time = ATV_A2_DEBOUNCE_NON;  // A2 HW debounce = 0
	MD_CTRL_REG.max_threshold = ATV_MODE_MAX_TH_0;    // Max_TH=0
	md_status_2_reg.lpf_coef_sel = ATV_LPF_COEF_SEL_12;
	md_status_2_reg.lpf_coef_sel_lock = ATV_LPF_COEF_SEL_12;
	MD_CTRL_REG.high_threshold = ATV_MODE_HI_TH_2P00T;    // Easily for detecting Stereo/dual
	MD_CTRL_REG.low_threshold = ATV_MODE_LO_TH_1P50T;
	MD_CTRL_REG.enable = 1;
	AIO_WriteRegister(AUDIO_md_ctrl_reg, MD_CTRL_REG.regValue);
	AIO_WriteRegister(AUDIO_md_status_2_reg, md_status_2_reg.regValue);
	AIO_WriteRegister(AUDIO_md_status_3_reg, md_status_3_reg.regValue);

	AtvCleanStatusData();
	g_UserTVA2ISStereo = 0;
	g_UserTVA2Language = 0;
	g_UserTVBTSCISStereo = 0;
	g_UserTVBTSCSAP = 0;
	g_UserTVNICAMISStereo = 0;
	g_UserTVNICAMLanguage = 0;
	g_InForceSoundSelectMode = 0;
	g_ForceSoundSelect = 0;
	g_A2_soundmode = 0;
	g_nicam_soundmode = 0;
	g_btsc_soundmode = 0;
	g_last_soundmode[2] = g_last_soundmode[1] = g_last_soundmode[0] = 0;
	g_SetMode_Mute = 0;
	g_InternalDecoder_0_FAIL = 0;
	g_InternalDecoder_1_FAIL = 0;
	//Audio_AtvSetSoundSelect(ATV_SOUND_SEL_FMAM );//default sound mode
#ifdef LG_NO_SIGNAL_NOISE_SOUND
	g_LG_NoSignal = 0;
#endif

	g_AudioClkStatus = AUDIO_IPT_SRC_UNKNOWN;
	g_AudioSubClkStatus = AUDIO_IPT_SRC_UNKNOWN;

	g_SetStdFlag = 1;
	AtvSetAtvClock(AUDIO_IPT_SRC_ATV, __LINE__);
	AtvSetAtvSubClock(AUDIO_IPT_SRC_ATV, __LINE__);
	//audio_hw_usleep(330000);//150ms delay
	g_nicam_carrier_shift = 0;
	g_DetectedBGNicam = 0;
	AtvResetNicamOverflow();
	alog_info("Set Band Delay...\n");
}

void Audio_HwpCurSifType(ATV_AUDIO_SIF_TYPE_T eSifType)
{
	g_CurSifType = eSifType;

	alog_info("CurSifTyp %d........\n", eSifType);
}

void Audio_AtvSetDevOnOff(bool bOnOff)
{
	g_HighDevOnOff = bOnOff;
	alog_info("High Dev %d........\n", bOnOff);
}

void Audio_HwpSetDecoderInputMute(bool bOnOff)
{
	

	//clear PB FIFO
	audio_down_sample_control_for_playback_RBUS  down_sample_control_for_palyback;

	alog_debug("Audio_HwpSetDecoderInputMute %d\n", bOnOff);
	down_sample_control_for_palyback.regValue = AIO_ReadRegister(AUDIO_down_sample_control_for_playback_reg);
	down_sample_control_for_palyback.backend_play_en = 0;
	AIO_WriteRegister(AUDIO_down_sample_control_for_playback_reg, down_sample_control_for_palyback.regValue);

	down_sample_control_for_palyback.regValue = AIO_ReadRegister(AUDIO_down_sample_control_for_playback_reg);
	down_sample_control_for_palyback.backend_play_en = 1;
	AIO_WriteRegister(AUDIO_down_sample_control_for_playback_reg, down_sample_control_for_palyback.regValue);

#if 0
	audio_msd_result_RBUS		MSD_RESULT_REG;

	MSD_RESULT_REG.regValue = AIO_ReadRegister(AUDIO_msd_result_reg);
	MSD_RESULT_REG.reg_std = ATV_SOUND_STD_UNKNOWN;
	AIO_WriteRegister(AUDIO_msd_result_reg, MSD_RESULT_REG.regValue);

#if 1

#endif

	alog_info("\x1b[32m Audio_HwpSetDecoderInputMute \x1b[m\n");
#endif
}

/*=============================================================*/
/**
 * audio_ifd_set_audio_bp
 *
 *
 * @param <audio_bp_sel>
 * @return { void }
 */
void audio_ifd_set_audio_bp(ATV_AUDIO_BP_SEL audio_bp_sel)
{
	audio_sif_agc3_ctrl_RBUS sif_agc3_ctrl;

	sif_agc3_ctrl.regValue = AIO_ReadRegister(AUDIO_sif_agc3_ctrl_reg);
	sif_agc3_ctrl.audio_bp_sel = audio_bp_sel&0xFF;

	AIO_WriteRegister(AUDIO_sif_agc3_ctrl_reg, sif_agc3_ctrl.regValue);
}

/*=============================================================*/
/**
 * audio_ifd_get_audio_bp_info
 *
 *
 * @param <void>
 * @return { audio_bp_sel }
 */
uint8_t audio_ifd_get_audio_bp_info(void)
{
	audio_sif_agc3_ctrl_RBUS sif_agc3_ctrl;

	sif_agc3_ctrl.regValue = AIO_ReadRegister(AUDIO_sif_agc3_ctrl_reg);
	return sif_agc3_ctrl.audio_bp_sel;
}

/*=============================================================*/
/**
 * audio_ifd_audio_gain_en
 *
 *
 * @param <enable>
 * @return { void }
 */
void audio_ifd_audio_gain_en(bool enable)
{
	audio_sif_agc3_ctrl_RBUS sif_agc3_ctrl;
	audio_sif_agc2_ctrl_RBUS sif_agc2_ctrl;
	audio_analog_pga_RBUS analog_pga;

	sif_agc3_ctrl.regValue = AIO_ReadRegister(AUDIO_sif_agc3_ctrl_reg);
	sif_agc2_ctrl.regValue = AIO_ReadRegister(AUDIO_sif_agc2_ctrl_reg);
	analog_pga.regValue = AIO_ReadRegister(AUDIO_analog_pga_reg);

	if (enable) {
		sif_agc3_ctrl.aagc_en = enable;
		sif_agc3_ctrl.audio_gain_manual = 0;
	} else {
		sif_agc3_ctrl.aagc_en = enable;
		sif_agc3_ctrl.audio_gain_manual = analog_pga.afe_pga_vol;
	}

	AIO_WriteRegister(AUDIO_sif_agc3_ctrl_reg, sif_agc3_ctrl.regValue);
}

/*=============================================================*/
/**
 * audio_ifd_audio_gain_en_get_info
 *
 *
 * @param <void>
 * @return { enable }
 */
bool audio_ifd_audio_gain_en_get_info(void)
{
	audio_sif_agc3_ctrl_RBUS sif_agc3_ctrl;

	sif_agc3_ctrl.regValue = AIO_ReadRegister(AUDIO_sif_agc3_ctrl_reg);
	return sif_agc3_ctrl.aagc_en;
}

void audio_ifd_audio_gain_manual(uint16_t gain)
{
	audio_sif_agc3_ctrl_RBUS sif_agc3_ctrl;

	sif_agc3_ctrl.regValue = AIO_ReadRegister(AUDIO_sif_agc3_ctrl_reg);
	sif_agc3_ctrl.audio_gain_manual = gain;
	AIO_WriteRegister(AUDIO_sif_agc3_ctrl_reg, sif_agc3_ctrl.regValue);
}

uint16_t audio_ifd_audio_gain_manual_get_info(void)
{
	audio_sif_agc3_ctrl_RBUS sif_agc3_ctrl;

	sif_agc3_ctrl.regValue = AIO_ReadRegister(AUDIO_sif_agc3_ctrl_reg);
	return sif_agc3_ctrl.audio_gain_manual;
}

/*=============================================================*/
/**
 * audio_ifd_audio_gain_status
 *
 *
 * @param <void>
 * @return <uint16_t>
 */
uint16_t audio_ifd_audio_gain_status(void)
{
	audio_analog_pga_RBUS analog_pga;

	analog_pga.regValue = AIO_ReadRegister(AUDIO_analog_pga_reg);

	return analog_pga.afe_pga_vol;
}

void audio_ifd_audio_output_div2(bool enable)
{
	audio_sif_agc3_ctrl_RBUS sif_agc3_ctrl;

	sif_agc3_ctrl.regValue =  AIO_ReadRegister(AUDIO_sif_agc3_ctrl_reg);
	sif_agc3_ctrl.output_bpf_input_div2 = enable;
	AIO_WriteRegister(AUDIO_sif_agc3_ctrl_reg, sif_agc3_ctrl.regValue);
}

static int set_sif_mute(unsigned int para)
{
	audio_tvdemod_digital_volume_control_RBUS       tvdemod_digital_volume_control;

	uint32_t	time_out = 0;
	return AIO_OK;

	tvdemod_digital_volume_control.regValue = AIO_ReadRegister(AUDIO_TVdemod_Digital_Volume_Control_reg);
	if (para == 1 && tvdemod_digital_volume_control.force_mute_tvd == 1)
	{
		return AIO_OK;
	}
	else if (para == 0 && tvdemod_digital_volume_control.force_mute_tvd == 0)
	{
		return AIO_OK;
	}
	#if 0
	while (1) {
		tvdemod_digital_volume_control.regValue = AIO_ReadRegister(AUDIO_TVdemod_Digital_Volume_Control_reg);
		if (tvdemod_digital_volume_control.dvol_apply_tvd == 1) {
			//alog("[AUDIO][DRV] dvol_apply = 1\n");
		} else {
			break;
		}

		time_out++;

		if (time_out > 0x800000) {
			alog_info("%s() TimeOut(0x%08x)!!!\n", __FUNCTION__, time_out);
			return AIO_ERROR;
		}
	}
	#endif

	if (1 == para) {    // Clayton 2013/1/3
		#if 0
		tvdemod_digital_volume_control.dvcm_tvd = 2; //Soft Ramp
		tvdemod_digital_volume_control.ramp_step_mute_tvd = 2; //4/8dB
		tvdemod_digital_volume_control.zcto_mute_tvd = 1; //1024*2^1/Fs
		#else
		tvdemod_digital_volume_control.dvcm_tvd = 0; //Immedicate change
		tvdemod_digital_volume_control.ramp_step_mute_tvd = 1; //2/8dB
		tvdemod_digital_volume_control.zcto_mute_tvd = 3; //1024*2^3/Fs
		#endif
		tvdemod_digital_volume_control.force_mute_tvd = para;
		AIO_WriteRegister(AUDIO_TVdemod_Digital_Volume_Control_reg, tvdemod_digital_volume_control.regValue);
	} else { // sap
		tvdemod_digital_volume_control.dvcm_tvd = 0; //Immedicate change
		tvdemod_digital_volume_control.ramp_step_mute_tvd = 1; //2/8dB
		tvdemod_digital_volume_control.zcto_mute_tvd = 3; //1024*2^3/Fs
		tvdemod_digital_volume_control.force_mute_tvd = para;
		AIO_WriteRegister(AUDIO_TVdemod_Digital_Volume_Control_reg, tvdemod_digital_volume_control.regValue);
	}

	#if 1
	while (1)
	{
		audio_hw_usleep(100);
		tvdemod_digital_volume_control.regValue = AIO_ReadRegister(AUDIO_TVdemod_Digital_Volume_Control_reg);
		if (para == 0 && tvdemod_digital_volume_control.switch_status_tvd == ATV_HW_IDLE_STATE)
		{
			break;
		}
		else if (para == 1 && tvdemod_digital_volume_control.switch_status_tvd == ATV_HW_FADE_OUT_DONE_STATE)
		{
			break;
		}

		time_out++;
		if (time_out > 600) {
			alog_err("%s() TimeOut(0x%x)!!!\n", __FUNCTION__, time_out);
			return AIO_ERROR;
		}
	}
	#endif

	return AIO_OK;
}

/**
 * Set SIF  Digital Volume
 *
 * @param <vol>		{ step = 0.125, range from APP_MIN_VOL ~ APP_MAX_VOL }
 */
static void HwpSetVolume_SIF(int32_t vol)
{
	audio_tvdemod_digital_volume_control_RBUS	tvdemod_digital_volume_control;
	audio_tvdemod_digital_volume_control_2_RBUS tvdemod_digital_volume_control_2;
	int32_t	a, b, c;
	//int32_t lr_idx = 0;
	uint32_t	time_out = 0;

	vol += g_sif_offset;
	down(&audio_sem_sif);
	tvdemod_digital_volume_control.regValue = Audio_HwpReadRegister(AUDIO_TVdemod_Digital_Volume_Control_reg);
	while (1)
	{
		audio_hw_usleep(100);
		tvdemod_digital_volume_control.regValue = Audio_HwpReadRegister(AUDIO_TVdemod_Digital_Volume_Control_reg);
		if (tvdemod_digital_volume_control.dvol_apply_tvd == 1 && tvdemod_digital_volume_control.force_mute_tvd == 0)
		{
			//alog_info("[AUDIO][APP] dvol_apply = 1\n");
		}
		else if (tvdemod_digital_volume_control.switch_status_tvd == ATV_HW_FADE_OUT_STATE
			|| tvdemod_digital_volume_control.switch_status_tvd == ATV_HW_FADE_IN_STATE)
		{
			
		}
		else
		{
			break;
		}
		time_out++;

		if (time_out > 600) {
			up(&audio_sem_sif);
			alog_info("%s() TimeOut(0x%x)!!!\n", __FUNCTION__, time_out);
			return;
		}
	}

	//APP_LOG("[AUDIO][APP] TimeOut = %d\n",time_out);

	if (vol > APP_MAX_VOL)
		vol = APP_MAX_VOL;

	if (vol < APP_MIN_VOL)
		vol = APP_MIN_VOL;

	c = vol&0x7;
	a = (vol >> 3) / 6;
	b = (vol >> 3) % 6;
	if (b < 0) {
		a--;
		b += 6;
	}

	alog_debug("sif_dvc_vol=%d, a=%d,b=%d,c=%d\n", vol, a, b, c);
	tvdemod_digital_volume_control_2.regValue = Audio_HwpReadRegister(AUDIO_TVdemod_Digital_Volume_Control_2_reg);

	//left & right channel
	tvdemod_digital_volume_control_2.vol_a_tvd = a;
	tvdemod_digital_volume_control_2.vol_b_tvd = (b << 3)|c;

	Audio_HwpWriteRegister(AUDIO_TVdemod_Digital_Volume_Control_2_reg, tvdemod_digital_volume_control_2.regValue);

	// is it necessary to protect application before IP finish the previous setting ?
	tvdemod_digital_volume_control.regValue = Audio_HwpReadRegister(AUDIO_TVdemod_Digital_Volume_Control_reg);
	tvdemod_digital_volume_control.dvol_apply_tvd = 1;

	Audio_HwpWriteRegister(AUDIO_TVdemod_Digital_Volume_Control_reg, tvdemod_digital_volume_control.regValue);
	up(&audio_sem_sif);
}

static int set_sif_eq_reg(unsigned int address, int data, int shift)
{
	unsigned int oridata, read_back, i;

	oridata = AIO_ReadRegister(address);

	if (shift == 1) {
		data = (oridata&0xFFFF)|((data&0xFFFF) << 16);
	} else {
		data = (oridata&0xFFFF0000)|(data&0xFFFF);
	}

	AIO_WriteRegister(address, data);

	// double buffer issue
	i = 1000;
	do {
		i--;
		read_back = AIO_ReadRegister(address);
		if (read_back == 0xdeaddead) {
			return AIO_ERROR;
		}
	}while ((read_back != (unsigned int)data) && (i != 0));

	return AIO_OK;
}

int audio_drv_set_sif_eq_coef_48K(ATV_SIF_EQ_48K_CFG *p_eq_cfg)
{
	int i = 0;

	/*
	 * if EQ/SPK_COMP is enabled, return fail!!
	 */
	if (p_eq_cfg != NULL)
		memcpy(&k_sif_eq_48K_cfg, (void *)p_eq_cfg, sizeof(ATV_SIF_EQ_48K_CFG));

	alog_debug("[ATV] ATV_SIF_EQ_BAND_NUM = %d \n", ATV_SIF_EQ_BAND_NUM);
	if (ATV_SIF_EQ_BAND_NUM > ATV_SIF_EQ_BAND_NUM_MAX)
	{
		alog_info("[ATV] WARNING! too much SIF EQ band\n");
		return AIO_ERROR;
	}

	// debug only ---------
	alog_debug("sif_eq_cfg.coef[0].a1 = %x\n", k_sif_eq_48K_cfg.coef[0].a1);
	alog_debug("sif_eq_cfg.coef[1].a2 = %x\n", k_sif_eq_48K_cfg.coef[1].a2);
	alog_debug("sif_eq_cfg.coef[2].h0 = %x\n", k_sif_eq_48K_cfg.coef[2].h0);
	/* bit0 = LPF, bit1~bit2 = BPF1~BPF2*/
	i = 0;
	if (i < ATV_SIF_EQ_BAND_NUM) {
		set_sif_eq_reg(AUDIO_EQ_tvd_lp_reg, k_sif_eq_48K_cfg.coef[i].a1, 1);
		set_sif_eq_reg(AUDIO_EQ_tvd_lp_reg, k_sif_eq_48K_cfg.coef[i].h0, 0);
		i++;
	}

	if (i < ATV_SIF_EQ_BAND_NUM) {
		set_sif_eq_reg(AUDIO_EQ_tvd_bp1_1_reg, k_sif_eq_48K_cfg.coef[i].a1, 1);
		set_sif_eq_reg(AUDIO_EQ_tvd_bp1_1_reg, k_sif_eq_48K_cfg.coef[i].a2, 0);
		set_sif_eq_reg(AUDIO_EQ_tvd_bp1_2_reg, k_sif_eq_48K_cfg.coef[i].h0, 0);
		i++;
	}

	if (i < ATV_SIF_EQ_BAND_NUM) {
		set_sif_eq_reg(AUDIO_EQ_tvd_bp2_1_reg, k_sif_eq_48K_cfg.coef[i].a1, 1);
		set_sif_eq_reg(AUDIO_EQ_tvd_bp2_1_reg, k_sif_eq_48K_cfg.coef[i].a2, 0);
		set_sif_eq_reg(AUDIO_EQ_tvd_bp2_2_reg, k_sif_eq_48K_cfg.coef[i].h0, 0);
		i++;
	}

	return AIO_OK;
}

int32_t Audio_HwpSetSIFEQCoef_48K(ATV_SIF_EQ_48K_CFG *p_cfg_eq)
{
	if (p_cfg_eq == NULL)
		alog_info(" SIF EQ table error\n");

	audio_drv_set_sif_eq_coef_48K(p_cfg_eq);

	return AIO_OK;
}
#if 0
void DisableSIFEQPara(void)
{
	audio_eq_tvd_lp_RBUS	eq_tvd_lp;
	audio_eq_tvd_bp1_1_RBUS eq_tvd_bp1_1;
	audio_eq_tvd_bp1_2_RBUS eq_tvd_bp1_2;
	audio_eq_tvd_bp2_1_RBUS eq_tvd_bp2_1;
	audio_eq_tvd_bp2_2_RBUS eq_tvd_bp2_2;

	// Step1:
	alog_info("DisableSIFEQPara\n");
	eq_tvd_lp.regValue = AIO_ReadRegister(AUDIO_EQ_tvd_lp_reg);
	eq_tvd_lp.eq_tvd_lp_a1 = 0;
	eq_tvd_lp.eq_tvd_lp_h0 = 0;

	eq_tvd_bp1_1.regValue = AIO_ReadRegister(AUDIO_EQ_tvd_bp1_1_reg);
	eq_tvd_bp1_1.eq_tvd_bp1_a1 = 0;
	eq_tvd_bp1_1.eq_tvd_bp1_a2 = 0;
	eq_tvd_bp1_2.regValue = AIO_ReadRegister(AUDIO_EQ_tvd_bp1_2_reg);
	eq_tvd_bp1_2.eq_tvd_bp1_h0 = 0;

	eq_tvd_bp2_1.regValue = AIO_ReadRegister(AUDIO_EQ_tvd_bp2_1_reg);
	eq_tvd_bp2_1.eq_tvd_bp2_a1 = 0;
	eq_tvd_bp2_1.eq_tvd_bp2_a2 = 0;
	eq_tvd_bp2_2.regValue = AIO_ReadRegister(AUDIO_EQ_tvd_bp2_2_reg);
	eq_tvd_bp2_2.eq_tvd_bp2_h0 = 0;

	// Step2:

	AIO_WriteRegister(AUDIO_EQ_tvd_lp_reg, eq_tvd_lp.regValue);
	AIO_WriteRegister(AUDIO_EQ_tvd_bp1_1_reg, eq_tvd_bp1_1.regValue);
	AIO_WriteRegister(AUDIO_EQ_tvd_bp1_2_reg, eq_tvd_bp1_2.regValue);
	AIO_WriteRegister(AUDIO_EQ_tvd_bp2_1_reg, eq_tvd_bp2_1.regValue);
	AIO_WriteRegister(AUDIO_EQ_tvd_bp2_2_reg, eq_tvd_bp2_2.regValue);
}
#endif
uint32_t isSIFEQOverflow(void)
{
	audio_eq_tvd_bp_status_RBUS eq_tvd_bp_status;
	uint32_t sif_eq_overflow;

	eq_tvd_bp_status.regValue = AIO_ReadRegister(AUDIO_EQ_tvd_bp_Status_reg);
	sif_eq_overflow = eq_tvd_bp_status.eq_tvd_lp_of|eq_tvd_bp_status.eq_tvd_band1_of|eq_tvd_bp_status.eq_tvd_band2_of;

	return sif_eq_overflow;
}

void CleanSIFEQOverflow(void)
{
	audio_hw_process_control_RBUS         hw_process_control, hw_process_control_bk;
	audio_loudness_status_register_RBUS   loudness_status_register;
	audio_eq_status_register_RBUS         eq_status_register;
	audio_system_int_en_RBUS              system_int_en_RBUS;

	uint32_t	count = 0;
	audio_eq_control_register_RBUS	eq_control_reg, eq_control_reg_bk;
	audio_loudness_control_register_RBUS	loudness_control_reg, loudness_control_reg_bk;
	audio_eq_hp_RBUS		eq_hp_reg;
	audio_eq_lp_RBUS		eq_lp_reg;
	audio_eq_bp1_1_RBUS	eq_bp1_1_reg;
	audio_eq_bp1_2_RBUS	eq_bp1_2_reg;
	audio_eq_bp2_1_RBUS	eq_bp2_1_reg;
	audio_eq_bp2_2_RBUS	eq_bp2_2_reg;


	audio_eq_tvd_lp_RBUS eq_tvd_lp;
	audio_eq_tvd_bp1_1_RBUS eq_tvd_bp1_1;
	audio_eq_tvd_bp1_2_RBUS eq_tvd_bp1_2;
	audio_eq_tvd_bp2_1_RBUS eq_tvd_bp2_1;
	audio_eq_tvd_bp2_2_RBUS eq_tvd_bp2_2;
	audio_eq_tvd_bp_status_RBUS eq_tvd_bp_status;
	audio_eq_tvd_bp_control_RBUS eq_tvd_bp_control, eq_tvd_bp_control_bk;

	// Step1: Backup EQ & Loudness parameters
	alog_info("CleanSIFEQLoudnessOverflow step1\n");
	eq_tvd_lp.regValue = AIO_ReadRegister(AUDIO_EQ_tvd_lp_reg);
	eq_tvd_bp1_1.regValue = AIO_ReadRegister(AUDIO_EQ_tvd_bp1_1_reg);
	eq_tvd_bp1_2.regValue = AIO_ReadRegister(AUDIO_EQ_tvd_bp1_2_reg);
	eq_tvd_bp2_1.regValue = AIO_ReadRegister(AUDIO_EQ_tvd_bp2_1_reg);
	eq_tvd_bp2_2.regValue = AIO_ReadRegister(AUDIO_EQ_tvd_bp2_2_reg);

	// Step2: Clear all the parameters for overflow bands
	eq_tvd_bp_status.regValue = AIO_ReadRegister(AUDIO_EQ_tvd_bp_Status_reg);

	if (eq_tvd_bp_status.eq_tvd_lp_of == 1) {
		alog_info("CleanSIFEQLoudnessOverflow step2 : eq_tvd_lp_of\n");
		AIO_WriteRegister(AUDIO_EQ_tvd_lp_reg, 0);
	}

	if (eq_tvd_bp_status.eq_tvd_band1_of == 1) {
		alog_info("CleanEQLoudnessOverflow step2 : eq_tvd_band1_of\n");
		AIO_WriteRegister(AUDIO_EQ_tvd_bp1_1_reg, 0);
		AIO_WriteRegister(AUDIO_EQ_tvd_bp1_2_reg, 0);
	}

	if (eq_tvd_bp_status.eq_tvd_band2_of == 1) {
		alog_info("CleanEQLoudnessOverflow step2 : eq_tvd_band2_of\n");
		AIO_WriteRegister(AUDIO_EQ_tvd_bp2_1_reg, 0);
		AIO_WriteRegister(AUDIO_EQ_tvd_bp2_2_reg, 0);
	}

	// Step3: Clear overflow flag, Max clear 10 times
	do {
		eq_tvd_bp_status.regValue = AIO_ReadRegister(AUDIO_EQ_tvd_bp_Status_reg);
		Audio_HwpWriteRegister(AUDIO_EQ_tvd_bp_Status_reg, eq_tvd_bp_status.regValue);

		if (++count > 10) {
			alog_info("CleanSIFEQLoudnessOverflow step3 : count= %d, break\n", count);
			break;
		}
		alog_info("CleanSIFEQLoudnessOverflow step3 : count= %d\n", count);
	} while (isSIFEQOverflow());

	// Step4: Disable Main power of SIF_EQ
	eq_tvd_bp_control.regValue = AIO_ReadRegister(AUDIO_EQ_tvd_bp_Control_reg);
	eq_tvd_bp_control_bk.regValue = eq_tvd_bp_control.regValue;
	eq_tvd_bp_control.eq_tvd_deq_enable = 0;
	AIO_WriteRegister(AUDIO_EQ_tvd_bp_Control_reg, eq_tvd_bp_control.regValue);
	alog_info("CleanSIFEQLoudnessOverflow step4 : eq_tvd_bp_control= %x\n", eq_tvd_bp_control.regValue);

	// Step5: Disable Sub power of SIF_EQ
	eq_tvd_bp_control.regValue = AIO_ReadRegister(AUDIO_EQ_tvd_bp_Control_reg);
	eq_tvd_bp_control.eq_tvd_lp_enable = 0;
	eq_tvd_bp_control.eq_tvd_band1_enable = 0;
	eq_tvd_bp_control.eq_tvd_band2_enable = 0;
	AIO_WriteRegister(AUDIO_EQ_tvd_bp_Control_reg, eq_tvd_bp_control.regValue);
	alog_info("CleanSIFEQLoudnessOverflow step5 : eq_tvd_bp_control= %x", eq_tvd_bp_control.regValue);

	// Step6: Write back the parameters of EQ/Loudness
	AIO_WriteRegister(AUDIO_EQ_tvd_lp_reg, eq_tvd_lp.regValue);
	AIO_WriteRegister(AUDIO_EQ_tvd_bp1_1_reg, eq_tvd_bp1_1.regValue);
	AIO_WriteRegister(AUDIO_EQ_tvd_bp1_2_reg, eq_tvd_bp1_2.regValue);
	AIO_WriteRegister(AUDIO_EQ_tvd_bp2_1_reg, eq_tvd_bp2_1.regValue);
	AIO_WriteRegister(AUDIO_EQ_tvd_bp2_2_reg, eq_tvd_bp2_2.regValue);
	alog_info("CleanSIFEQLoudnessOverflow step6 : Write back\n");
	audio_hw_usleep(10);

	// Step7: Enable Sub power of EQ & Loudness
	Audio_HwpWriteRegister(AUDIO_EQ_tvd_bp_Control_reg, eq_tvd_bp_control_bk.regValue&0x7);
	alog_info("CleanSIFEQLoudnessOverflow step7 : Enable Sub power of SIF_EQ %x\n", eq_tvd_bp_control_bk.regValue);

	// Step8: Enable Main power of EQ & Loudness
	Audio_HwpWriteRegister(AUDIO_EQ_tvd_bp_Control_reg, eq_tvd_bp_control_bk.regValue);
	alog_info("CleanSIFEQLoudnessOverflow step7 : Enable Main power of SIF_EQ %x\n", eq_tvd_bp_control_bk.regValue);
}

void AIO_WriteMask(uint32_t address, uint32_t val)
{
	uint32_t data = AIO_ReadRegister(address);

	data = data|val;
	AIO_WriteRegister(address, data);
	alog_info("address = %x val = %x\n", address, data);
}

void AtvLowBTSCSAPModeDetectThreshold(void)
{
	audio_btsc_sap_status_RBUS btsc_sap_status;
	audio_btsc_sap_thresh_RBUS btsc_sap_thresh;
	audio_btsc_sap_noise_RBUS btsc_sap_noise;

	btsc_sap_status.regValue = AIO_ReadRegister(AUDIO_btsc_sap_status_reg);
	btsc_sap_thresh.regValue = AIO_ReadRegister(AUDIO_btsc_sap_thresh_reg);
	btsc_sap_noise.regValue = AIO_ReadRegister(AUDIO_btsc_sap_noise_reg);

	//add SNR protection for lower SAP detect threshold
	if (btsc_sap_status.w10sapmagnitude - btsc_sap_noise.w10sapnoise > Low_BTSC_SAP_SIGNAL_NOISE_RATIO) {
		btsc_sap_thresh.sap_hithresh = Low_BTSC_SAP_THRESHOLD_HIGH;
		btsc_sap_thresh.sap_lothresh = Low_BTSC_SAP_THRESHOLD_LOW;
		AIO_WriteRegister(AUDIO_btsc_sap_thresh_reg, btsc_sap_thresh.regValue);
	} else {
		btsc_sap_thresh.sap_hithresh = atv_cfg.m_btsc_sap_threshold_high;
		btsc_sap_thresh.sap_lothresh = atv_cfg.m_btsc_sap_threshold_low;
		AIO_WriteRegister(AUDIO_btsc_sap_thresh_reg, btsc_sap_thresh.regValue);
	}

	alog_info("[low] sap Hi_th Lo_th = %x %x\n", btsc_sap_thresh.sap_hithresh, btsc_sap_thresh.sap_lothresh);
}

void AtvNormalBTSCSAPModeDetectThreshold(void)
{
	audio_btsc_sap_status_RBUS btsc_sap_status;
	audio_btsc_sap_thresh_RBUS btsc_sap_thresh;

	btsc_sap_status.regValue = AIO_ReadRegister(AUDIO_btsc_sap_status_reg);
	btsc_sap_thresh.regValue = AIO_ReadRegister(AUDIO_btsc_sap_thresh_reg);

	btsc_sap_thresh.sap_hithresh = atv_cfg.m_btsc_sap_threshold_high;
	btsc_sap_thresh.sap_lothresh = atv_cfg.m_btsc_sap_threshold_low;
	AIO_WriteRegister(AUDIO_btsc_sap_thresh_reg, btsc_sap_thresh.regValue);
	alog_info("[normal] sap Hi_th Lo_th = %x %x\n", btsc_sap_thresh.sap_hithresh, btsc_sap_thresh.sap_lothresh);
}

int32_t AtvCheckVideoTiming(ATV_SOUND_STD_MAIN_SYSTEM main_sys)
{
	uint32_t vd_decision_mode_status, video_status_reg3;
	uint32_t vd_sep_burst_ro_2, sep_443_burst, sep_358_burst, line_625_flag;
	int timing_match_flag = 0;

	vd_decision_mode_status = AIO_ReadRegister(VD_MODE_DETECTION_STATUS_VADDR)&0x7;
	vd_sep_burst_ro_2 = AIO_ReadRegister(VD_SEP_BURST_RO_2_VADDR);
	video_status_reg3 = AIO_ReadRegister(VIDEO_STATUS_REG3_VADDR);
	sep_443_burst = (vd_sep_burst_ro_2&0xFF00) >> 8;
	sep_358_burst = vd_sep_burst_ro_2&0xFF;
	line_625_flag = (video_status_reg3&0x4) >> 2;

	alog_info("vd_decision_mode_status = %d\n", vd_decision_mode_status);
	alog_info("vd_sep_burst_ro_2 = %x\n", vd_sep_burst_ro_2);
	alog_info("line_625_flag = %x\n", line_625_flag);

	if (main_sys == ATV_SOUND_MN_SYSTEM) {
		//if(vd_decision_mode_status < 0x4 && sep_358_burst > BURST_TH) //add threshold for avoiding fake burst
		if (sep_358_burst > BURST_TH) {  // mono
			timing_match_flag = 1;
			alog_info("video timing is MN system, return SNR\n");
		} else if (sep_443_burst > BURST_TH) {
			timing_match_flag = 0;
			alog_info("fake MN system, return 0\n");
		} else {    // Clayton ; Date: 2013/1/3
			if (Check625LineDetect() == 1) {
				timing_match_flag = 0;
				alog_info("line 625 is detected, return 0\n");
			} else {
				timing_match_flag = 1;
				alog_info("video timing is MN system but no burst, return SNR\n");
			}
		}
	} else if (main_sys == ATV_SOUND_DK_SYSTEM || main_sys == ATV_SOUND_L_SYSTEM) {
		//if(vd_decision_mode_status > 0x3 && sep_443_burst > BURST_TH) //add threshold for avoiding fake burst
		if (sep_443_burst > BURST_TH) {  // mono
			timing_match_flag = 1;
			alog_info("video timing is DK or L system, return SNR\n");
		} else if (sep_358_burst > BURST_TH) {
			timing_match_flag = 0;
			alog_info("fake DK or L system, return 0\n");
		} else { // sap
#if 0
			if(Check625LineDetect() == 1){
				timing_match_flag = 1;
				alog_info("video timing is DK or L system but no burst, return SNR\n");
			} else {
				timing_match_flag = 0;
				alog_info("line 625 is not detected, return 0\n");
			}
#else
			timing_match_flag = 1;
			alog_info("video timing is DK or L system but no burst, return SNR\n");
#endif
		}
	} else {  // mono
		timing_match_flag = 1;
	}

	return timing_match_flag;
}

int Check625LineDetect(void)
{
	uint32_t video_status_reg3;
	uint32_t line_625_flag;

	video_status_reg3 = AIO_ReadRegister(VIDEO_STATUS_REG3_VADDR);
	line_625_flag = (video_status_reg3&0x4) >> 2;

	if (line_625_flag == 0) {
		audio_hw_usleep(200000); //200ms
		alog_info("wait for VD stable\n");
	}

	video_status_reg3 = AIO_ReadRegister(VIDEO_STATUS_REG3_VADDR);
	line_625_flag = (video_status_reg3&0x4) >> 2;
	return	line_625_flag;
}

ATV_SOUND_STD Audio_HwSIFRetrunSoundStandard(int debounce_sound_std)
{
	ATV_SOUND_STD HwDetectStd;
	ATV_SOUND_STD FwReturnStd;

	HwDetectStd = (ATV_SOUND_STD)AtvGetHWStd();
	if (debounce_sound_std == ATV_SOUND_STD_UNKNOWN) {
		if (HwDetectStd == ATV_SOUND_STD_UNKNOWN) {
			FwReturnStd = (ATV_SOUND_STD)g_UserStd;
		} else {
			//g_CurrentHWDetectStd = HwDetectStd; //don't update g_CurrentHWDetectStd
			FwReturnStd = HwDetectStd;
		}
	} else {
		//*detected_sound_std = (ATV_SOUND_STD)AtvGetHWStd();
		FwReturnStd = (ATV_SOUND_STD)g_CurrentHWDetectStd;
	}

	alog_debug("HwDetectStd / debounce_sound_std  / FwReturnStd = %x %x %x\n", HwDetectStd, debounce_sound_std, FwReturnStd);

	return FwReturnStd;
}

uint32_t AtvGetSubThresh(ATV_SUB_TONE_RATIO ratio, uint32_t main_tone)
{
	uint32_t subThresh;

	switch (ratio) {
	case ATV_SUB_3_32:
		subThresh = (main_tone >> 5) + (main_tone >> 4);
		break;
	case ATV_SUB_3_64:
		subThresh = (main_tone >> 6) + (main_tone >> 5);
		break;
	case ATV_SUB_1_32:
		subThresh = (main_tone >> 5);
		break;
	case ATV_SUB_4_64:
		subThresh = (main_tone >> 4);
		break;
	case ATV_SUB_5_64:
		subThresh = (main_tone >> 4) + (main_tone >> 6);
		break;
	default :
		subThresh = (main_tone >> 6);
		break;
	}

	// Too frequently to print log, disable default and enable it if needs.
	//alog_info("ratio, subThresh = %x %x\n", ratio, subThresh);

	return subThresh;
}

int32_t AUDIO_SIF_SetBandSetup(ATV_AUDIO_SIF_TYPE_T eSifType, ATV_SOUND_STD_MAIN_SYSTEM sifBand)
{
	alog_info("[%s] SIF set band %d\n", __FUNCTION__, (int)sifBand);
	Audio_HwpSetChannelChange();
	Audio_HwpSetBandDelay();
	if (sifBand<ATV_SOUND_BG_SYSTEM &&sifBand> ATV_SOUND_MN_SYSTEM) {
		alog_info("[%s] error sifBand %d\n", __FUNCTION__, (int32_t)sifBand);
		return AIO_ERROR;
	} else {
		if (Audio_HwpSetAtvAudioBand(sifsource, sifBand) == -1) {
			alog_info("[%s] Audio_HwpSetAtvAudioBand not success\n", __FUNCTION__);
		}

		Audio_HwpCurSifType(eSifType);
	}

	return AIO_OK;
}

int32_t Audio_AtvGetCurrentDetectUpdate(int *isComplete)
{
    *isComplete = g_CurrentHWDetectUpdate;
    return AIO_OK;
}
int32_t Audio_SetAudioHWConfig(int32_t config)
{
	g_user_config = config;
	return AIO_OK;
}

void audio_sif_adc_initial_flow(void)
{
	tv_sb1_ana_ifadc_ctrl1_RBUS ifadc_ctrl1;
	tv_sb1_ana_ifadc_ctrl2_RBUS ifadc_ctrl2;

	tv_sb1_ana_iqadc_ctrl0_RBUS iqadc_ctrl0;
	tv_sb1_ana_iqadc_ctrl2_RBUS iqadc_ctrl2;
	tv_sb1_ana_iqadc_ctrl3_RBUS iqadc_ctrl3;
	tv_sb1_ana_iqadc_ctrl4_RBUS iqadc_ctrl4;
	tv_sb1_ana_iqadc_ctrl5_RBUS iqadc_ctrl5;
	tv_sb1_ana_iqadc_ctrl7_RBUS iqadc_ctrl7;

	ifadc_ctrl1.regValue = IoReg_Read32(TV_SB1_ANA_IFADC_CTRL1_reg);
	ifadc_ctrl2.regValue = IoReg_Read32(TV_SB1_ANA_IFADC_CTRL2_reg);

	iqadc_ctrl0.regValue = IoReg_Read32(TV_SB1_ANA_IQADC_CTRL0_reg);
	iqadc_ctrl2.regValue = IoReg_Read32(TV_SB1_ANA_IQADC_CTRL2_reg);
	iqadc_ctrl3.regValue = IoReg_Read32(TV_SB1_ANA_IQADC_CTRL3_reg);
	iqadc_ctrl4.regValue = IoReg_Read32(TV_SB1_ANA_IQADC_CTRL4_reg);
	iqadc_ctrl5.regValue = IoReg_Read32(TV_SB1_ANA_IQADC_CTRL5_reg);
	iqadc_ctrl7.regValue = IoReg_Read32(TV_SB1_ANA_IQADC_CTRL7_reg);

	//IFADC+IFPGA power on
	ifadc_ctrl1.reg_pow_mbias = 1; //[16]REG_POW_MBIAS
	IoReg_Write32(TV_SB1_ANA_IFADC_CTRL1_reg, ifadc_ctrl1.regValue);

	ifadc_ctrl2.reg_adc2x_difpow = 1; //[24]REG_ADC2X_DIFPOW
	IoReg_Write32(TV_SB1_ANA_IFADC_CTRL2_reg, ifadc_ctrl2.regValue);

	//IQADC+IQPGA power on
	iqadc_ctrl7.reg_qadc_meta_pow = 1; //[12]REG_QADC_META_POW, [8]REG_IADC_META_POW
	iqadc_ctrl7.reg_iadc_meta_pow = 1;
	IoReg_Write32(TV_SB1_ANA_IQADC_CTRL7_reg, iqadc_ctrl7.regValue);

	iqadc_ctrl3.reg_pow_q_pga = 1; //[12]REG_POW_Q_PGA, [8]REG_POW_I_PGA, [4]REG_POW_Q_ADC, [0]REG_POW_I_ADC
	iqadc_ctrl3.reg_pow_q_adc = 1;
	iqadc_ctrl3.reg_pow_i_pga = 1;
	iqadc_ctrl3.reg_pow_i_adc = 1;
	IoReg_Write32(TV_SB1_ANA_IQADC_CTRL3_reg, iqadc_ctrl3.regValue);

	//Fix IFPGA 2dB
	iqadc_ctrl2.reg_adc2x_fixgain= 0; //[6:4]REG_ADC2X_FIXGAIN, Fix IFPGA 2dB, [0]REG_IF_FIX_EN
	iqadc_ctrl2.reg_if_fix_en= 1;
	IoReg_Write32(TV_SB1_ANA_IQADC_CTRL2_reg, iqadc_ctrl2.regValue);

	iqadc_ctrl5.reg_ipga_d = 2; //[3:0]REG_IPGA_D, IPGA gain adjust 0x2: 2dB
	IoReg_Write32(TV_SB1_ANA_IQADC_CTRL5_reg, iqadc_ctrl5.regValue);

	// SIF Audio related setting

	iqadc_ctrl0.reg_ckout_sel_q = 0; //REG_CKOUT_SEL_Q--> 0:Q_CKOUT
	IoReg_Write32(TV_SB1_ANA_IQADC_CTRL0_reg, iqadc_ctrl0.regValue);

	iqadc_ctrl4.reg_qpga_input_sel = 0x4; //REG_QPGA_INPUT_SEL  100: SIF input
	IoReg_Write32(TV_SB1_ANA_IQADC_CTRL4_reg, iqadc_ctrl4.regValue);

	iqadc_ctrl7.reg_qadc_vref_sel = 0; //1.23V
	iqadc_ctrl7.reg_iadc_vref_sel = 0; //1.23V
	iqadc_ctrl7.reg_qadc_ldo_sel = 0; //0.95V
	iqadc_ctrl7.reg_iadc_ldo_sel = 0; //0.95V
	IoReg_Write32(TV_SB1_ANA_IQADC_CTRL7_reg, iqadc_ctrl7.regValue);

	iqadc_ctrl2.reg_iqcmp_isel = 0x4; //50uA(default)
	IoReg_Write32(TV_SB1_ANA_IQADC_CTRL2_reg, iqadc_ctrl2.regValue);

	iqadc_ctrl5.reg_q_ckin_sel = 0x2; //REG_Q_CKIN_SEL 10: CK_24M From Digital
	IoReg_Write32(TV_SB1_ANA_IQADC_CTRL5_reg, iqadc_ctrl5.regValue);
}

void Audio_Hw_SetFmRadioMode(AUDIO_ATV_FM_RADIO_MODE Enable)
{
	if (g_FM_RADIO_MODE != Enable)
	{
		audio_btsc_pilot_thres_RBUS abtsc_pilot_thres_RBUS;

		g_FM_RADIO_MODE = Enable;
		audio_hw_usleep(100);
		abtsc_pilot_thres_RBUS.regValue = AIO_ReadRegister(AUDIO_btsc_pilot_thres_reg);
		if (Enable == AUDIO_ATV_FM_RADIO_PLAY)
		{
			abtsc_pilot_thres_RBUS.fm_radio_en = 1;
			Audio_AtvChangebtscpilotphasedelta(ATV_PILOT_PHASE_DELTA_FM_RADIO);
		}
		else
		{
			abtsc_pilot_thres_RBUS.fm_radio_en = 0;
			Audio_AtvChangebtscpilotphasedelta(ATV_PILOT_PHASE_DELTA_Others);
		}

		AIO_WriteRegister(AUDIO_btsc_pilot_thres_reg, abtsc_pilot_thres_RBUS.regValue);
	}
}

AUDIO_ATV_FM_RADIO_MODE ATV_GetFmRadioMode(void)
{
	return g_FM_RADIO_MODE;
}

void Audio_Auto_Verify_Set_Path(void)
{
	#if 0 //ryanlan
	//pll_audio init
	alog_err("[owen] Audio_DDTS_BringUp\n");
	WriteRegister(0xb8000104,0x000F8000);
	WriteRegister(0xb8000104, _BIT19|_BIT18|_BIT17|_BIT16|_BIT15|_BIT0);

	WriteRegister(0xb800011c,0x000003FE);
	WriteRegister(0xb800011c, _BIT9|_BIT8|_BIT7|_BIT6|_BIT5|_BIT4|_BIT3|_BIT2|_BIT1|_BIT0);

  	WriteRegister(0xb8000114,0x00038000);
  	WriteRegister(0xb8000114, _BIT17|_BIT16|_BIT15|_BIT0);
 
  	WriteRegister(0xb8000118,0x00009000);
  	WriteRegister(0xb8000118, _BIT15|_BIT12|_BIT0);

	WriteRegister(0xb80004d4,0x88085501);//Enable Audio PLL related LDO, PLL_POW_LDO11V & PLL_POW_LDO
	WriteRegister(0xb80004e4,0x00000019);//Enable PLLAUD_CK196M/CK295M output
	WriteRegister(0xb80004b4,0x00000003);//Enable PLL512Fs output*/
	WriteRegister(0xb80004ec,0x0000000C);//PSAUD_EN, PSAUD_PSEN 0 --> 1

	//audio path init
	audio_hw_usleep(1000); //ideal 80us, wait 1ms.
	
	WriteMaskRegister(0xb8006004, ~(_BIT31|_BIT30|_BIT29|_BIT28), _BIT31|_BIT30|_BIT29|_BIT28);//SDRAM on
	WriteMaskRegister(0xb8006004, ~(_BIT20), _BIT20);//SIF ADC CLOCK on
	WriteMaskRegister(0xb8006004, ~(_BIT13|_BIT12|_BIT5|_BIT4), _BIT13|_BIT5);//PLL AUDIO
	alog_err("[owen] 0xb8006004 = %x\n", IoReg_Read32(0xb8006004));

	WriteMaskRegister(0xb8006b5c, ~(_BIT3|_BIT2), _BIT3|_BIT2);//enable output normal mode FOR HP/AIO Frank

	WriteMaskRegister(0xb8006b58, ~(_BIT10|_BIT9|_BIT8|_BIT2|_BIT1), _BIT10|_BIT2|_BIT1);//enable HPO/AIO enable depop
	
	WriteMaskRegister(0xb8033000, ~(_BIT24),_BIT24);// turn on "REG_VDAC_POWMBIAS" for BB audio
	//ryanliao turn on audio power
	WriteMaskRegister(0xb8006b44, ~(_BIT11|_BIT10|_BIT9|_BIT8|_BIT7|_BIT6|_BIT5|_BIT4|_BIT3|_BIT2),
	_BIT11|_BIT10|_BIT9|_BIT8|_BIT7|_BIT6|_BIT5|_BIT4|_BIT3|_BIT2);

	WriteMaskRegister(0xb8006038, ~(_BIT8|_BIT7|_BIT6|_BIT5|_BIT4), _BIT8|_BIT7|_BIT6|_BIT5|_BIT4);// enable tv_demod, i2s_out, spdif_out functions

	WriteRegister(0xb8006700, 0x00000000);

	WriteRegister(0xb8006b48, 0x00023000);// HPO mode
	WriteRegister(0xb8006b4c, 0xD5D517D5);// HPO bias control (11: 20u)
	WriteRegister(0xb8006b10, 0x000C0003);//DAC_0_1 setting PB(modify)
	WriteRegister(0xb8006b38, 0x80180005);//DAC0_HPO DAC1_AIO1 unmute L channel
	WriteRegister(0xb8006b3c, 0x00180005);//DAC0_HPO DAC1_AIO1 unmute R channel
	#endif
	//K4L
	//WriteMaskRegister(0xb800635c, 0xF7FFFFFF, 0); //disable SIF DVC
	//WriteMaskRegister(0xb80067bc, ~(_BIT31|_BIT15), 0);

	AIO_WriteRegister(0xb8006004, 0xF0102222);//PLL audio, turn on ADC/DAC SDRAM
	AIO_WriteRegister(0xb8006b10, 0x000C0003);//DAC_0_1 setting PB(modify)
	AIO_WriteRegister(0xb8006700, 0x00000014);
}

void Audio_Hw_Set_Scan_Std_Flag(bool Flag)
{
	g_AudioScanSoundStdFlag = Flag;
}

bool ATV_Get_Scan_Std_Flag(void)
{
	return g_AudioScanSoundStdFlag;
}

void Audio_AtvSetFwPriority(uint16_t Priority)
{
	g_FwStdPriority = Priority;
}

uint16_t AtvGetFwPriority(void)
{
	return g_FwStdPriority;
}
