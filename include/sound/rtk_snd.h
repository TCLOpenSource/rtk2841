#ifndef _SND_REALTEK_H_
#define _SND_REALTEK_H_

#define S_OK		0x10000000
#define RPCCMD_CONFIG_USB_AUDIO_IN	0

enum RINGBUFFER_TYPE {
	RINGBUFFER_STREAM,
	RINGBUFFER_COMMAND,
	RINGBUFFER_MESSAGE,
	RINGBUFFER_VBI,
	RINGBUFFER_PTS,
	RINGBUFFER_DTVCC
};

enum ENUM_AUDIO_KERNEL_RPC_CMD {
	ENUM_KERNEL_RPC_CREATE_AGENT,
	ENUM_KERNEL_RPC_INIT_RINGBUF,
	ENUM_KERNEL_RPC_PRIVATEINFO,
	ENUM_KERNEL_RPC_RUN,
	ENUM_KERNEL_RPC_PAUSE,
	ENUM_KERNEL_RPC_SWITCH_FOCUS,
	ENUM_KERNEL_RPC_MALLOC_ADDR,
	ENUM_KERNEL_RPC_VOLUME_CONTROL,
	ENUM_KERNEL_RPC_FLUSH,
	ENUM_KERNEL_RPC_CONNECT,
	ENUM_KERNEL_RPC_SETREFCLOCK,
	ENUM_KERNEL_RPC_DAC_I2S_CONFIG,
	ENUM_KERNEL_RPC_DAC_SPDIF_CONFIG,
	ENUM_KERNEL_RPC_HDMI_OUT_EDID,
	ENUM_KERNEL_RPC_HDMI_OUT_EDID2,
	ENUM_KERNEL_RPC_HDMI_SET,
	ENUM_KERNEL_RPC_HDMI_MUTE,
	ENUM_KERNEL_RPC_ASK_DBG_MEM_ADDR,
	ENUM_KERNEL_RPC_DESTROY,
	ENUM_KERNEL_RPC_STOP,

	/* check if Audio get memory pool from AP */
	ENUM_KERNEL_RPC_CHECK_READY,

	/* get mute and volume level */
	ENUM_KERNEL_RPC_GET_MUTE_N_VOLUME,
	ENUM_KERNEL_RPC_EOS,
	ENUM_KERNEL_RPC_ADC0_CONFIG
};

enum AUDIO_CONFIG_CMD_MSG {
	AUDIO_CONFIG_CMD_SPEAKER = 0,
	AUDIO_CONFIG_CMD_AGC = 1,
	AUDIO_CONFIG_CMD_SPDIF = 2,
	AUDIO_CONFIG_CMD_VOLUME = 3,
	AUDIO_CONFIG_CMD_MUTE = 4,
	AUDIO_CONFIG_CMD_AO_MIC = 5,
	AUDIO_CONFIG_CMD_AO_AUX = 6,
	AUDIO_CONFIG_CMD_AO_ECHO_REVERB = 7,
	AUDIO_CONFIG_CMD_AO_MIC1_VOLUME = 8,
	AUDIO_CONFIG_CMD_AO_MIC2_VOLUME = 9,
	AUDIO_CONFIG_CMD_AO_DEC_VOLUME = 10,
	AUDIO_CONFIG_CMD_AO_AUX_VOLUME = 11,
	AUDIO_CONFIG_CMD_DAC_SWITCH = 12,
	AUDIO_CONFIG_CMD_DD_DUALMONO = 13,
	AUDIO_CONFIG_CMD_DD_SCALE = 14,
	AUDIO_CONFIG_CMD_DD_DOWNMIXMODE = 15,
	AUDIO_CONFIG_CMD_DD_COMP = 16,
	AUDIO_CONFIG_CMD_DD_LFE = 17,
	AUDIO_CONFIG_CMD_DD_STEREOMIX = 18,
	AUDIO_CONFIG_CMD_DIGITAL_OUT = 19,
	AUDIO_CONFIG_CMD_EXCLUSIVE = 20,
	AUDIO_CONFIG_CMD_AC3_SPDIF_RAW = 21,
	AUDIO_CONFIG_CMD_AC3_HDMI_RAW = 22,
	AUDIO_CONFIG_CMD_DTS_SPDIF_RAW = 23,
	AUDIO_CONFIG_CMD_DTS_HDMI_RAW = 24,
	AUDIO_CONFIG_CMD_MPG_SPDIF_RAW = 25,
	AUDIO_CONFIG_CMD_MPG_HDMI_RAW = 26,
	AUDIO_CONFIG_CMD_AAC_SPDIF_RAW = 27,
	AUDIO_CONFIG_CMD_AAC_HDMI_RAW = 28,
	AUDIO_CONFIG_CMD_MLP_HDMI_RAW = 29,
	AUDIO_CONFIG_CMD_DDP_HDMI_RAW = 30,
	AUDIO_CONFIG_CMD_HDMI_CHANNEL_OUT = 31,
	AUDIO_CONFIG_CMD_FORCE_CHANNEL_CODEC = 32,
	AUDIO_CONFIG_CMD_MLP_SPDIF_RAW = 33,
	AUDIO_CONFIG_CMD_DDP_SPDIF_RAW = 34,
	AUDIO_CONFIG_CMD_MAX_OUTPUT_SAMPLERATE = 35,
	AUDIO_CONFIG_CMD_USB_DEVICE_SUPPORT_SAMPLERATE = 36,
	AUDIO_CONFIG_CMD_KARAOKE_MODE = 37,
	AUDIO_CONFIG_CMD_BRAZIL_LATM_AAC = 38,
	AUDIO_CONFIG_CMD_DRC_PERCENT = 39,
	AUDIO_CONFIG_CMD_LICENSE_MODE = 40,
	AUDIO_CONFIG_CMD_AUDIO_TYPE_PRIORITY = 41,
};

struct AUDIO_CONFIG_COMMAND {
	enum AUDIO_CONFIG_CMD_MSG msg_id;
	unsigned int value[6];
};

struct AUDIO_RPC_SENDIO {
	int instance_id;
	int pin_id;
};

struct AUDIO_RPC_SENDPIN_LONG {
	int instance_id;
	int pin_id;
	int data;
};

struct AUDIO_RPC_INSTANCE {
	int instance_id;
	int type;
};

struct RPCRES {
	int result;
	int data;
};

enum ENUM_AUDIO_HDMI_EDID_ENABLE {
	ENUM_AUDIO_EDID_DISABLE = 0,
	ENUM_AUDIO_EDID_ENABLE = 1,
	ENUM_AUDIO_EDID_START = 2,
	ENUM_AUDIO_EDID_END = 3,
};

struct AUDIO_RPC_CONNECTION {
	int src_instance;
	int src_pin;
	int des_instance;
	int des_pin;
	int mediatype;
};

struct RPC_RBUF_HEADER {
	int instance_id;
	int pin_id;
	int rbuf_list[8]; /* ringbuffer list */
	int rd_idx; /* read index */
	int listsize;
};

/* downmix could be placed on in-band queue */
/* set media type or private information to in-band queue */
enum AUDIO_INBAND_CMD_TYPE {

	/* Audio Decoder In-band Command */
	AUDIO_DEC_INBAND_CMD_TYPE_PTS = 0,

	/* let begin_AGC_gain = 1 */
	AUDIO_DEC_INBAND_CMD_TYPE_NEW_SEG = 1,
	AUDIO_DEC_INBAMD_CMD_TYPE_NEW_FORMAT = 2,

	/* Can not be passed, sent back to system */
	AUDIO_DEC_INBAND_CMD_TYPE_EOS = 3,

	/* write debug information, need a RPC_ToSystem command
	Can not be passed, sent back to system */
	AUDIO_DEC_INBAND_CMD_TYPE_CONTEXT = 4,

	/* Information for each decoder is inclueded */
	AUDIO_DEC_INBAND_CMD_TYPE_DECODE = 5,
	AUDIO_DEC_INABND_CMD_TYPE_PTS_SKIP = 6,
	AUDIO_DEC_INBAND_CMD_TYPE_PRIVATE_INFO = 7,

	/* Information about vorbis packets */
	AUDIO_DEC_INBAND_CMD_TYPE_VORBIS_PACKETINFO = 8,

	AUDIO_DEC_INBAND_CMD_TYPE_BS_DISCONTINUITY = 9,
	AUDIO_DEC_INBAND_CMD_TYPE_RESYNC = 10,
	AUDIO_DEC_INBAND_CMD_TYPE_CGMS_INFO = 11,
	AUDIO_DEC_INBAND_CMD_TYPE_RALSD_INFO = 12,
	AUDIO_DEC_INBAND_CMD_TYPE_WMAPRO_DRC = 13,
	AUDIO_DEC_INBAND_CMD_TYPE_WMAPRO_DWNMIX_MTRX = 14,

	/* for lpcm emphasis info */
	AUDIO_DEC_INBAND_CMD_TYPE_EMPHASIS = 15,

	/* Audio AO Mixer In-band Command */
	AUDIO_AO_MIXER_INBAND_CMD_TYPE_SET_MIXER_RPTS = 64,
	AUDIO_AO_MIXER_INBAND_CMD_TYPE_SET_BLEND,

	/* Audio DV Mixer In-band Command */
	AUDIO_DV_MIXER_INBAND_CMD_TYPE_SET_BLEND
};

enum AUDIO_DEC_TYPE {
	AUDIO_UNKNOWN_TYPE = 0,
	AUDIO_MPEG_DECODER_TYPE = 1,
	AUDIO_AC3_DECODER_TYPE = 2,
	AUDIO_LPCM_DECODER_TYPE = 3,
	AUDIO_DTS_DECODER_TYPE = 4,
	AUDIO_WMA_DECODER_TYPE = 5,
	AUDIO_AAC_DECODER_TYPE = 6,
	AUDIO_VORBIS_DECODER_TYPE = 7,
	AUDIO_DV_DECODER_TYPE = 8,
	AUDIO_MLP_DECODER_TYPE = 9,
	AUDIO_DDP_DECODER_TYPE = 10,
	AUDIO_DTS_HD_DECODER_TYPE = 11,
	AUDIO_WMA_PRO_DECODER_TYPE = 12,
	AUDIO_MP4AAC_DECODER_TYPE = 13,
	AUDIO_MP3_PRO_DECODER_TYPE = 14,
	AUDIO_MP4HEAAC_DECODER_TYPE = 15,
	AUDIO_RAW_AAC_DECODER_TYPE = 16,
	AUDIO_RA1_DECODER_TYPE = 17,
	AUDIO_RA2_DECODER_TYPE = 18,
	AUDIO_ATRAC3_DECODER_TYPE = 19,
	AUDIO_COOK_DECODER_TYPE = 20,
	AUDIO_LSD_DECODER_TYPE = 21,
	AUDIO_ADPCM_DECODER_TYPE = 22,
	AUDIO_FLAC_DECODER_TYPE = 23,
	AUDIO_ULAW_DECODER_TYPE = 24,
	AUDIO_ALAW_DECODER_TYPE = 25,
	AUDIO_ALAC_DECODER_TYPE = 26,
	AUDIO_DTS_HIGH_RESOLUTION_DECODER_TYPE = 27,
	AUDIO_DTS_LBR_DECODER_TYPE = 28,
	AUDIO_DTS_MASTER_AUDIO_DECODER_TYPE = 29,
	AUDIO_AMR_DECODER_TYPE = 30,
	AUDIO_MIDI_DECODER_TYPE = 31,
	AUDIO_APE_DECODER_TYPE = 32,
	AUDIO_AVS_DECODER_TYPE = 33,
	AUDIO_NELLYMOSER_DECODER_TYPE = 34,
	AUDIO_WMA_LOSSLESS_DECODER_TYPE = 35,
	AUDIO_UNCERTAIN_DECODER_TYPE = 36,
	AUDIO_UNCERTAIN_HDMV_DECODER_TYPE = 37,
	AUDIO_ILBC_DECODER_TYPE = 38,
};

struct AUDIO_INBAND_CMD_PKT_HEADER {
	enum AUDIO_INBAND_CMD_TYPE type;
	int size;
};

struct AUDIO_DEC_NEW_FORMAT {
	struct AUDIO_INBAND_CMD_PKT_HEADER header;
	unsigned int w_ptr;
	enum AUDIO_DEC_TYPE audiotype;
	/* note: privateinfo[6] is used for choosing decoder sync pts method */
	int pri_info[8];
};

struct AUDIO_DEC_EOS {
	struct AUDIO_INBAND_CMD_PKT_HEADER header;
	unsigned int w_ptr;
	int EOSID;	/* ID associated with command */
};

enum AUDIO_MODULE_TYPE {
	AUDIO_OUT = 7,
	AUDIO_IN = 8,
	AUDIO_ENCODER = 9,
	AUDIO_MPEG_ENCODER = 10,
	AUDIO_PSEUDO_OUT = 14,
	AUDIO_PP_OUT = 15,
	AUDIO_DECODER = 16,
	AUDIO_UNKNOWN = 17,
	AUDIO_LPCM_ENCODER = 19,
	AUDIO_AAC_ENCODER = 21,
	AUDIO_MP3_ENCODER = 22,
	AUDIO_RV_PARSER = 23,
	AUDIO_AC3_ENCODER = 24,
	AUDIO_VIENNA_OUT = 25,
	AUDIO_DTS_ENCODER = 26,
};

enum AUDIO_IO_PIN {
	BASE_BS_IN = 0,
	EXT_BS_IN = 1,
	PCM_IN = 2,
	BASE_BS_OUT = 3,
	EXT_BS_OUT = 4,
	PCM_OUT = 5,
	SPDIF_IN = 6,
	SPDIF_OUT = 7,
	NON_PCM_OUT = 8,
	INBAND_QUEUE = 9,
	MESSAGE_QUEUE = 10,
	MIC_IN = 11,
	SOUND_EVENT_IN = 12,
	PCM_OUT1 = 13,
	PCM_OUT2 = 14,
	FLASH_AUDIO_PIN_1 = 15,
	FLASH_AUDIO_PIN_2 = 16,
	FLASH_AUDIO_PIN_3 = 17,
	FLASH_AUDIO_PIN_4 = 18,
	FLASH_AUDIO_PIN_5 = 19,
	FLASH_AUDIO_PIN_6 = 20,
	FLASH_AUDIO_PIN_7 = 21,
	FLASH_AUDIO_PIN_8 = 22,
	DWNSTRM_INBAND_QUEUE = 200,
};

/* pin define for AI */
#define PB_OUTPIN PCM_OUT
#define TS_OUTPIN PCM_OUT2
#define ALSA_OUTPIN	BASE_BS_OUT

/* AI format */
enum AUDIO_FORMAT_OF_AI_SEND_TO_ALSA {
	AUDIO_ALSA_FORMAT_16BITS_BE_PCM = 0,
	AUDIO_ALSA_FORMAT_24BITS_BE_PCM = 1,
	AUDIO_ALSA_FORMAT_16BITS_LE_LPCM = 2,
	AUDIO_ALSA_FORMAT_24BITS_LE_LPCM = 3,
};

enum ENUM_AUDIO_BBADC_SRC {
	AUDIO_BBADC_SRC_MUTE_ALL = 0x00FF,
	AUDIO_BBADC_SRC_MIC1 = 0x0001,
	AUDIO_BBADC_SRC_MIC2 = 0x0002,
	AUDIO_BBADC_SRC_AIN1 = 0x0004,
	AUDIO_BBADC_SRC_AIN2 = 0x0008,
	AUDIO_BBADC_SRC_AIN3 = 0x0010,
	AUDIO_BBADC_SRC_AIO1 = 0x0020,
	AUDIO_BBADC_SRC_AIO2 = 0x0040,
	AUDIO_BBADC_SRC_DMIC = 0x0080,
	AUDIO_BBADC_SRC_UNKNOWN = 0x0100,
};

enum AIO_PATH_SRC {
	/*
	* If you want to change this definition.
	* you also need to update AudioRPCBaseDS.x
	* and generate new RPC header file.
	*/
	AIO_PATH_SRC_ATV = 0x00,
	AIO_PATH_SRC_BBADC = 0x01,
	AIO_PATH_SRC_SPDIF = 0x02,
	AIO_PATH_SRC_ID3 = 0x03,
	AIO_PATH_SRC_I2S_PRI_CH12 = 0x04,
	AIO_PATH_SRC_I2S_PRI_CH34 = 0x05,
	AIO_PATH_SRC_I2S_PRI_CH56 = 0x06,
	AIO_PATH_SRC_I2S_PRI_CH78 = 0x07,
	AIO_PATH_SRC_I2S_SEC_CH12 = 0x08,
	AIO_PATH_SRC_ATV_NICAM = 0x09,
	AIO_PATH_SRC_ATV_HDEV = 0x0a,
	AIO_PATH_SRC_DTV = 0x10,
	AIO_PATH_SRC_FILE = 0x20,
	AIO_PATH_SRC_UNKNOWN = 0xFF
};

enum ENUM_AUDIO_BBADC_CLK {
	AUDIO_BBADC_CLK_24M = 0,
	AUDIO_BBADC_CLK_49M = 1,
	AUDIO_BBADC_CLK_98M = 2,
};

enum ENUM_AUDIO_I2SI_ID {
	AUDIO_I2SI_ID_PRIMARY = 0,
	AUDIO_I2SI_ID_SECOND = 1,
};

enum ENUM_AUDIO_I2SI_SRC {
	AUDIO_I2SI_SRC_IN = 0,
	AUDIO_I2SI_SRC_HDMI = 1,
	AUDIO_I2SI_SRC_LOOPBACK = 2,
	AUDIO_I2SI_SRC_DISABLE = 3,
};

enum ENUM_AUDIO_I2SI_MODE {
	AUDIO_I2SI_MODE_SLAVE = 0,
	AUDIO_I2SI_MODE_MASTER = 1,
	AUDIO_I2SI_MODE_NOCARE = 2,
};

enum ENUM_AUDIO_I2SI_SYNC {
	AUDIO_I2SI_SYNC_NORMAL = 0,
	AUDIO_I2SI_SYNC_LEFT = 1,
	AUDIO_I2SI_SYNC_RIGHT = 2,
};

enum ENUM_AUDIO_SPDIFI_SRC {
	AUDIO_SPDIFI_SRC_IN = 0,
	AUDIO_SPDIFI_SRC_HDMI = 1,
	AUDIO_SPDIFI_SRC_LOOPBACK = 2,
	AUDIO_SPDIFI_SRC_DISABLE = 3,
};

enum ENUM_AUDIO_CHANNEL_IDX {
	AUDIO_CH_IDX_0 = 0x01,
	AUDIO_CH_IDX_1 = 0x02,
	AUDIO_CH_IDX_2 = 0x04,
	AUDIO_CH_IDX_3 = 0x08,
	AUDIO_CH_IDX_4 = 0x10,
	AUDIO_CH_IDX_5 = 0x20,
	AUDIO_CH_IDX_6 = 0x40,
	AUDIO_CH_IDX_7 = 0x80,
};

enum AUDIO_ENUM_PRIVAETINFO {
	ENUM_PRIVATEINFO_AUDIO_FORMAT_PARSER_CAPABILITY = 0,
	ENUM_PRIVATEINFO_AUDIO_DECODER_CAPABILITY = 1,
	ENUM_PRIVATEINFO_AUDIO_CONFIG_CMD_BS_INFO = 2,
	ENUM_PRIVATEINFO_AUDIO_CHECK_LPCM_ENDIANESS = 3,
	ENUM_PRIVATEINFO_AUDIO_CONFIG_CMD_AO_DELAY_INFO = 4,
	ENUM_PRIVATEINFO_AUDIO_AO_CHANNEL_VOLUME_LEVEL = 5,
	ENUM_PRIVATEINFO_AUDIO_GET_FLASH_PIN = 6,
	ENUM_PRIVATEINFO_AUDIO_RELEASE_FLASH_PIN = 7,
	ENUM_PRIVATEINFO_AUDIO_GET_MUTE_N_VOLUME = 8,
	ENUM_PRIVATEINFO_AUDIO_AO_MONITOR_RCD_DRIFT = 9,
	ENUM_PRIVATEINFO_AUDIO_CONTROL_FLASH_VOLUME = 10,
	ENUM_PRIVATEINFO_AUDIO_CONTROL_DAC_SWITCH = 11,
	ENUM_PRIVATEINFO_AUDIO_CONTROL_AO_GIVE_UP_SET_CLOCK = 12,
	ENUM_PRIVATEINFO_AUDIO_DEC_DELAY_RP = 13,
	ENUM_PRIVATEINFO_AUDIO_AI_SET_OUT_FMT = 14,
	ENUM_PRIVATEINFO_AUDIO_AI_SWITCH_FOCUS = 15,
	ENUM_PRIVATEINFO_AUDIO_SUPPORT_SAMPLERATE = 16,
	ENUM_PRIVATEINFO_AUDIO_GET_AVAILABLE_AO_OUTPUT_PIN = 17,
	ENUM_PRIVATEINFO_AUDIO_GET_PCM_IN_PIN = 18,
	ENUM_PRIVATEINFO_AUDIO_RELEASE_PCM_IN_PIN = 19,
	ENUM_PRIVATEINFO_AUDIO_FIRMWARE_CAPABILITY = 20,
	ENUM_PRIVATEINFO_AUDIO_SRC_PROCESS_DONE = 21,
	ENUM_PRIVATEINFO_AUDIO_DEC_SRC_ENABLE = 22,
	ENUM_PRIVATEINFO_AUDIO_QUERY_FLASH_PIN = 23,
	ENUM_PRIVATEINFO_AUDIO_SET_FLASH_PIN = 24,
	ENUM_PRIVATEINFO_AUDIO_SET_SYSTEM_PROCESS_PID = 25,
	ENUM_PRIVATEINFO_AUDIO_HANDLE_VIRTUAL_X_PARAM = 26,
};


struct RPC_PRI_PARAM {
	int instance_id;
	enum AUDIO_ENUM_PRIVAETINFO type;
	int pri_info[16];
};

struct RPC_PRI_RET {
	int instance_id;
	int pri_info[16];
};

enum AUDIO_ENDIANTYPE {
	AUDIO_BIG_ENDIAN = 0,
	AUDIO_LITTLE_ENDIAN = 1,
	AUDIO_LPCM_DHMV_TYPE = 2,
};

enum AUDIO_CHANNEL_OUT_INDEX {
	AUDIO_NULL_CHANNEL_INDEX = 0,
	AUDIO_LEFT_FRONT_INDEX = 1,
	AUDIO_RIGHT_FRONT_INDEX = 2,
	AUDIO_CENTER_FRONT_INDEX = 5,
	AUDIO_LFE_INDEX = 6,
	AUDIO_LEFT_SURROUND_REAR_INDEX = 3,
	AUDIO_RIGHT_SURROUND_REAR_INDEX = 4,
	AUDIO_LEFT_OUTSIDE_FRONT_INDEX = 7,
	AUDIO_RIGHT_OUTSIDE_FRONT_INDEX = 8,
	AUDIO_SPDIF_LEFT_CHANNEL_INDEX = 9,
	AUDIO_SPDIF_RIGHT_CHANNEL_INDEX = 10,
	AUDIO_SURROUND_INDEX = 11,
	AUDIO_CENTER_SURROUND_REAR_INDEX = 12,
	AUDIO_OVERHEAD_INDEX = 13,
	AUDIO_LEFT_SURROUND_INDEX = 14,
	AUDIO_RIGHT_SURROUND_INDEX = 15,
	AUDIO_LEFT_FRONT_HIGH_INDEX = 16,
	AUDIO_RIGHT_FRONT_HIGH_INDEX = 17,
	AUDIO_LEFT_INNER_FRONT_INDEX = 18,
	AUDIO_RIGHT_INNER_FRONT_INDEX = 19,
	AUDIO_LEFT_REAR_INDEX = 20,
	AUDIO_RIGHT_REAR_INDEX = 21,
	AUDIO_LEFT_SURROUND_DIRECT_INDEX = 22,
	AUDIO_RIGHT_SURROUND_DIRECT_INDEX = 23,
	AUDIO_CENTER_FRONT_HIGH_INDEX = 24,
	AUDIO_LFE2_INDEX = 25,
	AUDIO_SPDIF_NON_PCM_TYPE = 256,
	AUDIO_ENABLE_DOWNMIX = 257,
};

/* Ring Buffer header is the shared memory structure for DSP use*/
struct RBUF_HEADER {
	unsigned int magic;   /* Magic number */
	unsigned int begin_addr;
	unsigned int size;

	/* RINGBUFFER_TYPE, choose a type from RINGBUFFER_TYPE */
	unsigned int buf_id;

	unsigned int wr_ptr;
	unsigned int num_rd_ptr;
	unsigned int reserve2;  /* Reserve for Red Zone */
	unsigned int reserve3;  /* Reserve for Red Zone */

	unsigned int rd_ptr[4];

	int file_offset;
	int req_file_offset;
	int file_size;

	/* Can't be sought if data is streamed by HTTP */
	int b_seekable;
/*
file_offset:
	the offset to the streaming file from the beginning of the file.
	It is set by system to tell FW that the current streaming is
	starting from ¡¥file_offset¡¦ bytes. For example,
	the TIFF file display will set fileOffset to 0 at beginning.

req_file_offset:
	the offset to be set by video firmware, to request system
	to seek to other place.
	The initial is -1.When it is not equal to -1, that means FW
	side is requesting a new seek.

file_size:
	file size. At current implementation,
	only TIFF decode needs the file_size,
	other decoding does not pay attention to this field

	the behavior for TIFF seek:
	At the initial value, FileOffset = 0, or at any initial offset
	(for example, resume from bookmark), RequestedFileOffset=-1.
	FileSize= file size.
	1. If FW needs to perform seek operation, FW set RequestedFileOffset
	to the value it need to seek.
	2. Once system see RequestedOffset is not -1,
	system reset the ring buffer
	(FW need to make sure it will not use ring buffer
	after request the seek),
	set FileOffset to the new location (the value of RequestedFileOffset),
	then set RequestedOffset  to -1. From now on, system will stream data
	from byte FileOffset of the file.
	3. FW needs to wait until RequestedOffset== -1, then check the value
	inside FileOffset. If FileOffset is -1, that means read out of bound.
	If system already finish the streaming before FW issue a seek, system
	will still continue polling.
*/
};

/* Ring Buffer header is the shared memory structure for arm use */
struct RBUF_HEADER_ARM {
	unsigned long magic;
	unsigned long begin_addr;
	unsigned long size;

	unsigned long buf_id;

	unsigned long wr_ptr;
	unsigned long num_rd_ptr;
	unsigned long reserve2;
	unsigned long reserve3;

	unsigned long rd_ptr[4];

	long file_offset;
	long req_file_offset;
	long file_size;

	long b_seekable;
};
#endif
